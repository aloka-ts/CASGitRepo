package com.agnity.inapitutcs2.operations;import com.agnity.inapitutcs2.asngenerated.*;import com.agnity.inapitutcs2.datatypes.ErrorRejectTypeArg;import com.agnity.inapitutcs2.datatypes.RestartNodeId;import com.agnity.inapitutcs2.enumdata.ErrorRejectEnum;import com.agnity.inapitutcs2.util.Util;import jain.protocol.ss7.SignalingPointCode;import jain.protocol.ss7.tcap.ComponentIndEvent;import jain.protocol.ss7.tcap.TcapConstants;import jain.protocol.ss7.tcap.component.*;import org.apache.log4j.Logger;import org.bn.CoderFactory;import org.bn.IDecoder;import org.bn.IEncoder;import org.bn.exceptions.IndefiniteLengthNotSupportedException;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.InputStream;import java.util.*;/** * This class contains methods for decoding and encoding of * <p> * INAP operations (i.e. InitialDp, connect etc.). * * @author Mriganka */public class InapOperationsCoding {    private static Logger logger = Logger.getLogger(InapOperationsCoding.class);    static public void warmup() {        try {            logger.error("InapOperationsCoding...starting warmup.");            String bufferIDP = "306680012c82078610219091330783078313535515110185010aab068001008101028e0100af3530330201fea12e302c810481230000820783142190913307830f02fb05fe03000231f805fe030022538404fd01fc088504812300009a022001bb038101009c0103";            String bufferSCI = "300e8007af05a003800101a103800101";            String bufferRNCE = "301b3019800faf0da00ba0090a01000a01020a0103810101a203800102";            String bufferRRBE = "3039a0373006800107810101300b800106810100be03810114300b800109810101a203800101300b800109810101a203800102300680010a810101";            String bufferConnect = "302da009040703108999999999aa1830160201ff0a0100a10e300ca10a800802fa05fe03000231af068701008b0100";            String bufferENC = "3042800faf0da00ba0090a01000a01020a0103812aaf28a026a024801800fc05fe03000231fe0efe03002253fd0480230000fc010282021604830481230000a203810102";            String bufferERB = "3018800109a209a7078002849081017da303810101a403800101";            //String bufferRC = "01060D020010C930";            //String bufferER = "60a003800101";            Object objLinkListIDP = decodeOperationsForOpCode(hexStringToByteArray(bufferIDP), InapOpCodes.IDP);            Object objLinkListSCI = decodeOperationsForOpCode(hexStringToByteArray(bufferSCI), InapOpCodes.SCI);            Object objLinkListRNCE = decodeOperationsForOpCode(hexStringToByteArray(bufferRNCE), InapOpCodes.RNCE);            Object objLinkListRRBE = decodeOperationsForOpCode(hexStringToByteArray(bufferRRBE), InapOpCodes.RRBE);            Object objLinkListCONNECT = decodeOperationsForOpCode(hexStringToByteArray(bufferConnect), InapOpCodes.CONNECT);            Object objLinkListENC = decodeOperationsForOpCode(hexStringToByteArray(bufferENC), InapOpCodes.ENC);            Object objLinkListERB = decodeOperationsForOpCode(hexStringToByteArray(bufferERB), InapOpCodes.ERB);            //Object objLinkListRC = decodeOperationsForOpCode(hexStringToByteArray(bufferRC), InapOpCodes.RELEASE_CALL);            //Object objLinkListER = decodeOperationsForOpCode(hexStringToByteArray(bufferER), InapOpCodes.ER);            LinkedList<Object> opObjLinkList = new LinkedList<Object>();            opObjLinkList.add(objLinkListIDP);            opObjLinkList.add(objLinkListSCI);            opObjLinkList.add(objLinkListRNCE);            opObjLinkList.add(objLinkListRRBE);            opObjLinkList.add(objLinkListCONNECT);            opObjLinkList.add(objLinkListENC);            opObjLinkList.add(objLinkListERB);            //opObjLinkList.add(objLinkListRC);            //opObjLinkList.add(objLinkListER);            LinkedList<String> opCodesLinkList = new LinkedList<String>();            opCodesLinkList.add(InapOpCodes.IDP);            opCodesLinkList.add(InapOpCodes.SCI);            opCodesLinkList.add(InapOpCodes.RNCE);            opCodesLinkList.add(InapOpCodes.RRBE);            opCodesLinkList.add(InapOpCodes.CONNECT);            opCodesLinkList.add(InapOpCodes.ENC);            opCodesLinkList.add(InapOpCodes.ERB);            //opCodesLinkList.add(InapOpCodes.RELEASE_CALL);            //opCodesLinkList.add(InapOpCodes.ER);            LinkedList<byte[]> byteArrayLinkList = encodeOperations(opObjLinkList, opCodesLinkList);            logger.error("InapOperationsCoding...leaving warmup.");        } catch (Exception e) {            logger.error("ISUPOperationsCoding...inside warmup...", e);        }    }    /**     * This method will decode the INAP operations and will return the     * <p>     * object (of class generated from ASN) as per operation code.     *     * @param singleOpBuffer     * @param singleOpCode     * @return Object     * @throws Exception     */    public static Object decodeOperationsForOpCode(byte[] singleOpBuffer, String singleOpCode) throws Exception {        if (logger.isInfoEnabled()) {            logger.info("decodeOperationsForOpCode:Enter");        }        if (logger.isDebugEnabled()) {            logger.debug("decodeOperationsForOpCode:Input ---> opCode:" + singleOpCode +            		", Bytes:" +  Util.formatBytes(singleOpBuffer));        }        Object out = null;        IDecoder decoder;        decoder = CoderFactory.getInstance().newDecoder("BER");        if (logger.isInfoEnabled()) {            logger.info("decodeOperationsForOpCode:decoder");        }        InputStream ins = new ByteArrayInputStream(singleOpBuffer);        if (singleOpCode.equalsIgnoreCase(InapOpCodes.IDP)) {            if (logger.isInfoEnabled()) {                logger.info("decodeOperationsForOpCode:decoding initialDP");            }            out = decoder.decode(ins, InitialDPArg.class);        } else if (singleOpCode.equalsIgnoreCase(InapOpCodes.ENC)) {            if (logger.isInfoEnabled()) {                logger.info("decodeOperationsForOpCode:decoding ENC");            }            out = decoder.decode(ins, EventNotificationChargingArg.class);        } else if (singleOpCode.equalsIgnoreCase(InapOpCodes.ERB)) {            if (logger.isInfoEnabled()) {                logger.info("decodeOperationsForOpCode:decoding ERB");            }            out = decoder.decode(ins, EventReportBCSMArg.class);        } else if (singleOpCode.equalsIgnoreCase(InapOpCodes.CONNECT)) {            if (logger.isInfoEnabled()) {                logger.info("decodeOperationsForOpCode:decoding CON");            }            out = decoder.decode(ins, ConnectArg.class);        } else if (singleOpCode.equalsIgnoreCase(InapOpCodes.SCI)) {            if (logger.isInfoEnabled()) {                logger.info("decodeOperationsForOpCode:decoding SCI");            }            out = decoder.decode(ins, SendChargingInformationArg.class);        } else if (singleOpCode.equalsIgnoreCase(InapOpCodes.FCI)) {            if (logger.isInfoEnabled()) {                logger.info("decodeOperationsForOpCode:decoding FCI");            }            out = decoder.decode(ins, FurnishChargingInformationArg.class);        } else if (singleOpCode.equalsIgnoreCase(InapOpCodes.RNCE)) {            if (logger.isInfoEnabled()) {                logger.info("decodeOperationsForOpCode:decoding RNCE");            }            out = decoder.decode(ins, RequestNotificationChargingEventArg.class);        } else if (singleOpCode.equalsIgnoreCase(InapOpCodes.RRBE)) {            if (logger.isInfoEnabled()) {                logger.info("decodeOperationsForOpCode:decoding RRBE");            }            out = decoder.decode(ins, RequestReportBCSMEventArg.class);        } else if (singleOpCode.equalsIgnoreCase(InapOpCodes.ETC)) {            if (logger.isInfoEnabled()) {                logger.info("decodeOperationsForOpCode:decoding ETC");            }            out = decoder.decode(ins, EstablishTemporaryConnectionArg.class);        } else if (singleOpCode.equalsIgnoreCase(InapOpCodes.DFC)) {            if (logger.isInfoEnabled()) {                logger.info("decodeOperationsForOpCode:decoding DFC");            }            out = decoder.decode(ins, DisconnectForwardConnectionWithArgumentArg.class);        } else if (singleOpCode.equalsIgnoreCase(InapOpCodes.ER)) {            if (logger.isInfoEnabled()) {                logger.info("decodeOperationsForOpCode:decoding ER");            }            out = decoder.decode(ins, EntityReleasedArg.class);        } else if (singleOpCode.equalsIgnoreCase(InapOpCodes.RESTART_NOTIFICATION)) {            if (logger.isInfoEnabled()) {                logger.info("decodeOperationsForOpCode:decoding RESTART_NOTIFICATION");            }            //out = decoder.decode(ins, RestartNotificationArg.class);        } else if (singleOpCode.equalsIgnoreCase(InapOpCodes.RESTART_NOTIFICATION_ACK)) {            if (logger.isInfoEnabled()) {                logger.info("decodeOperationsForOpCode:decoding RESTART_NOTIFICATION_ACK");            }            //out = decoder.decode(ins, RestartNotificationAcknowledgementArg.class);        } else if (singleOpCode.equalsIgnoreCase(InapOpCodes.RELEASE_CALL)) {            if (logger.isInfoEnabled()) {                logger.info("decodeOperationsForOpCode:decoding Release Call");            }            out = decoder.decode(ins, ReleaseCallArg.class);        } else if (singleOpCode.equalsIgnoreCase(InapOpCodes.PA)) {            if (logger.isInfoEnabled()) {                logger.info("decodeOperationsForOpCode:decoding Play Announcement");            }            out = decoder.decode(ins, PlayAnnouncementArg.class);        } else if (singleOpCode.equalsIgnoreCase(InapOpCodes.PAC)) {            if (logger.isInfoEnabled()) {                logger.info("decodeOperationsForOpCode:decoding Prompt & Collect Announcement");            }            out = decoder.decode(ins, PromptAndCollectUserInformationArg.class);        } else if (singleOpCode.equalsIgnoreCase(InapOpCodes.SRR)) {            if (logger.isInfoEnabled()) {                logger.info("decodeOperationsForOpCode:decoding Specialized Resource Report");            }            out = decoder.decode(ins, SpecializedResourceReportArg.class);        } else if (singleOpCode.equalsIgnoreCase(InapOpCodes.CONNECT_TO_RESOURCE)) {            if (logger.isInfoEnabled()) {                logger.info("decodeOperationsForOpCode:decoding CTR");            }            out = decoder.decode(ins, ConnectToResourceArg.class);        }        if (logger.isInfoEnabled()) {            logger.info("decodeOperationsForOpCode:Exit");        }        return out;    }    public static byte[] hexStringToByteArray(String s) {        int len = s.length();        byte[] data = new byte[len / 2];        for (int i = 0; i < len; i += 2) {            data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) << 4) + Character.digit(s.charAt(i + 1), 16));        }        return data;    }    /**     * This method will encode the INAP operations and will return the list of encoded byte[].     * <p>     * Operation codes are needed as input to get to know the type of incoming object.     *     * @param opObjects     * @param opCodes     * @return LinkedList<byte[]>     * @throws Exception     */    public static LinkedList<byte[]> encodeOperations(LinkedList<Object> opObjects, LinkedList<String> opCodes) throws Exception {        if (logger.isInfoEnabled()) {            logger.info("encodeOperations:Enter");        }        if (logger.isDebugEnabled()) {            logger.debug("encodeOperations:Input ---> opCodes:" + opCodes);        }        LinkedList<byte[]> outList = new LinkedList<byte[]>();        for (int i = 0; i < opCodes.size(); i++) {            Object singleOpObj = opObjects.get(i);            String singleOpCode = opCodes.get(i);            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();            if (singleOpCode.equalsIgnoreCase(InapOpCodes.SCI)) {                if (logger.isInfoEnabled()) {                    logger.info("encodeOperations:encoding SCI");                }                IEncoder<SendChargingInformationArg> encoder = CoderFactory.getInstance().newEncoder("BER");                encoder.encode((SendChargingInformationArg) singleOpObj, outputStream);                outList.add(outputStream.toByteArray());            } else if (singleOpCode.equalsIgnoreCase(InapOpCodes.RNCE)) {                if (logger.isInfoEnabled()) {                    logger.info("encodeOperations:encoding RNCE");                }                IEncoder<RequestNotificationChargingEventArg> encoder = CoderFactory.getInstance().newEncoder("BER");                encoder.encode((RequestNotificationChargingEventArg) singleOpObj, outputStream);                outList.add(outputStream.toByteArray());            } else if (singleOpCode.equalsIgnoreCase(InapOpCodes.RRBE)) {                if (logger.isInfoEnabled()) {                    logger.info("encodeOperations:encoding RRBE");                }                IEncoder<RequestReportBCSMEventArg> encoder = CoderFactory.getInstance().newEncoder("BER");                encoder.encode((RequestReportBCSMEventArg) singleOpObj, outputStream);                outList.add(outputStream.toByteArray());            } else if (singleOpCode.equalsIgnoreCase(InapOpCodes.CONNECT)) {                if (logger.isInfoEnabled()) {                    logger.info("encodeOperations:encoding CON");                }                IEncoder<ConnectArg> encoder = CoderFactory.getInstance().newEncoder("BER");                encoder.encode((ConnectArg) singleOpObj, outputStream);                outList.add(outputStream.toByteArray());            } else if (singleOpCode.equalsIgnoreCase(InapOpCodes.ETC)) {                if (logger.isInfoEnabled()) {                    logger.info("encodeOperations:encoding ETC");                }                IEncoder<EstablishTemporaryConnectionArg> encoder = CoderFactory.getInstance().newEncoder("BER");                encoder.encode((EstablishTemporaryConnectionArg) singleOpObj, outputStream);                outList.add(outputStream.toByteArray());            } else if (singleOpCode.equalsIgnoreCase(InapOpCodes.DFC)) {                if (logger.isInfoEnabled()) {                    logger.info("encodeOperations:encoding DFC");                }                IEncoder<DisconnectForwardConnectionWithArgumentArg> encoder = CoderFactory.getInstance().newEncoder("BER");                encoder.encode((DisconnectForwardConnectionWithArgumentArg) singleOpObj, outputStream);                outList.add(outputStream.toByteArray());            } else if (singleOpCode.equalsIgnoreCase(InapOpCodes.DISCONNECT_LEG)) {                if (logger.isInfoEnabled()) {                    logger.info("encodeOperations:encoding Disconnect Leg");                }                IEncoder<DisconnectLegArg> encoder = CoderFactory.getInstance().newEncoder("BER");                encoder.encode((DisconnectLegArg) singleOpObj, outputStream);                outList.add(outputStream.toByteArray());            } else if (singleOpCode.equalsIgnoreCase(InapOpCodes.CONTINUE)) {                if (logger.isInfoEnabled()) {                    logger.info("encodeOperations:encoding Continue");                }                IEncoder<ContinueWithArgumentArg> encoder = CoderFactory.getInstance().newEncoder("BER");                encoder.encode((ContinueWithArgumentArg) singleOpObj, outputStream);                outList.add(outputStream.toByteArray());            }                        //added for JUnit testing (generally decoding is done)            if (singleOpCode.equalsIgnoreCase(InapOpCodes.IDP)) {                if (logger.isInfoEnabled()) {                    logger.info("encodeOperations:encoding IDP");                }                IEncoder<InitialDPArg> encoder = CoderFactory.getInstance().newEncoder("BER");                encoder.encode((InitialDPArg) singleOpObj, outputStream);                outList.add(outputStream.toByteArray());            }            if (singleOpCode.equalsIgnoreCase(InapOpCodes.ENC)) {                if (logger.isInfoEnabled()) {                    logger.info("encodeOperations:encoding ENC");                }                IEncoder<EventNotificationChargingArg> encoder = CoderFactory.getInstance().newEncoder("BER");                encoder.encode((EventNotificationChargingArg) singleOpObj, outputStream);                outList.add(outputStream.toByteArray());            }            if (singleOpCode.equalsIgnoreCase(InapOpCodes.ERB)) {                if (logger.isInfoEnabled()) {                    logger.info("encodeOperations:encoding ERB");                }                IEncoder<EventReportBCSMArg> encoder = CoderFactory.getInstance().newEncoder("BER");                encoder.encode((EventReportBCSMArg) singleOpObj, outputStream);                outList.add(outputStream.toByteArray());            }            if (singleOpCode.equalsIgnoreCase(InapOpCodes.ER)) {                if (logger.isInfoEnabled()) {                    logger.info("encodeOperations:encoding ER");                }                IEncoder<EntityReleasedArg> encoder = CoderFactory.getInstance().newEncoder("BER");                encoder.encode((EntityReleasedArg) singleOpObj, outputStream);                outList.add(outputStream.toByteArray());            }            if (singleOpCode.equalsIgnoreCase(InapOpCodes.RELEASE_CALL)) {                if (logger.isInfoEnabled()) {                    logger.info("encodeOperations:encoding RELEASE CALL");                }                IEncoder<ReleaseCallArg> encoder = CoderFactory.getInstance().newEncoder("BER");                encoder.encode((ReleaseCallArg) singleOpObj, outputStream);                outList.add(outputStream.toByteArray());            }            if (singleOpCode.equalsIgnoreCase(InapOpCodes.FCI)) {                if (logger.isInfoEnabled()) {                    logger.info("encodeOperations:encoding FCI");                }                IEncoder<FurnishChargingInformationArg> encoder = CoderFactory.getInstance().newEncoder("BER");                encoder.encode((FurnishChargingInformationArg) singleOpObj, outputStream);                outList.add(outputStream.toByteArray());            }            if (singleOpCode.equalsIgnoreCase(InapOpCodes.PA)) {                if (logger.isInfoEnabled()) {                    logger.info("encodeOperations:encoding PA");                }                IEncoder<PlayAnnouncementArg> encoder = CoderFactory.getInstance().newEncoder("BER");                encoder.encode((PlayAnnouncementArg) singleOpObj, outputStream);                outList.add(outputStream.toByteArray());            }            if (singleOpCode.equalsIgnoreCase(InapOpCodes.PAC)) {                if (logger.isInfoEnabled()) {                    logger.info("encodeOperations:encoding PAC");                }                IEncoder<PromptAndCollectUserInformationArg> encoder = CoderFactory.getInstance().newEncoder("BER");                encoder.encode((PromptAndCollectUserInformationArg) singleOpObj, outputStream);                outList.add(outputStream.toByteArray());            }            if (singleOpCode.equalsIgnoreCase(InapOpCodes.SRR)) {                if (logger.isInfoEnabled()) {                    logger.info("encodeOperations:encoding SRR");                }                IEncoder<SpecializedResourceReportArg> encoder = CoderFactory.getInstance().newEncoder("BER");                encoder.encode((SpecializedResourceReportArg) singleOpObj, outputStream);                outList.add(outputStream.toByteArray());            }            if (singleOpCode.equalsIgnoreCase(InapOpCodes.CONNECT_TO_RESOURCE)) {                if (logger.isInfoEnabled()) {                    logger.info("encodeOperations:encoding CTR");                }                IEncoder<ConnectToResourceArg> encoder = CoderFactory.getInstance().newEncoder("BER");                encoder.encode((ConnectToResourceArg) singleOpObj, outputStream);                outList.add(outputStream.toByteArray());            }            if (singleOpCode.equalsIgnoreCase(InapOpCodes.RESET_TIMER)) {                if (logger.isInfoEnabled()) {                    logger.info("encodeOperations:encoding ResetTimer");                }                IEncoder<ResetTimerArg> encoder = CoderFactory.getInstance().newEncoder("BER");                encoder.encode((ResetTimerArg) singleOpObj, outputStream);                outList.add(outputStream.toByteArray());            }        }        if (logger.isInfoEnabled()) {            logger.info("encodeOperations:Exit");        }        return outList;    }    public static Object decodeResultOperationsForOpCode(byte[] singleOpBuffer, String singleOpCode) throws Exception {        if (logger.isInfoEnabled()) {            logger.info("decodeResultOperationsForOpCode:Enter");        }        if (logger.isDebugEnabled()) {            logger.debug("decodeResultOperationsForOpCode:Input ---> opCode:" + singleOpCode);        }        Object out = null;        IDecoder decoder;        decoder = CoderFactory.getInstance().newDecoder("BER");        if (logger.isInfoEnabled()) {            logger.info("decodeResultOperationsForOpCode:decoder");        }        InputStream ins = new ByteArrayInputStream(singleOpBuffer);        if (singleOpCode.equalsIgnoreCase(InapOpCodes.PAC)) {            if (logger.isInfoEnabled()) {                logger.info("decodeResultOperationsForOpCode:decoding initialDP");            }            out = decoder.decode(ins, ReceivedInformationArg.class);        } else {            logger.warn("Unsupported result operation!");        }        if (logger.isInfoEnabled()) {            logger.info("decodeResultOperationsForOpCode:Exit");        }        return out;    }    public static Object decodeOperation(byte[] opBuffer, EventObject eventObject) throws Exception {        if (logger.isInfoEnabled()) {            logger.info("decodeOperation:Enter");        }        if (logger.isDebugEnabled()) {            logger.debug("decodeOperation:Input");        }        Object out = null;        ComponentIndEvent cmpReqEvent = (ComponentIndEvent) eventObject;        if (logger.isDebugEnabled()) {            logger.debug("decodeOperation:Primitive: " + cmpReqEvent.getPrimitiveType());        }        try {            switch (cmpReqEvent.getPrimitiveType()) {                case TcapConstants.PRIMITIVE_INVOKE: {                    InvokeIndEvent receivedInvoke = (InvokeIndEvent) cmpReqEvent;                    Operation opr = receivedInvoke.getOperation();                    byte[] opCode = opr.getOperationCode();                    String opCodeStr = Util.formatBytes(opCode);                    out = decodeOperationsForOpCode(opBuffer, opCodeStr);                    break;                }                case TcapConstants.PRIMITIVE_ERROR: {                    if (logger.isDebugEnabled()) {                        logger.debug("decodeOperation:PRIMITIVE_ERROR");                    }                    // casting to ErrorIndEvent for future purpose                    ErrorIndEvent errorInd = (ErrorIndEvent) cmpReqEvent;                    byte[] errorCode = errorInd.getErrorCode();                    int errorType = errorInd.getErrorType();                    if (logger.isDebugEnabled()) {                        logger.debug("decodeOperation:PRIMITIVE_ERROR1");                    }                    ErrorRejectTypeArg errorRejectObj = new ErrorRejectTypeArg();                    errorRejectObj.setErrorRejectEnum(ErrorRejectEnum.ERROR);                    errorRejectObj.setErrorCode(errorCode);                    errorRejectObj.setErrorType(errorType);                    out = errorRejectObj;                    if (logger.isDebugEnabled()) {                        logger.debug("decodeOperation:errorRejectObj: "                                             + errorRejectObj);                    }                    break;                }                case TcapConstants.PRIMITIVE_REJECT: {                    if (logger.isDebugEnabled()) {                        logger.debug("decodeOperation:PRIMITIVE_REJECT");                    }                    // casting to RejectIndEvent for future purpose                    RejectIndEvent rejectInd = (RejectIndEvent) cmpReqEvent;                    int rejectProblem = rejectInd.getProblem();                    int rejectProblemType = rejectInd.getProblemType();                    ErrorRejectTypeArg errorRejectObj = new ErrorRejectTypeArg();                    errorRejectObj.setErrorRejectEnum(ErrorRejectEnum.REJECT);                    errorRejectObj.setRejectProblem(rejectProblem);                    errorRejectObj.setRejectProblemType(rejectProblemType);                    out = errorRejectObj;                    break;                }                case TcapConstants.PRIMITIVE_RESULT: {                    if (logger.isDebugEnabled()) {                        logger.debug("decodeOperation:PRIMITIVE_RESULT");                    }                    ResultIndEvent resultIndEvent = (ResultIndEvent) cmpReqEvent;                    Operation opr = resultIndEvent.getOperation();                    byte[] opCode = opr.getOperationCode();                    String opCodeStr = Util.formatBytes(opCode);                    out = decodeResultOperationsForOpCode(opBuffer, opCodeStr);                    break;                }            }        } catch (IndefiniteLengthNotSupportedException e) {            logger.error("Indefinite length" + e);            out = decodeOperation(createClassForDefiniteBuffer(opBuffer), eventObject);        }        return out;    }    private static byte[] createClassForDefiniteBuffer(byte[] opBuffer) throws IOException {        DefiniteBuffer definiteBuffer = new DefiniteBuffer() {            List<Integer> delimiterIndexList = new ArrayList<Integer>();            int recursionCount = 0;            int messageLength = 0;            boolean needToModifyMsgLength = true;            int indefiniteLengthCounter = 0;            int[] delimiterIndexes = new int[200];            int[] indefiniteLengthCounters = new int[200];            int countIndefinite = 0;            public byte[] createDefiniteBuffer(byte[] opBuffer) throws IOException {                InputStream stream = new ByteArrayInputStream(opBuffer);                int adjustMsgLength = 1;                int newMessageLength = 0;                handleIndefiniteLength(stream, 0, opBuffer);                if (needToModifyMsgLength) {                    adjustMsgLength = adjustMsgLength * (delimiterIndexList.size() * 2);                    newMessageLength = messageLength - adjustMsgLength;                }                byte[] finalBuffer = new byte[opBuffer.length - (delimiterIndexList.size() * 2)];                int j = 0;                for (int i = 0; i < opBuffer.length; i++) {                    if (delimiterIndexList.contains(i)) {                        i++;                    } else {                        if (i == 1 && needToModifyMsgLength) {                            finalBuffer[j] = (byte) (opBuffer[i] - adjustMsgLength);                            if (newMessageLength < 128 && messageLength > 128) {                                //if before adjustment the length of the message is greater than 128                                //and after adjustment less than 128 then remove additional byte from the                                //original array                                i++;                            } else if (newMessageLength > 128 && newMessageLength < 256 && messageLength > 128 && messageLength < 256) {                                //no need just apply the adjustment on the first byte of the length and copy the second one as it is                                continue;                            } else if (newMessageLength < 256 && messageLength > 256) {                                j++;                                finalBuffer[j] = (byte) 129;                                i = i + 2;                            }                        } else {                            finalBuffer[j] = opBuffer[i];                        }                        j++;                    }                }                return finalBuffer;            }            public void handleIndefiniteLength(InputStream stream, int pos, byte[] opBuffer) throws IOException {                while (stream.available() != 0) {                    recursionCount++;                    int tag = stream.read();                    pos++;                    int length = stream.read();                    pos++;                    if (tag == 0 && length == 0) {                        //This is done to ensure that the 00(delimiters) encountered is corresponding to the last 80 indefinite length received.                        //For instance following is the order of receiving the 80s and 00s 80 -> 80-> 00-> 80 -->80--> 00-->80 --> 00 -->00 -->00                        // at if block for length check indefiniteLengthCounters[countIndefinite] = indefiniteLengthCounter; this ensures that                        //1st index has 1, 2nd index has second and the counter (countIndefinite) would be at 2 when first 00 is received and                        //hence the index for this delimiter would be saved corresponding to its position.                        delimiterIndexes[indefiniteLengthCounters[countIndefinite]] = pos - 2;                        countIndefinite--;                        continue;                    }                    if (length == 128) {                        if (recursionCount == 1) {                            messageLength = length;                            //This boolean would be true in case message length is finite                            //as it is a possibility that message with definite length can                            //have indefinite parameters                            needToModifyMsgLength = false;                        }                        indefiniteLengthCounter++;                        countIndefinite++;                        indefiniteLengthCounters[countIndefinite] = indefiniteLengthCounter;                        handleIndefiniteLength(stream, pos, opBuffer);                        if (delimiterIndexList.size() == 0) {                            //only initialization at first recursion out                            for (int i : delimiterIndexes) {                                if (i == 0) {                                    continue;                                } else {                                    delimiterIndexList.add(i);                                }                            }                        }                        System.out.println((pos - 1) + "==" + delimiterIndexes[indefiniteLengthCounter]);                        System.out.println("indefiniteLengthCounter" + indefiniteLengthCounter);                        int countOfInterimDelim = 0;                        //This loop is needed to count the interim delims for the purpose of calcating the number of octets to                        //minus while calculating the length to replace each 80                        for (int i : delimiterIndexList) {                            if (i > pos && i < delimiterIndexes[indefiniteLengthCounter]) {                                countOfInterimDelim++;                            }                        }                        //idpUAT1441_4[tempPos-1] = (byte) ((delimiterIndexes[indefiniteLengthCounter]-(tempPos-1)) - (count ==0 ? 0 :(count-indefiniteLengthCounter)*2));                        opBuffer[pos - 1] = (byte) ((delimiterIndexes[indefiniteLengthCounter] - pos) - (countOfInterimDelim * 2));                        //first recursion out has maximum delimiter value and at each recursion out it would be decremented till the time it is 1.                        //8 --> 7 --> ...1                        indefiniteLengthCounter--;                    } else if (length > 128) {                        int result = 0;                        int len = 0;                        for (int i = length - 128; i > 0; i--) {                            int fBt = stream.read();                            pos++;                            if (fBt == -1)                                throw new IllegalArgumentException(                                        "Unexpected EOF when decoding!");                            result = result << 8;                            result = result | fBt;                            len++;                        }                        if (recursionCount == 1) {                            //do not skip the buffer if the length of the idp buffer is definate                            messageLength = length;                            continue;                        } else {                            stream.skip(result);                            pos = pos + result;                        }                    } else {                        if (recursionCount == 1) {                            messageLength = length;                            //do not skip the buffer if the whole length of the message buffer is definite                            continue;                        } else {                            stream.skip(length);                            pos = pos + length;                        }                    }                }            }        };        return definiteBuffer.createDefiniteBuffer(opBuffer);    }    public static Object decodeOperation(EventObject eventObject) throws Exception {        if (logger.isInfoEnabled()) {            logger.info("decodeOperation:Enter");        }        if (logger.isDebugEnabled()) {            logger.debug("decodeOperation:Input");        }        Object out = null;        byte[] opBuffer = null;        ComponentIndEvent cmpReqEvent = (ComponentIndEvent) eventObject;        if (logger.isDebugEnabled()) {            logger.debug("decodeOperation:Primitive: " + cmpReqEvent.getPrimitiveType());        }        if (cmpReqEvent.getPrimitiveType() == TcapConstants.PRIMITIVE_INVOKE) {            InvokeIndEvent receivedInvoke = (InvokeIndEvent) cmpReqEvent;            opBuffer = receivedInvoke.getParameters().getParameter();        } else if(cmpReqEvent.getPrimitiveType() == TcapConstants.PRIMITIVE_RESULT) {            ResultIndEvent resultIndEvent = (ResultIndEvent) cmpReqEvent;            opBuffer = resultIndEvent.getParameters().getParameter();        }        return InapOperationsCoding.decodeOperation(opBuffer, eventObject);    }    public static Map<RestartNodeId, byte[]> decodeRSNOperation(byte[] rsnBuffer, boolean ignoreTwoBytes) {        int length = 0;        int restartNodeIdsLength = 0;        int restartedNodeIds = 0;        //LinkedList<RestartNodeId> restartedNodes = new LinkedList<RestartNodeId>();        Map<RestartNodeId, byte[]> restartedNodeCICMap = new HashMap<RestartNodeId, byte[]>();        byte[] cicBytes = null;        int i = 0;        if (ignoreTwoBytes)            i = 5;        else            i = 3;        int max = 0;        do {            cicBytes = new byte[2];            length = rsnBuffer[i];            restartNodeIdsLength = restartNodeIdsLength + length;            byte[] restartedNodeIdOctet = new byte[length];            int j = 0;            if (ignoreTwoBytes)                j = 6;            else                j = 4;            for (int k = 0; k < length; j++, k++) {                restartedNodeIdOctet[k] = rsnBuffer[j];            }            //restartedNodes.add(decodeRestartedNodeIds(restartedNodeIdOctet));            cicBytes[0] = restartedNodeIdOctet[3];            cicBytes[1] = restartedNodeIdOctet[4];            restartedNodeCICMap.put(decodeRestartedNodeIds(restartedNodeIdOctet), cicBytes);            i = i + (length + 1);            restartedNodeIds++;            if (ignoreTwoBytes)                max = restartNodeIdsLength + 6 + restartedNodeIds;            else                max = restartNodeIdsLength + 4 + restartedNodeIds;        } while (rsnBuffer.length > max);        return restartedNodeCICMap;    }    public static RestartNodeId decodeRestartedNodeIds(byte[] restartedNodeIdBuffer) {        //Minimum length would be 5 and maximum would be 15        int routingIndicator = (restartedNodeIdBuffer[0] >> 6) & 0x1;        int globalTitileIndicator = (restartedNodeIdBuffer[0] >> 2) & 0xF;        int ssnPresent = (restartedNodeIdBuffer[0] >> 1) & 0x1;        int translationType = 0;        SignalingPointCode signalPointCode = null;        RestartNodeId restartedNode = new RestartNodeId();        byte[] signalingPointCodeBytes = {restartedNodeIdBuffer[5], restartedNodeIdBuffer[6]};        restartedNode.setSignalingPointCodeBytes(signalingPointCodeBytes);        if (routingIndicator == 0) {            if (logger.isInfoEnabled()) {                logger.info("GT based routing");            }            if (globalTitileIndicator == 2) {                if (logger.isInfoEnabled()) {                    logger.info("GT includes translation type only");                }                if (ssnPresent == 1) {                    if (logger.isDebugEnabled()) {                        logger.debug("SSN present, decoding SSN field");                    }                    restartedNode.setSsn((restartedNodeIdBuffer[1] < 0 ? 256 + restartedNodeIdBuffer[1] : restartedNodeIdBuffer[1]));                } else {                    if (logger.isDebugEnabled()) {                        logger.debug("SSN not present");                    }                }                translationType = (restartedNodeIdBuffer[2] < 0 ? 256 + restartedNodeIdBuffer[2] : restartedNodeIdBuffer[2]);                if (translationType == 232 || translationType == 233) {                    byte temp = restartedNodeIdBuffer[5];                    restartedNodeIdBuffer[5] = restartedNodeIdBuffer[6];                    restartedNodeIdBuffer[6] = temp;                    signalPointCode = new SignalingPointCode(((restartedNodeIdBuffer[6] < 0 ? 256 + restartedNodeIdBuffer[6] : restartedNodeIdBuffer[6]) & 0x1f), (((restartedNodeIdBuffer[6] < 0 ? 256 + restartedNodeIdBuffer[6] : restartedNodeIdBuffer[6]) >> 5 & 0x07) | ((restartedNodeIdBuffer[5] < 0 ? 256 + restartedNodeIdBuffer[5] : restartedNodeIdBuffer[5]) << 3 & 0x0f)), (restartedNodeIdBuffer[5] < 0 ? 256 + restartedNodeIdBuffer[5] : restartedNodeIdBuffer[5]) >> 1 & 0x7f);                    restartedNode.setSignalingPointCode(signalPointCode);                } else {                    logger.error("Unsupported Translation type");                }            } else {                logger.error("Other than Translation type GTI");            }        } else {            logger.error("NON-GT, SSN PC based routing is not supported");        }        return restartedNode;    }    interface DefiniteBuffer {        public byte[] createDefiniteBuffer(byte[] opBuffer) throws IOException;        public void handleIndefiniteLength(InputStream stream, int pos, byte[] opBuffer) throws IOException;    }}