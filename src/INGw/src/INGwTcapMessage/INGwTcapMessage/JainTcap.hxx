// Copyright (C) 2005-2007 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef JAIN_TCAP_HXX
#define JAIN_TCAP_HXX

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/version.hxx>

#if (XSD_INT_VERSION != 3000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/tree/parsing.hxx>

#include <xsd/cxx/tree/serialization.hxx>
#include <xsd/cxx/xml/dom/serialization-header.hxx>

namespace xml_schema
{
  // anyType and anySimpleType.
  //
  typedef ::xsd::cxx::tree::type type;
  typedef ::xsd::cxx::tree::simple_type<type> simple_type;

  // 8-bit
  //
  typedef signed char byte;
  typedef unsigned char unsigned_byte;

  // 16-bit
  //
  typedef short short_;
  typedef unsigned short unsigned_short;

  // 32-bit
  //
  typedef int int_;
  typedef unsigned int unsigned_int;

  // 64-bit
  //
  typedef long long long_;
  typedef unsigned long long unsigned_long;

  // Supposed to be arbitrary-length integral types.
  //
  typedef long long integer;
  typedef integer non_positive_integer;
  typedef integer non_negative_integer;
  typedef integer positive_integer;
  typedef integer negative_integer;

  // Boolean.
  //
  typedef bool boolean;

  // Floating-point types.
  //
  typedef float float_;
  typedef double double_;
  typedef double decimal;

  // String types.
  //
  typedef ::xsd::cxx::tree::string< char, simple_type > string;
  typedef ::xsd::cxx::tree::normalized_string< char, string > normalized_string;
  typedef ::xsd::cxx::tree::token< char, normalized_string > token;
  typedef ::xsd::cxx::tree::name< char, token > name;
  typedef ::xsd::cxx::tree::nmtoken< char, token > nmtoken;
  typedef ::xsd::cxx::tree::nmtokens< char, simple_type, nmtoken> nmtokens;
  typedef ::xsd::cxx::tree::ncname< char, name > ncname;
  typedef ::xsd::cxx::tree::language< char, token > language;

  // ID/IDREF.
  //
  typedef ::xsd::cxx::tree::id< char, ncname > id;
  typedef ::xsd::cxx::tree::idref< type, char, ncname > idref;
  typedef ::xsd::cxx::tree::idrefs< char, simple_type, idref > idrefs;

  // URI.
  //
  typedef ::xsd::cxx::tree::uri< char, simple_type > uri;

  // Qualified name.
  //
  typedef ::xsd::cxx::tree::qname< char, simple_type, uri, ncname > qname;

  // Binary.
  //
  typedef ::xsd::cxx::tree::buffer< char > buffer;
  typedef ::xsd::cxx::tree::base64_binary< char, simple_type > base64_binary;
  typedef ::xsd::cxx::tree::hex_binary< char, simple_type > hex_binary;

  // Date/time.
  //
  typedef ::xsd::cxx::tree::date< char, simple_type > date;
  typedef ::xsd::cxx::tree::date_time< char, simple_type > date_time;
  typedef ::xsd::cxx::tree::duration< char, simple_type > duration;
  typedef ::xsd::cxx::tree::day< char, simple_type > day;
  typedef ::xsd::cxx::tree::month< char, simple_type > month;
  typedef ::xsd::cxx::tree::month_day< char, simple_type > month_day;
  typedef ::xsd::cxx::tree::year< char, simple_type > year;
  typedef ::xsd::cxx::tree::year_month< char, simple_type > year_month;
  typedef ::xsd::cxx::tree::time< char, simple_type > time;

  // Entity.
  //
  typedef ::xsd::cxx::tree::entity< char, ncname > entity;
  typedef ::xsd::cxx::tree::entities< char, simple_type, entity > entities;

  // Namespace information. Used in serialization functions.
  //
  typedef ::xsd::cxx::xml::dom::namespace_info < char > namespace_info;
  typedef ::xsd::cxx::xml::dom::namespace_infomap < char > namespace_infomap;

  // Flags and properties.
  //
  typedef ::xsd::cxx::tree::flags flags;
  typedef ::xsd::cxx::tree::properties< char > properties;

  // DOM user data key for back pointers to tree nodes.
  //
#ifndef XSD_CXX_TREE_TREE_NODE_KEY_IN___XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY_IN___XML_SCHEMA

  const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;

#endif

  // Exceptions.
  //
  typedef ::xsd::cxx::tree::exception< char > exception;
  typedef ::xsd::cxx::tree::parsing< char > parsing;
  typedef ::xsd::cxx::tree::expected_element< char > expected_element;
  typedef ::xsd::cxx::tree::unexpected_element< char > unexpected_element;
  typedef ::xsd::cxx::tree::expected_attribute< char > expected_attribute;
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > unexpected_enumerator;
  typedef ::xsd::cxx::tree::expected_text_content< char > expected_text_content;
  typedef ::xsd::cxx::tree::no_type_info< char > no_type_info;
  typedef ::xsd::cxx::tree::not_derived< char > not_derived;
  typedef ::xsd::cxx::tree::duplicate_id< char > duplicate_id;
  typedef ::xsd::cxx::tree::serialization< char > serialization;
  typedef ::xsd::cxx::tree::no_namespace_mapping< char > no_namespace_mapping;
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > no_prefix_mapping;
  typedef ::xsd::cxx::tree::xsi_already_in_use< char > xsi_already_in_use;
  typedef ::xsd::cxx::tree::bounds< char > bounds;

  // Parsing/serialization diagnostics.
  //
  typedef ::xsd::cxx::tree::severity severity;
  typedef ::xsd::cxx::tree::error< char > error;
  typedef ::xsd::cxx::tree::diagnostics< char > diagnostics;

  // Error handler interface.
  //
  typedef ::xsd::cxx::xml::error_handler< char > error_handler;
}

// Forward declarations.
//
class error_req_event_type;
class timer_reset_req_event_type;
class gtindicator0001_type;
class user_abort_ind_event_type;
class reject_req_event_type;
class end_ind_event_type;
class user_cancel_req_event_type;
class operation_type_def;
class error_ind_event_type;
class dialogue_portion_type;
class tcap_user_address_type;
class nstate_ind_event_type;
class provider_abort_ind_event_type;
class user_abort_req_event_type;
class begin_ind_event_type;
class invoke_req_event_type;
class gtindicator0100_type;
class sub_system_address_type;
class signaling_point_code_type;
class unidirectional_req_event_type;
class reject_ind_event_type;
class local_cancel_ind_event_type;
class gtindicator0011_type;
class continue_req_event_type;
class nstate_req_event_type;
class unidirectional_ind_event_type;
class continue_ind_event_type;
class gtindicator0010_type;
class npcstate_ind_event_type;
class begin_req_event_type;
class notice_ind_event_type;
class invoke_ind_event_type;
class result_ind_event_type;
class end_req_event_type;
class result_req_event_type;
class sccp_user_address_type;
class parameters_type;
class state_req_event_type;
class dialogue_ind_event_type;
class component_ind_event_type;
class state_ind_event_type;
class dialogue_req_event_type;
class global_title_type;
class component_req_event_type;
class tcap_type;
class tcap_config_type;
class error_type;
class numbering_plan;
class nature_of_addr_ind;
class encoding_scheme;
class abort_reason;
class problem_type;
class problem;
class reject_type;
class operation_type;
class error_type1;
class protocol_version;
class app_context_identifier;
class security_context_identifier;
class user_status;
class p_abort;
class abort_reason1;
class class_type;
class numbering_plan1;
class nature_of_addr_ind1;
class encoding_scheme1;
class problem_type1;
class problem1;
class reject_type1;
class numbering_plan2;
class encoding_scheme2;
class user_status1;
class signaling_point_status;
class class_type1;
class termination;
class routing_indicator;
class parameter_identifier;

#include <memory>    // std::auto_ptr
#include <algorithm> // std::binary_search

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

class error_req_event_type: public ::xml_schema::type
{
  public:
  // parameters
  // 
  typedef ::parameters_type parameters_type;
  typedef ::xsd::cxx::tree::optional< parameters_type > parameters_optional;
  typedef ::xsd::cxx::tree::traits< parameters_type, char > parameters_traits;

  const parameters_optional&
  parameters () const;

  parameters_optional&
  parameters ();

  void
  parameters (const parameters_type& x);

  void
  parameters (const parameters_optional& x);

  void
  parameters (::std::auto_ptr< parameters_type > p);

  // error-code
  // 
  typedef ::xml_schema::hex_binary error_code_type;
  typedef ::xsd::cxx::tree::traits< error_code_type, char > error_code_traits;

  const error_code_type&
  error_code () const;

  error_code_type&
  error_code ();

  void
  error_code (const error_code_type& x);

  void
  error_code (::std::auto_ptr< error_code_type > p);

  // dialogue-id
  // 
  typedef ::xml_schema::integer dialogue_id_type;
  typedef ::xsd::cxx::tree::optional< dialogue_id_type > dialogue_id_optional;
  typedef ::xsd::cxx::tree::traits< dialogue_id_type, char > dialogue_id_traits;

  const dialogue_id_optional&
  dialogue_id () const;

  dialogue_id_optional&
  dialogue_id ();

  void
  dialogue_id (const dialogue_id_type& x);

  void
  dialogue_id (const dialogue_id_optional& x);

  // invoke-id
  // 
  typedef ::xml_schema::integer invoke_id_type;
  typedef ::xsd::cxx::tree::optional< invoke_id_type > invoke_id_optional;
  typedef ::xsd::cxx::tree::traits< invoke_id_type, char > invoke_id_traits;

  const invoke_id_optional&
  invoke_id () const;

  invoke_id_optional&
  invoke_id ();

  void
  invoke_id (const invoke_id_type& x);

  void
  invoke_id (const invoke_id_optional& x);

  // link-id
  // 
  typedef ::xml_schema::integer link_id_type;
  typedef ::xsd::cxx::tree::optional< link_id_type > link_id_optional;
  typedef ::xsd::cxx::tree::traits< link_id_type, char > link_id_traits;

  const link_id_optional&
  link_id () const;

  link_id_optional&
  link_id ();

  void
  link_id (const link_id_type& x);

  void
  link_id (const link_id_optional& x);

  // error-type
  // 
  typedef ::error_type error_type_type;
  typedef ::xsd::cxx::tree::traits< error_type_type, char > error_type_traits;

  const error_type_type&
  error_type () const;

  error_type_type&
  error_type ();

  void
  error_type (const error_type_type& x);

  void
  error_type (::std::auto_ptr< error_type_type > p);

  // Constructors.
  //
  error_req_event_type (const error_code_type&,
                        const error_type_type&);

  error_req_event_type (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::type* c = 0);

  error_req_event_type (const error_req_event_type& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::type* c = 0);

  virtual error_req_event_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::type* c = 0) const;

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  private:
  parameters_optional parameters_;
  ::xsd::cxx::tree::one< error_code_type > error_code_;
  dialogue_id_optional dialogue_id_;
  invoke_id_optional invoke_id_;
  link_id_optional link_id_;
  ::xsd::cxx::tree::one< error_type_type > error_type_;
};

class timer_reset_req_event_type: public ::xml_schema::type
{
  public:
  // dialogue-id
  // 
  typedef ::xml_schema::integer dialogue_id_type;
  typedef ::xsd::cxx::tree::optional< dialogue_id_type > dialogue_id_optional;
  typedef ::xsd::cxx::tree::traits< dialogue_id_type, char > dialogue_id_traits;

  const dialogue_id_optional&
  dialogue_id () const;

  dialogue_id_optional&
  dialogue_id ();

  void
  dialogue_id (const dialogue_id_type& x);

  void
  dialogue_id (const dialogue_id_optional& x);

  // invoke-id
  // 
  typedef ::xml_schema::integer invoke_id_type;
  typedef ::xsd::cxx::tree::optional< invoke_id_type > invoke_id_optional;
  typedef ::xsd::cxx::tree::traits< invoke_id_type, char > invoke_id_traits;

  const invoke_id_optional&
  invoke_id () const;

  invoke_id_optional&
  invoke_id ();

  void
  invoke_id (const invoke_id_type& x);

  void
  invoke_id (const invoke_id_optional& x);

  // Constructors.
  //
  timer_reset_req_event_type ();

  timer_reset_req_event_type (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::type* c = 0);

  timer_reset_req_event_type (const timer_reset_req_event_type& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::type* c = 0);

  virtual timer_reset_req_event_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::type* c = 0) const;

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  private:
  dialogue_id_optional dialogue_id_;
  invoke_id_optional invoke_id_;
};

class gtindicator0001_type: public ::xml_schema::type
{
  public:
  // address-information
  // 
  typedef ::xml_schema::hex_binary address_information_type;
  typedef ::xsd::cxx::tree::optional< address_information_type > address_information_optional;
  typedef ::xsd::cxx::tree::traits< address_information_type, char > address_information_traits;

  const address_information_optional&
  address_information () const;

  address_information_optional&
  address_information ();

  void
  address_information (const address_information_type& x);

  void
  address_information (const address_information_optional& x);

  void
  address_information (::std::auto_ptr< address_information_type > p);

  // translation-type
  // 
  typedef ::xml_schema::byte translation_type_type;
  typedef ::xsd::cxx::tree::optional< translation_type_type > translation_type_optional;
  typedef ::xsd::cxx::tree::traits< translation_type_type, char > translation_type_traits;

  const translation_type_optional&
  translation_type () const;

  translation_type_optional&
  translation_type ();

  void
  translation_type (const translation_type_type& x);

  void
  translation_type (const translation_type_optional& x);

  // numbering-plan
  // 
  typedef ::numbering_plan numbering_plan_type;
  typedef ::xsd::cxx::tree::optional< numbering_plan_type > numbering_plan_optional;
  typedef ::xsd::cxx::tree::traits< numbering_plan_type, char > numbering_plan_traits;

  const numbering_plan_optional&
  numbering_plan () const;

  numbering_plan_optional&
  numbering_plan ();

  void
  numbering_plan (const numbering_plan_type& x);

  void
  numbering_plan (const numbering_plan_optional& x);

  void
  numbering_plan (::std::auto_ptr< numbering_plan_type > p);

  // nature-of-addr-ind
  // 
  typedef ::nature_of_addr_ind nature_of_addr_ind_type;
  typedef ::xsd::cxx::tree::optional< nature_of_addr_ind_type > nature_of_addr_ind_optional;
  typedef ::xsd::cxx::tree::traits< nature_of_addr_ind_type, char > nature_of_addr_ind_traits;

  const nature_of_addr_ind_optional&
  nature_of_addr_ind () const;

  nature_of_addr_ind_optional&
  nature_of_addr_ind ();

  void
  nature_of_addr_ind (const nature_of_addr_ind_type& x);

  void
  nature_of_addr_ind (const nature_of_addr_ind_optional& x);

  void
  nature_of_addr_ind (::std::auto_ptr< nature_of_addr_ind_type > p);

  // encoding-scheme
  // 
  typedef ::encoding_scheme encoding_scheme_type;
  typedef ::xsd::cxx::tree::optional< encoding_scheme_type > encoding_scheme_optional;
  typedef ::xsd::cxx::tree::traits< encoding_scheme_type, char > encoding_scheme_traits;

  const encoding_scheme_optional&
  encoding_scheme () const;

  encoding_scheme_optional&
  encoding_scheme ();

  void
  encoding_scheme (const encoding_scheme_type& x);

  void
  encoding_scheme (const encoding_scheme_optional& x);

  void
  encoding_scheme (::std::auto_ptr< encoding_scheme_type > p);

  // Constructors.
  //
  gtindicator0001_type ();

  gtindicator0001_type (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::type* c = 0);

  gtindicator0001_type (const gtindicator0001_type& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::type* c = 0);

  virtual gtindicator0001_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::type* c = 0) const;

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  private:
  address_information_optional address_information_;
  translation_type_optional translation_type_;
  numbering_plan_optional numbering_plan_;
  nature_of_addr_ind_optional nature_of_addr_ind_;
  encoding_scheme_optional encoding_scheme_;
};

class user_abort_ind_event_type: public ::xml_schema::type
{
  public:
  // dialogue-portion
  // 
  typedef ::dialogue_portion_type dialogue_portion_type;
  typedef ::xsd::cxx::tree::optional< dialogue_portion_type > dialogue_portion_optional;
  typedef ::xsd::cxx::tree::traits< dialogue_portion_type, char > dialogue_portion_traits;

  const dialogue_portion_optional&
  dialogue_portion () const;

  dialogue_portion_optional&
  dialogue_portion ();

  void
  dialogue_portion (const dialogue_portion_type& x);

  void
  dialogue_portion (const dialogue_portion_optional& x);

  void
  dialogue_portion (::std::auto_ptr< dialogue_portion_type > p);

  // component-ind-event
  // 
  typedef ::component_ind_event_type component_ind_event_type;
  typedef ::xsd::cxx::tree::sequence< component_ind_event_type > component_ind_event_sequence;
  typedef component_ind_event_sequence::iterator component_ind_event_iterator;
  typedef component_ind_event_sequence::const_iterator component_ind_event_const_iterator;
  typedef ::xsd::cxx::tree::traits< component_ind_event_type, char > component_ind_event_traits;

  const component_ind_event_sequence&
  component_ind_event () const;

  component_ind_event_sequence&
  component_ind_event ();

  void
  component_ind_event (const component_ind_event_sequence& s);

  // user-abort-information
  // 
  typedef ::xml_schema::hex_binary user_abort_information_type;
  typedef ::xsd::cxx::tree::optional< user_abort_information_type > user_abort_information_optional;
  typedef ::xsd::cxx::tree::traits< user_abort_information_type, char > user_abort_information_traits;

  const user_abort_information_optional&
  user_abort_information () const;

  user_abort_information_optional&
  user_abort_information ();

  void
  user_abort_information (const user_abort_information_type& x);

  void
  user_abort_information (const user_abort_information_optional& x);

  void
  user_abort_information (::std::auto_ptr< user_abort_information_type > p);

  // dialogue-id
  // 
  typedef ::xml_schema::integer dialogue_id_type;
  typedef ::xsd::cxx::tree::optional< dialogue_id_type > dialogue_id_optional;
  typedef ::xsd::cxx::tree::traits< dialogue_id_type, char > dialogue_id_traits;

  const dialogue_id_optional&
  dialogue_id () const;

  dialogue_id_optional&
  dialogue_id ();

  void
  dialogue_id (const dialogue_id_type& x);

  void
  dialogue_id (const dialogue_id_optional& x);

  // abort-reason
  // 
  typedef ::abort_reason abort_reason_type;
  typedef ::xsd::cxx::tree::optional< abort_reason_type > abort_reason_optional;
  typedef ::xsd::cxx::tree::traits< abort_reason_type, char > abort_reason_traits;

  const abort_reason_optional&
  abort_reason () const;

  abort_reason_optional&
  abort_reason ();

  void
  abort_reason (const abort_reason_type& x);

  void
  abort_reason (const abort_reason_optional& x);

  void
  abort_reason (::std::auto_ptr< abort_reason_type > p);

  // quality-of-service
  // 
  typedef ::xml_schema::byte quality_of_service_type;
  typedef ::xsd::cxx::tree::optional< quality_of_service_type > quality_of_service_optional;
  typedef ::xsd::cxx::tree::traits< quality_of_service_type, char > quality_of_service_traits;

  const quality_of_service_optional&
  quality_of_service () const;

  quality_of_service_optional&
  quality_of_service ();

  void
  quality_of_service (const quality_of_service_type& x);

  void
  quality_of_service (const quality_of_service_optional& x);

  // Constructors.
  //
  user_abort_ind_event_type ();

  user_abort_ind_event_type (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::type* c = 0);

  user_abort_ind_event_type (const user_abort_ind_event_type& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::type* c = 0);

  virtual user_abort_ind_event_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::type* c = 0) const;

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  private:
  dialogue_portion_optional dialogue_portion_;
  component_ind_event_sequence component_ind_event_;
  user_abort_information_optional user_abort_information_;
  dialogue_id_optional dialogue_id_;
  abort_reason_optional abort_reason_;
  quality_of_service_optional quality_of_service_;
};

class reject_req_event_type: public ::xml_schema::type
{
  public:
  // parameters
  // 
  typedef ::parameters_type parameters_type;
  typedef ::xsd::cxx::tree::optional< parameters_type > parameters_optional;
  typedef ::xsd::cxx::tree::traits< parameters_type, char > parameters_traits;

  const parameters_optional&
  parameters () const;

  parameters_optional&
  parameters ();

  void
  parameters (const parameters_type& x);

  void
  parameters (const parameters_optional& x);

  void
  parameters (::std::auto_ptr< parameters_type > p);

  // dialogue-id
  // 
  typedef ::xml_schema::integer dialogue_id_type;
  typedef ::xsd::cxx::tree::optional< dialogue_id_type > dialogue_id_optional;
  typedef ::xsd::cxx::tree::traits< dialogue_id_type, char > dialogue_id_traits;

  const dialogue_id_optional&
  dialogue_id () const;

  dialogue_id_optional&
  dialogue_id ();

  void
  dialogue_id (const dialogue_id_type& x);

  void
  dialogue_id (const dialogue_id_optional& x);

  // invoke-id
  // 
  typedef ::xml_schema::integer invoke_id_type;
  typedef ::xsd::cxx::tree::optional< invoke_id_type > invoke_id_optional;
  typedef ::xsd::cxx::tree::traits< invoke_id_type, char > invoke_id_traits;

  const invoke_id_optional&
  invoke_id () const;

  invoke_id_optional&
  invoke_id ();

  void
  invoke_id (const invoke_id_type& x);

  void
  invoke_id (const invoke_id_optional& x);

  // link-id
  // 
  typedef ::xml_schema::integer link_id_type;
  typedef ::xsd::cxx::tree::optional< link_id_type > link_id_optional;
  typedef ::xsd::cxx::tree::traits< link_id_type, char > link_id_traits;

  const link_id_optional&
  link_id () const;

  link_id_optional&
  link_id ();

  void
  link_id (const link_id_type& x);

  void
  link_id (const link_id_optional& x);

  // problem-type
  // 
  typedef ::problem_type problem_type_type;
  typedef ::xsd::cxx::tree::traits< problem_type_type, char > problem_type_traits;

  const problem_type_type&
  problem_type () const;

  problem_type_type&
  problem_type ();

  void
  problem_type (const problem_type_type& x);

  void
  problem_type (::std::auto_ptr< problem_type_type > p);

  // problem
  // 
  typedef ::problem problem_type1;
  typedef ::xsd::cxx::tree::traits< problem_type1, char > problem_traits;

  const problem_type1&
  problem () const;

  problem_type1&
  problem ();

  void
  problem (const problem_type1& x);

  void
  problem (::std::auto_ptr< problem_type1 > p);

  // reject-type
  // 
  typedef ::reject_type reject_type_type;
  typedef ::xsd::cxx::tree::optional< reject_type_type > reject_type_optional;
  typedef ::xsd::cxx::tree::traits< reject_type_type, char > reject_type_traits;

  const reject_type_optional&
  reject_type () const;

  reject_type_optional&
  reject_type ();

  void
  reject_type (const reject_type_type& x);

  void
  reject_type (const reject_type_optional& x);

  void
  reject_type (::std::auto_ptr< reject_type_type > p);

  // Constructors.
  //
  reject_req_event_type (const problem_type_type&,
                         const problem_type1&);

  reject_req_event_type (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::type* c = 0);

  reject_req_event_type (const reject_req_event_type& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::type* c = 0);

  virtual reject_req_event_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::type* c = 0) const;

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  private:
  parameters_optional parameters_;
  dialogue_id_optional dialogue_id_;
  invoke_id_optional invoke_id_;
  link_id_optional link_id_;
  ::xsd::cxx::tree::one< problem_type_type > problem_type_;
  ::xsd::cxx::tree::one< problem_type1 > problem_;
  reject_type_optional reject_type_;
};

class end_ind_event_type: public ::xml_schema::type
{
  public:
  // dialogue-portion
  // 
  typedef ::dialogue_portion_type dialogue_portion_type;
  typedef ::xsd::cxx::tree::optional< dialogue_portion_type > dialogue_portion_optional;
  typedef ::xsd::cxx::tree::traits< dialogue_portion_type, char > dialogue_portion_traits;

  const dialogue_portion_optional&
  dialogue_portion () const;

  dialogue_portion_optional&
  dialogue_portion ();

  void
  dialogue_portion (const dialogue_portion_type& x);

  void
  dialogue_portion (const dialogue_portion_optional& x);

  void
  dialogue_portion (::std::auto_ptr< dialogue_portion_type > p);

  // component-ind-event
  // 
  typedef ::component_ind_event_type component_ind_event_type;
  typedef ::xsd::cxx::tree::sequence< component_ind_event_type > component_ind_event_sequence;
  typedef component_ind_event_sequence::iterator component_ind_event_iterator;
  typedef component_ind_event_sequence::const_iterator component_ind_event_const_iterator;
  typedef ::xsd::cxx::tree::traits< component_ind_event_type, char > component_ind_event_traits;

  const component_ind_event_sequence&
  component_ind_event () const;

  component_ind_event_sequence&
  component_ind_event ();

  void
  component_ind_event (const component_ind_event_sequence& s);

  // dialogue-id
  // 
  typedef ::xml_schema::integer dialogue_id_type;
  typedef ::xsd::cxx::tree::optional< dialogue_id_type > dialogue_id_optional;
  typedef ::xsd::cxx::tree::traits< dialogue_id_type, char > dialogue_id_traits;

  const dialogue_id_optional&
  dialogue_id () const;

  dialogue_id_optional&
  dialogue_id ();

  void
  dialogue_id (const dialogue_id_type& x);

  void
  dialogue_id (const dialogue_id_optional& x);

  // quality-of-service
  // 
  typedef ::xml_schema::byte quality_of_service_type;
  typedef ::xsd::cxx::tree::optional< quality_of_service_type > quality_of_service_optional;
  typedef ::xsd::cxx::tree::traits< quality_of_service_type, char > quality_of_service_traits;

  const quality_of_service_optional&
  quality_of_service () const;

  quality_of_service_optional&
  quality_of_service ();

  void
  quality_of_service (const quality_of_service_type& x);

  void
  quality_of_service (const quality_of_service_optional& x);

  // Constructors.
  //
  end_ind_event_type ();

  end_ind_event_type (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::type* c = 0);

  end_ind_event_type (const end_ind_event_type& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::type* c = 0);

  virtual end_ind_event_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::type* c = 0) const;

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  private:
  dialogue_portion_optional dialogue_portion_;
  component_ind_event_sequence component_ind_event_;
  dialogue_id_optional dialogue_id_;
  quality_of_service_optional quality_of_service_;
};

class user_cancel_req_event_type: public ::xml_schema::type
{
  public:
  // dialogue-id
  // 
  typedef ::xml_schema::integer dialogue_id_type;
  typedef ::xsd::cxx::tree::optional< dialogue_id_type > dialogue_id_optional;
  typedef ::xsd::cxx::tree::traits< dialogue_id_type, char > dialogue_id_traits;

  const dialogue_id_optional&
  dialogue_id () const;

  dialogue_id_optional&
  dialogue_id ();

  void
  dialogue_id (const dialogue_id_type& x);

  void
  dialogue_id (const dialogue_id_optional& x);

  // invoke-id
  // 
  typedef ::xml_schema::integer invoke_id_type;
  typedef ::xsd::cxx::tree::optional< invoke_id_type > invoke_id_optional;
  typedef ::xsd::cxx::tree::traits< invoke_id_type, char > invoke_id_traits;

  const invoke_id_optional&
  invoke_id () const;

  invoke_id_optional&
  invoke_id ();

  void
  invoke_id (const invoke_id_type& x);

  void
  invoke_id (const invoke_id_optional& x);

  // Constructors.
  //
  user_cancel_req_event_type ();

  user_cancel_req_event_type (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::type* c = 0);

  user_cancel_req_event_type (const user_cancel_req_event_type& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::type* c = 0);

  virtual user_cancel_req_event_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::type* c = 0) const;

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  private:
  dialogue_id_optional dialogue_id_;
  invoke_id_optional invoke_id_;
};

class operation_type_def: public ::xml_schema::type
{
  public:
  // operation-code
  // 
  typedef ::xml_schema::hex_binary operation_code_type;
  typedef ::xsd::cxx::tree::traits< operation_code_type, char > operation_code_traits;

  const operation_code_type&
  operation_code () const;

  operation_code_type&
  operation_code ();

  void
  operation_code (const operation_code_type& x);

  void
  operation_code (::std::auto_ptr< operation_code_type > p);

  // private-operation-data
  // 
  typedef ::xml_schema::hex_binary private_operation_data_type;
  typedef ::xsd::cxx::tree::optional< private_operation_data_type > private_operation_data_optional;
  typedef ::xsd::cxx::tree::traits< private_operation_data_type, char > private_operation_data_traits;

  const private_operation_data_optional&
  private_operation_data () const;

  private_operation_data_optional&
  private_operation_data ();

  void
  private_operation_data (const private_operation_data_type& x);

  void
  private_operation_data (const private_operation_data_optional& x);

  void
  private_operation_data (::std::auto_ptr< private_operation_data_type > p);

  // operation-type
  // 
  typedef ::operation_type operation_type_type;
  typedef ::xsd::cxx::tree::traits< operation_type_type, char > operation_type_traits;

  const operation_type_type&
  operation_type () const;

  operation_type_type&
  operation_type ();

  void
  operation_type (const operation_type_type& x);

  void
  operation_type (::std::auto_ptr< operation_type_type > p);

  // Constructors.
  //
  operation_type_def (const operation_code_type&,
                      const operation_type_type&);

  operation_type_def (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::type* c = 0);

  operation_type_def (const operation_type_def& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::type* c = 0);

  virtual operation_type_def*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::type* c = 0) const;

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  private:
  ::xsd::cxx::tree::one< operation_code_type > operation_code_;
  private_operation_data_optional private_operation_data_;
  ::xsd::cxx::tree::one< operation_type_type > operation_type_;
};

class error_ind_event_type: public ::xml_schema::type
{
  public:
  // parameters
  // 
  typedef ::parameters_type parameters_type;
  typedef ::xsd::cxx::tree::optional< parameters_type > parameters_optional;
  typedef ::xsd::cxx::tree::traits< parameters_type, char > parameters_traits;

  const parameters_optional&
  parameters () const;

  parameters_optional&
  parameters ();

  void
  parameters (const parameters_type& x);

  void
  parameters (const parameters_optional& x);

  void
  parameters (::std::auto_ptr< parameters_type > p);

  // error-code
  // 
  typedef ::xml_schema::hex_binary error_code_type;
  typedef ::xsd::cxx::tree::traits< error_code_type, char > error_code_traits;

  const error_code_type&
  error_code () const;

  error_code_type&
  error_code ();

  void
  error_code (const error_code_type& x);

  void
  error_code (::std::auto_ptr< error_code_type > p);

  // dialogue-id
  // 
  typedef ::xml_schema::integer dialogue_id_type;
  typedef ::xsd::cxx::tree::optional< dialogue_id_type > dialogue_id_optional;
  typedef ::xsd::cxx::tree::traits< dialogue_id_type, char > dialogue_id_traits;

  const dialogue_id_optional&
  dialogue_id () const;

  dialogue_id_optional&
  dialogue_id ();

  void
  dialogue_id (const dialogue_id_type& x);

  void
  dialogue_id (const dialogue_id_optional& x);

  // invoke-id
  // 
  typedef ::xml_schema::integer invoke_id_type;
  typedef ::xsd::cxx::tree::optional< invoke_id_type > invoke_id_optional;
  typedef ::xsd::cxx::tree::traits< invoke_id_type, char > invoke_id_traits;

  const invoke_id_optional&
  invoke_id () const;

  invoke_id_optional&
  invoke_id ();

  void
  invoke_id (const invoke_id_type& x);

  void
  invoke_id (const invoke_id_optional& x);

  // last-component
  // 
  typedef ::xml_schema::boolean last_component_type;
  typedef ::xsd::cxx::tree::optional< last_component_type > last_component_optional;
  typedef ::xsd::cxx::tree::traits< last_component_type, char > last_component_traits;

  const last_component_optional&
  last_component () const;

  last_component_optional&
  last_component ();

  void
  last_component (const last_component_type& x);

  void
  last_component (const last_component_optional& x);

  // link-id
  // 
  typedef ::xml_schema::integer link_id_type;
  typedef ::xsd::cxx::tree::optional< link_id_type > link_id_optional;
  typedef ::xsd::cxx::tree::traits< link_id_type, char > link_id_traits;

  const link_id_optional&
  link_id () const;

  link_id_optional&
  link_id ();

  void
  link_id (const link_id_type& x);

  void
  link_id (const link_id_optional& x);

  // error-type
  // 
  typedef ::error_type1 error_type_type;
  typedef ::xsd::cxx::tree::traits< error_type_type, char > error_type_traits;

  const error_type_type&
  error_type () const;

  error_type_type&
  error_type ();

  void
  error_type (const error_type_type& x);

  void
  error_type (::std::auto_ptr< error_type_type > p);

  // Constructors.
  //
  error_ind_event_type (const error_code_type&,
                        const error_type_type&);

  error_ind_event_type (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::type* c = 0);

  error_ind_event_type (const error_ind_event_type& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::type* c = 0);

  virtual error_ind_event_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::type* c = 0) const;

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  private:
  parameters_optional parameters_;
  ::xsd::cxx::tree::one< error_code_type > error_code_;
  dialogue_id_optional dialogue_id_;
  invoke_id_optional invoke_id_;
  last_component_optional last_component_;
  link_id_optional link_id_;
  ::xsd::cxx::tree::one< error_type_type > error_type_;
};

class dialogue_portion_type: public ::xml_schema::type
{
  public:
  // app-context-name
  // 
  typedef ::xml_schema::hex_binary app_context_name_type;
  typedef ::xsd::cxx::tree::optional< app_context_name_type > app_context_name_optional;
  typedef ::xsd::cxx::tree::traits< app_context_name_type, char > app_context_name_traits;

  const app_context_name_optional&
  app_context_name () const;

  app_context_name_optional&
  app_context_name ();

  void
  app_context_name (const app_context_name_type& x);

  void
  app_context_name (const app_context_name_optional& x);

  void
  app_context_name (::std::auto_ptr< app_context_name_type > p);

  // user-information
  // 
  typedef ::xml_schema::hex_binary user_information_type;
  typedef ::xsd::cxx::tree::optional< user_information_type > user_information_optional;
  typedef ::xsd::cxx::tree::traits< user_information_type, char > user_information_traits;

  const user_information_optional&
  user_information () const;

  user_information_optional&
  user_information ();

  void
  user_information (const user_information_type& x);

  void
  user_information (const user_information_optional& x);

  void
  user_information (::std::auto_ptr< user_information_type > p);

  // security-context-information
  // 
  typedef ::xml_schema::hex_binary security_context_information_type;
  typedef ::xsd::cxx::tree::optional< security_context_information_type > security_context_information_optional;
  typedef ::xsd::cxx::tree::traits< security_context_information_type, char > security_context_information_traits;

  const security_context_information_optional&
  security_context_information () const;

  security_context_information_optional&
  security_context_information ();

  void
  security_context_information (const security_context_information_type& x);

  void
  security_context_information (const security_context_information_optional& x);

  void
  security_context_information (::std::auto_ptr< security_context_information_type > p);

  // confidentiality-information
  // 
  typedef ::xml_schema::hex_binary confidentiality_information_type;
  typedef ::xsd::cxx::tree::optional< confidentiality_information_type > confidentiality_information_optional;
  typedef ::xsd::cxx::tree::traits< confidentiality_information_type, char > confidentiality_information_traits;

  const confidentiality_information_optional&
  confidentiality_information () const;

  confidentiality_information_optional&
  confidentiality_information ();

  void
  confidentiality_information (const confidentiality_information_type& x);

  void
  confidentiality_information (const confidentiality_information_optional& x);

  void
  confidentiality_information (::std::auto_ptr< confidentiality_information_type > p);

  // protocol-version
  // 
  typedef ::protocol_version protocol_version_type;
  typedef ::xsd::cxx::tree::optional< protocol_version_type > protocol_version_optional;
  typedef ::xsd::cxx::tree::traits< protocol_version_type, char > protocol_version_traits;

  const protocol_version_optional&
  protocol_version () const;

  protocol_version_optional&
  protocol_version ();

  void
  protocol_version (const protocol_version_type& x);

  void
  protocol_version (const protocol_version_optional& x);

  void
  protocol_version (::std::auto_ptr< protocol_version_type > p);

  // app-context-identifier
  // 
  typedef ::app_context_identifier app_context_identifier_type;
  typedef ::xsd::cxx::tree::optional< app_context_identifier_type > app_context_identifier_optional;
  typedef ::xsd::cxx::tree::traits< app_context_identifier_type, char > app_context_identifier_traits;

  const app_context_identifier_optional&
  app_context_identifier () const;

  app_context_identifier_optional&
  app_context_identifier ();

  void
  app_context_identifier (const app_context_identifier_type& x);

  void
  app_context_identifier (const app_context_identifier_optional& x);

  void
  app_context_identifier (::std::auto_ptr< app_context_identifier_type > p);

  // security-context-identifier
  // 
  typedef ::security_context_identifier security_context_identifier_type;
  typedef ::xsd::cxx::tree::optional< security_context_identifier_type > security_context_identifier_optional;
  typedef ::xsd::cxx::tree::traits< security_context_identifier_type, char > security_context_identifier_traits;

  const security_context_identifier_optional&
  security_context_identifier () const;

  security_context_identifier_optional&
  security_context_identifier ();

  void
  security_context_identifier (const security_context_identifier_type& x);

  void
  security_context_identifier (const security_context_identifier_optional& x);

  void
  security_context_identifier (::std::auto_ptr< security_context_identifier_type > p);

  // Constructors.
  //
  dialogue_portion_type ();

  dialogue_portion_type (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::type* c = 0);

  dialogue_portion_type (const dialogue_portion_type& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::type* c = 0);

  virtual dialogue_portion_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::type* c = 0) const;

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  private:
  app_context_name_optional app_context_name_;
  user_information_optional user_information_;
  security_context_information_optional security_context_information_;
  confidentiality_information_optional confidentiality_information_;
  protocol_version_optional protocol_version_;
  app_context_identifier_optional app_context_identifier_;
  security_context_identifier_optional security_context_identifier_;
};

class tcap_user_address_type: public ::xml_schema::type
{
  public:
  // Constructors.
  //
  tcap_user_address_type ();

  tcap_user_address_type (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::type* c = 0);

  tcap_user_address_type (const ::xercesc::DOMAttr& a,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::type* c = 0);

  tcap_user_address_type (const ::std::string& s,
                          const ::xercesc::DOMElement* e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::type* c = 0);

  tcap_user_address_type (const tcap_user_address_type& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::type* c = 0);

  virtual tcap_user_address_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::type* c = 0) const;
};

class nstate_ind_event_type: public ::xml_schema::type
{
  public:
  // affected-user
  // 
  typedef ::sccp_user_address_type affected_user_type;
  typedef ::xsd::cxx::tree::traits< affected_user_type, char > affected_user_traits;

  const affected_user_type&
  affected_user () const;

  affected_user_type&
  affected_user ();

  void
  affected_user (const affected_user_type& x);

  void
  affected_user (::std::auto_ptr< affected_user_type > p);

  // own-point-code
  // 
  typedef ::signaling_point_code_type own_point_code_type;
  typedef ::xsd::cxx::tree::traits< own_point_code_type, char > own_point_code_traits;

  const own_point_code_type&
  own_point_code () const;

  own_point_code_type&
  own_point_code ();

  void
  own_point_code (const own_point_code_type& x);

  void
  own_point_code (::std::auto_ptr< own_point_code_type > p);

  // user-status
  // 
  typedef ::user_status user_status_type;
  typedef ::xsd::cxx::tree::traits< user_status_type, char > user_status_traits;

  const user_status_type&
  user_status () const;

  user_status_type&
  user_status ();

  void
  user_status (const user_status_type& x);

  void
  user_status (::std::auto_ptr< user_status_type > p);

  // Constructors.
  //
  nstate_ind_event_type (const affected_user_type&,
                         const own_point_code_type&,
                         const user_status_type&);

  nstate_ind_event_type (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::type* c = 0);

  nstate_ind_event_type (const nstate_ind_event_type& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::type* c = 0);

  virtual nstate_ind_event_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::type* c = 0) const;

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  private:
  ::xsd::cxx::tree::one< affected_user_type > affected_user_;
  ::xsd::cxx::tree::one< own_point_code_type > own_point_code_;
  ::xsd::cxx::tree::one< user_status_type > user_status_;
};

class provider_abort_ind_event_type: public ::xml_schema::type
{
  public:
  // dialogue-portion
  // 
  typedef ::dialogue_portion_type dialogue_portion_type;
  typedef ::xsd::cxx::tree::optional< dialogue_portion_type > dialogue_portion_optional;
  typedef ::xsd::cxx::tree::traits< dialogue_portion_type, char > dialogue_portion_traits;

  const dialogue_portion_optional&
  dialogue_portion () const;

  dialogue_portion_optional&
  dialogue_portion ();

  void
  dialogue_portion (const dialogue_portion_type& x);

  void
  dialogue_portion (const dialogue_portion_optional& x);

  void
  dialogue_portion (::std::auto_ptr< dialogue_portion_type > p);

  // component-ind-event
  // 
  typedef ::component_ind_event_type component_ind_event_type;
  typedef ::xsd::cxx::tree::sequence< component_ind_event_type > component_ind_event_sequence;
  typedef component_ind_event_sequence::iterator component_ind_event_iterator;
  typedef component_ind_event_sequence::const_iterator component_ind_event_const_iterator;
  typedef ::xsd::cxx::tree::traits< component_ind_event_type, char > component_ind_event_traits;

  const component_ind_event_sequence&
  component_ind_event () const;

  component_ind_event_sequence&
  component_ind_event ();

  void
  component_ind_event (const component_ind_event_sequence& s);

  // dialogue-id
  // 
  typedef ::xml_schema::integer dialogue_id_type;
  typedef ::xsd::cxx::tree::optional< dialogue_id_type > dialogue_id_optional;
  typedef ::xsd::cxx::tree::traits< dialogue_id_type, char > dialogue_id_traits;

  const dialogue_id_optional&
  dialogue_id () const;

  dialogue_id_optional&
  dialogue_id ();

  void
  dialogue_id (const dialogue_id_type& x);

  void
  dialogue_id (const dialogue_id_optional& x);

  // quality-of-service
  // 
  typedef ::xml_schema::byte quality_of_service_type;
  typedef ::xsd::cxx::tree::optional< quality_of_service_type > quality_of_service_optional;
  typedef ::xsd::cxx::tree::traits< quality_of_service_type, char > quality_of_service_traits;

  const quality_of_service_optional&
  quality_of_service () const;

  quality_of_service_optional&
  quality_of_service ();

  void
  quality_of_service (const quality_of_service_type& x);

  void
  quality_of_service (const quality_of_service_optional& x);

  // p-abort
  // 
  typedef ::p_abort p_abort_type;
  typedef ::xsd::cxx::tree::traits< p_abort_type, char > p_abort_traits;

  const p_abort_type&
  p_abort () const;

  p_abort_type&
  p_abort ();

  void
  p_abort (const p_abort_type& x);

  void
  p_abort (::std::auto_ptr< p_abort_type > p);

  // Constructors.
  //
  provider_abort_ind_event_type (const p_abort_type&);

  provider_abort_ind_event_type (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::type* c = 0);

  provider_abort_ind_event_type (const provider_abort_ind_event_type& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::type* c = 0);

  virtual provider_abort_ind_event_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::type* c = 0) const;

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  private:
  dialogue_portion_optional dialogue_portion_;
  component_ind_event_sequence component_ind_event_;
  dialogue_id_optional dialogue_id_;
  quality_of_service_optional quality_of_service_;
  ::xsd::cxx::tree::one< p_abort_type > p_abort_;
};

class user_abort_req_event_type: public ::xml_schema::type
{
  public:
  // dialogue-portion
  // 
  typedef ::dialogue_portion_type dialogue_portion_type;
  typedef ::xsd::cxx::tree::optional< dialogue_portion_type > dialogue_portion_optional;
  typedef ::xsd::cxx::tree::traits< dialogue_portion_type, char > dialogue_portion_traits;

  const dialogue_portion_optional&
  dialogue_portion () const;

  dialogue_portion_optional&
  dialogue_portion ();

  void
  dialogue_portion (const dialogue_portion_type& x);

  void
  dialogue_portion (const dialogue_portion_optional& x);

  void
  dialogue_portion (::std::auto_ptr< dialogue_portion_type > p);

  // component-req-event
  // 
  typedef ::component_req_event_type component_req_event_type;
  typedef ::xsd::cxx::tree::sequence< component_req_event_type > component_req_event_sequence;
  typedef component_req_event_sequence::iterator component_req_event_iterator;
  typedef component_req_event_sequence::const_iterator component_req_event_const_iterator;
  typedef ::xsd::cxx::tree::traits< component_req_event_type, char > component_req_event_traits;

  const component_req_event_sequence&
  component_req_event () const;

  component_req_event_sequence&
  component_req_event ();

  void
  component_req_event (const component_req_event_sequence& s);

  // user-abort-information
  // 
  typedef ::xml_schema::hex_binary user_abort_information_type;
  typedef ::xsd::cxx::tree::optional< user_abort_information_type > user_abort_information_optional;
  typedef ::xsd::cxx::tree::traits< user_abort_information_type, char > user_abort_information_traits;

  const user_abort_information_optional&
  user_abort_information () const;

  user_abort_information_optional&
  user_abort_information ();

  void
  user_abort_information (const user_abort_information_type& x);

  void
  user_abort_information (const user_abort_information_optional& x);

  void
  user_abort_information (::std::auto_ptr< user_abort_information_type > p);

  // dialogue-id
  // 
  typedef ::xml_schema::integer dialogue_id_type;
  typedef ::xsd::cxx::tree::optional< dialogue_id_type > dialogue_id_optional;
  typedef ::xsd::cxx::tree::traits< dialogue_id_type, char > dialogue_id_traits;

  const dialogue_id_optional&
  dialogue_id () const;

  dialogue_id_optional&
  dialogue_id ();

  void
  dialogue_id (const dialogue_id_type& x);

  void
  dialogue_id (const dialogue_id_optional& x);

  // quality-of-service
  // 
  typedef ::xml_schema::byte quality_of_service_type;
  typedef ::xsd::cxx::tree::optional< quality_of_service_type > quality_of_service_optional;
  typedef ::xsd::cxx::tree::traits< quality_of_service_type, char > quality_of_service_traits;

  const quality_of_service_optional&
  quality_of_service () const;

  quality_of_service_optional&
  quality_of_service ();

  void
  quality_of_service (const quality_of_service_type& x);

  void
  quality_of_service (const quality_of_service_optional& x);

  // abort-reason
  // 
  typedef ::abort_reason1 abort_reason_type;
  typedef ::xsd::cxx::tree::optional< abort_reason_type > abort_reason_optional;
  typedef ::xsd::cxx::tree::traits< abort_reason_type, char > abort_reason_traits;

  const abort_reason_optional&
  abort_reason () const;

  abort_reason_optional&
  abort_reason ();

  void
  abort_reason (const abort_reason_type& x);

  void
  abort_reason (const abort_reason_optional& x);

  void
  abort_reason (::std::auto_ptr< abort_reason_type > p);

  // Constructors.
  //
  user_abort_req_event_type ();

  user_abort_req_event_type (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::type* c = 0);

  user_abort_req_event_type (const user_abort_req_event_type& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::type* c = 0);

  virtual user_abort_req_event_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::type* c = 0) const;

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  private:
  dialogue_portion_optional dialogue_portion_;
  component_req_event_sequence component_req_event_;
  user_abort_information_optional user_abort_information_;
  dialogue_id_optional dialogue_id_;
  quality_of_service_optional quality_of_service_;
  abort_reason_optional abort_reason_;
};

class begin_ind_event_type: public ::xml_schema::type
{
  public:
  // dialogue-portion
  // 
  typedef ::dialogue_portion_type dialogue_portion_type;
  typedef ::xsd::cxx::tree::optional< dialogue_portion_type > dialogue_portion_optional;
  typedef ::xsd::cxx::tree::traits< dialogue_portion_type, char > dialogue_portion_traits;

  const dialogue_portion_optional&
  dialogue_portion () const;

  dialogue_portion_optional&
  dialogue_portion ();

  void
  dialogue_portion (const dialogue_portion_type& x);

  void
  dialogue_portion (const dialogue_portion_optional& x);

  void
  dialogue_portion (::std::auto_ptr< dialogue_portion_type > p);

  // component-ind-event
  // 
  typedef ::component_ind_event_type component_ind_event_type;
  typedef ::xsd::cxx::tree::sequence< component_ind_event_type > component_ind_event_sequence;
  typedef component_ind_event_sequence::iterator component_ind_event_iterator;
  typedef component_ind_event_sequence::const_iterator component_ind_event_const_iterator;
  typedef ::xsd::cxx::tree::traits< component_ind_event_type, char > component_ind_event_traits;

  const component_ind_event_sequence&
  component_ind_event () const;

  component_ind_event_sequence&
  component_ind_event ();

  void
  component_ind_event (const component_ind_event_sequence& s);

  // destination-address
  // 
  typedef ::sccp_user_address_type destination_address_type;
  typedef ::xsd::cxx::tree::traits< destination_address_type, char > destination_address_traits;

  const destination_address_type&
  destination_address () const;

  destination_address_type&
  destination_address ();

  void
  destination_address (const destination_address_type& x);

  void
  destination_address (::std::auto_ptr< destination_address_type > p);

  // originating-address
  // 
  typedef ::sccp_user_address_type originating_address_type;
  typedef ::xsd::cxx::tree::traits< originating_address_type, char > originating_address_traits;

  const originating_address_type&
  originating_address () const;

  originating_address_type&
  originating_address ();

  void
  originating_address (const originating_address_type& x);

  void
  originating_address (::std::auto_ptr< originating_address_type > p);

  // dialogue-id
  // 
  typedef ::xml_schema::integer dialogue_id_type;
  typedef ::xsd::cxx::tree::optional< dialogue_id_type > dialogue_id_optional;
  typedef ::xsd::cxx::tree::traits< dialogue_id_type, char > dialogue_id_traits;

  const dialogue_id_optional&
  dialogue_id () const;

  dialogue_id_optional&
  dialogue_id ();

  void
  dialogue_id (const dialogue_id_type& x);

  void
  dialogue_id (const dialogue_id_optional& x);

  // quality-of-service
  // 
  typedef ::xml_schema::byte quality_of_service_type;
  typedef ::xsd::cxx::tree::optional< quality_of_service_type > quality_of_service_optional;
  typedef ::xsd::cxx::tree::traits< quality_of_service_type, char > quality_of_service_traits;

  const quality_of_service_optional&
  quality_of_service () const;

  quality_of_service_optional&
  quality_of_service ();

  void
  quality_of_service (const quality_of_service_type& x);

  void
  quality_of_service (const quality_of_service_optional& x);

  // allowed-permission
  // 
  typedef ::xml_schema::boolean allowed_permission_type;
  typedef ::xsd::cxx::tree::optional< allowed_permission_type > allowed_permission_optional;
  typedef ::xsd::cxx::tree::traits< allowed_permission_type, char > allowed_permission_traits;

  const allowed_permission_optional&
  allowed_permission () const;

  allowed_permission_optional&
  allowed_permission ();

  void
  allowed_permission (const allowed_permission_type& x);

  void
  allowed_permission (const allowed_permission_optional& x);

  // Constructors.
  //
  begin_ind_event_type (const destination_address_type&,
                        const originating_address_type&);

  begin_ind_event_type (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::type* c = 0);

  begin_ind_event_type (const begin_ind_event_type& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::type* c = 0);

  virtual begin_ind_event_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::type* c = 0) const;

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  private:
  dialogue_portion_optional dialogue_portion_;
  component_ind_event_sequence component_ind_event_;
  ::xsd::cxx::tree::one< destination_address_type > destination_address_;
  ::xsd::cxx::tree::one< originating_address_type > originating_address_;
  dialogue_id_optional dialogue_id_;
  quality_of_service_optional quality_of_service_;
  allowed_permission_optional allowed_permission_;
};

class invoke_req_event_type: public ::xml_schema::type
{
  public:
  // operation
  // 
  typedef ::operation_type_def operation_type;
  typedef ::xsd::cxx::tree::traits< operation_type, char > operation_traits;

  const operation_type&
  operation () const;

  operation_type&
  operation ();

  void
  operation (const operation_type& x);

  void
  operation (::std::auto_ptr< operation_type > p);

  // parameters
  // 
  typedef ::parameters_type parameters_type;
  typedef ::xsd::cxx::tree::optional< parameters_type > parameters_optional;
  typedef ::xsd::cxx::tree::traits< parameters_type, char > parameters_traits;

  const parameters_optional&
  parameters () const;

  parameters_optional&
  parameters ();

  void
  parameters (const parameters_type& x);

  void
  parameters (const parameters_optional& x);

  void
  parameters (::std::auto_ptr< parameters_type > p);

  // time-out
  // 
  typedef ::xml_schema::long_ time_out_type;
  typedef ::xsd::cxx::tree::optional< time_out_type > time_out_optional;
  typedef ::xsd::cxx::tree::traits< time_out_type, char > time_out_traits;

  const time_out_optional&
  time_out () const;

  time_out_optional&
  time_out ();

  void
  time_out (const time_out_type& x);

  void
  time_out (const time_out_optional& x);

  // dialogue-id
  // 
  typedef ::xml_schema::integer dialogue_id_type;
  typedef ::xsd::cxx::tree::optional< dialogue_id_type > dialogue_id_optional;
  typedef ::xsd::cxx::tree::traits< dialogue_id_type, char > dialogue_id_traits;

  const dialogue_id_optional&
  dialogue_id () const;

  dialogue_id_optional&
  dialogue_id ();

  void
  dialogue_id (const dialogue_id_type& x);

  void
  dialogue_id (const dialogue_id_optional& x);

  // invoke-id
  // 
  typedef ::xml_schema::integer invoke_id_type;
  typedef ::xsd::cxx::tree::optional< invoke_id_type > invoke_id_optional;
  typedef ::xsd::cxx::tree::traits< invoke_id_type, char > invoke_id_traits;

  const invoke_id_optional&
  invoke_id () const;

  invoke_id_optional&
  invoke_id ();

  void
  invoke_id (const invoke_id_type& x);

  void
  invoke_id (const invoke_id_optional& x);

  // linked-id
  // 
  typedef ::xml_schema::integer linked_id_type;
  typedef ::xsd::cxx::tree::optional< linked_id_type > linked_id_optional;
  typedef ::xsd::cxx::tree::traits< linked_id_type, char > linked_id_traits;

  const linked_id_optional&
  linked_id () const;

  linked_id_optional&
  linked_id ();

  void
  linked_id (const linked_id_type& x);

  void
  linked_id (const linked_id_optional& x);

  // class-type
  // 
  typedef ::class_type class_type_type;
  typedef ::xsd::cxx::tree::optional< class_type_type > class_type_optional;
  typedef ::xsd::cxx::tree::traits< class_type_type, char > class_type_traits;

  const class_type_optional&
  class_type () const;

  class_type_optional&
  class_type ();

  void
  class_type (const class_type_type& x);

  void
  class_type (const class_type_optional& x);

  void
  class_type (::std::auto_ptr< class_type_type > p);

  // last-invoke-event
  // 
  typedef ::xml_schema::boolean last_invoke_event_type;
  typedef ::xsd::cxx::tree::optional< last_invoke_event_type > last_invoke_event_optional;
  typedef ::xsd::cxx::tree::traits< last_invoke_event_type, char > last_invoke_event_traits;

  const last_invoke_event_optional&
  last_invoke_event () const;

  last_invoke_event_optional&
  last_invoke_event ();

  void
  last_invoke_event (const last_invoke_event_type& x);

  void
  last_invoke_event (const last_invoke_event_optional& x);

  // Constructors.
  //
  invoke_req_event_type (const operation_type&);

  invoke_req_event_type (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::type* c = 0);

  invoke_req_event_type (const invoke_req_event_type& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::type* c = 0);

  virtual invoke_req_event_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::type* c = 0) const;

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  private:
  ::xsd::cxx::tree::one< operation_type > operation_;
  parameters_optional parameters_;
  time_out_optional time_out_;
  dialogue_id_optional dialogue_id_;
  invoke_id_optional invoke_id_;
  linked_id_optional linked_id_;
  class_type_optional class_type_;
  last_invoke_event_optional last_invoke_event_;
};

class gtindicator0100_type: public ::xml_schema::type
{
  public:
  // address-information
  // 
  typedef ::xml_schema::hex_binary address_information_type;
  typedef ::xsd::cxx::tree::optional< address_information_type > address_information_optional;
  typedef ::xsd::cxx::tree::traits< address_information_type, char > address_information_traits;

  const address_information_optional&
  address_information () const;

  address_information_optional&
  address_information ();

  void
  address_information (const address_information_type& x);

  void
  address_information (const address_information_optional& x);

  void
  address_information (::std::auto_ptr< address_information_type > p);

  // translation-type
  // 
  typedef ::xml_schema::byte translation_type_type;
  typedef ::xsd::cxx::tree::traits< translation_type_type, char > translation_type_traits;

  const translation_type_type&
  translation_type () const;

  translation_type_type&
  translation_type ();

  void
  translation_type (const translation_type_type& x);

  // numbering-plan
  // 
  typedef ::numbering_plan1 numbering_plan_type;
  typedef ::xsd::cxx::tree::traits< numbering_plan_type, char > numbering_plan_traits;

  const numbering_plan_type&
  numbering_plan () const;

  numbering_plan_type&
  numbering_plan ();

  void
  numbering_plan (const numbering_plan_type& x);

  void
  numbering_plan (::std::auto_ptr< numbering_plan_type > p);

  // nature-of-addr-ind
  // 
  typedef ::nature_of_addr_ind1 nature_of_addr_ind_type;
  typedef ::xsd::cxx::tree::traits< nature_of_addr_ind_type, char > nature_of_addr_ind_traits;

  const nature_of_addr_ind_type&
  nature_of_addr_ind () const;

  nature_of_addr_ind_type&
  nature_of_addr_ind ();

  void
  nature_of_addr_ind (const nature_of_addr_ind_type& x);

  void
  nature_of_addr_ind (::std::auto_ptr< nature_of_addr_ind_type > p);

  // encoding-scheme
  // 
  typedef ::encoding_scheme1 encoding_scheme_type;
  typedef ::xsd::cxx::tree::traits< encoding_scheme_type, char > encoding_scheme_traits;

  const encoding_scheme_type&
  encoding_scheme () const;

  encoding_scheme_type&
  encoding_scheme ();

  void
  encoding_scheme (const encoding_scheme_type& x);

  void
  encoding_scheme (::std::auto_ptr< encoding_scheme_type > p);

  // Constructors.
  //
  gtindicator0100_type (const translation_type_type&,
                        const numbering_plan_type&,
                        const nature_of_addr_ind_type&,
                        const encoding_scheme_type&);

  gtindicator0100_type (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::type* c = 0);

  gtindicator0100_type (const gtindicator0100_type& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::type* c = 0);

  virtual gtindicator0100_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::type* c = 0) const;

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  private:
  address_information_optional address_information_;
  ::xsd::cxx::tree::one< translation_type_type > translation_type_;
  ::xsd::cxx::tree::one< numbering_plan_type > numbering_plan_;
  ::xsd::cxx::tree::one< nature_of_addr_ind_type > nature_of_addr_ind_;
  ::xsd::cxx::tree::one< encoding_scheme_type > encoding_scheme_;
};

class sub_system_address_type: public ::xml_schema::type
{
  public:
  // signaling-point-code
  // 
  typedef ::signaling_point_code_type signaling_point_code_type;
  typedef ::xsd::cxx::tree::traits< signaling_point_code_type, char > signaling_point_code_traits;

  const signaling_point_code_type&
  signaling_point_code () const;

  signaling_point_code_type&
  signaling_point_code ();

  void
  signaling_point_code (const signaling_point_code_type& x);

  void
  signaling_point_code (::std::auto_ptr< signaling_point_code_type > p);

  // sub-system-number
  // 
  typedef ::xml_schema::integer sub_system_number_type;
  typedef ::xsd::cxx::tree::traits< sub_system_number_type, char > sub_system_number_traits;

  const sub_system_number_type&
  sub_system_number () const;

  sub_system_number_type&
  sub_system_number ();

  void
  sub_system_number (const sub_system_number_type& x);

  // Constructors.
  //
  sub_system_address_type (const signaling_point_code_type&,
                           const sub_system_number_type&);

  sub_system_address_type (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::type* c = 0);

  sub_system_address_type (const sub_system_address_type& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::type* c = 0);

  virtual sub_system_address_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::type* c = 0) const;

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  private:
  ::xsd::cxx::tree::one< signaling_point_code_type > signaling_point_code_;
  ::xsd::cxx::tree::one< sub_system_number_type > sub_system_number_;
};

class signaling_point_code_type: public ::xml_schema::type
{
  public:
  // member
  // 
  typedef ::xml_schema::integer member_type;
  typedef ::xsd::cxx::tree::traits< member_type, char > member_traits;

  const member_type&
  member () const;

  member_type&
  member ();

  void
  member (const member_type& x);

  // cluster
  // 
  typedef ::xml_schema::integer cluster_type;
  typedef ::xsd::cxx::tree::traits< cluster_type, char > cluster_traits;

  const cluster_type&
  cluster () const;

  cluster_type&
  cluster ();

  void
  cluster (const cluster_type& x);

  // zone
  // 
  typedef ::xml_schema::integer zone_type;
  typedef ::xsd::cxx::tree::traits< zone_type, char > zone_traits;

  const zone_type&
  zone () const;

  zone_type&
  zone ();

  void
  zone (const zone_type& x);

  // Constructors.
  //
  signaling_point_code_type (const member_type&,
                             const cluster_type&,
                             const zone_type&);

  signaling_point_code_type (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::type* c = 0);

  signaling_point_code_type (const signaling_point_code_type& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::type* c = 0);

  virtual signaling_point_code_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::type* c = 0) const;

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  private:
  ::xsd::cxx::tree::one< member_type > member_;
  ::xsd::cxx::tree::one< cluster_type > cluster_;
  ::xsd::cxx::tree::one< zone_type > zone_;
};

class unidirectional_req_event_type: public ::xml_schema::type
{
  public:
  // dialogue-portion
  // 
  typedef ::dialogue_portion_type dialogue_portion_type;
  typedef ::xsd::cxx::tree::optional< dialogue_portion_type > dialogue_portion_optional;
  typedef ::xsd::cxx::tree::traits< dialogue_portion_type, char > dialogue_portion_traits;

  const dialogue_portion_optional&
  dialogue_portion () const;

  dialogue_portion_optional&
  dialogue_portion ();

  void
  dialogue_portion (const dialogue_portion_type& x);

  void
  dialogue_portion (const dialogue_portion_optional& x);

  void
  dialogue_portion (::std::auto_ptr< dialogue_portion_type > p);

  // component-req-event
  // 
  typedef ::component_req_event_type component_req_event_type;
  typedef ::xsd::cxx::tree::sequence< component_req_event_type > component_req_event_sequence;
  typedef component_req_event_sequence::iterator component_req_event_iterator;
  typedef component_req_event_sequence::const_iterator component_req_event_const_iterator;
  typedef ::xsd::cxx::tree::traits< component_req_event_type, char > component_req_event_traits;

  const component_req_event_sequence&
  component_req_event () const;

  component_req_event_sequence&
  component_req_event ();

  void
  component_req_event (const component_req_event_sequence& s);

  // destination-address
  // 
  typedef ::sccp_user_address_type destination_address_type;
  typedef ::xsd::cxx::tree::traits< destination_address_type, char > destination_address_traits;

  const destination_address_type&
  destination_address () const;

  destination_address_type&
  destination_address ();

  void
  destination_address (const destination_address_type& x);

  void
  destination_address (::std::auto_ptr< destination_address_type > p);

  // originating-address
  // 
  typedef ::sccp_user_address_type originating_address_type;
  typedef ::xsd::cxx::tree::traits< originating_address_type, char > originating_address_traits;

  const originating_address_type&
  originating_address () const;

  originating_address_type&
  originating_address ();

  void
  originating_address (const originating_address_type& x);

  void
  originating_address (::std::auto_ptr< originating_address_type > p);

  // dialogue-id
  // 
  typedef ::xml_schema::integer dialogue_id_type;
  typedef ::xsd::cxx::tree::optional< dialogue_id_type > dialogue_id_optional;
  typedef ::xsd::cxx::tree::traits< dialogue_id_type, char > dialogue_id_traits;

  const dialogue_id_optional&
  dialogue_id () const;

  dialogue_id_optional&
  dialogue_id ();

  void
  dialogue_id (const dialogue_id_type& x);

  void
  dialogue_id (const dialogue_id_optional& x);

  // quality-of-service
  // 
  typedef ::xml_schema::byte quality_of_service_type;
  typedef ::xsd::cxx::tree::optional< quality_of_service_type > quality_of_service_optional;
  typedef ::xsd::cxx::tree::traits< quality_of_service_type, char > quality_of_service_traits;

  const quality_of_service_optional&
  quality_of_service () const;

  quality_of_service_optional&
  quality_of_service ();

  void
  quality_of_service (const quality_of_service_type& x);

  void
  quality_of_service (const quality_of_service_optional& x);

  // Constructors.
  //
  unidirectional_req_event_type (const destination_address_type&,
                                 const originating_address_type&);

  unidirectional_req_event_type (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::type* c = 0);

  unidirectional_req_event_type (const unidirectional_req_event_type& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::type* c = 0);

  virtual unidirectional_req_event_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::type* c = 0) const;

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  private:
  dialogue_portion_optional dialogue_portion_;
  component_req_event_sequence component_req_event_;
  ::xsd::cxx::tree::one< destination_address_type > destination_address_;
  ::xsd::cxx::tree::one< originating_address_type > originating_address_;
  dialogue_id_optional dialogue_id_;
  quality_of_service_optional quality_of_service_;
};

class reject_ind_event_type: public ::xml_schema::type
{
  public:
  // parameters
  // 
  typedef ::parameters_type parameters_type;
  typedef ::xsd::cxx::tree::optional< parameters_type > parameters_optional;
  typedef ::xsd::cxx::tree::traits< parameters_type, char > parameters_traits;

  const parameters_optional&
  parameters () const;

  parameters_optional&
  parameters ();

  void
  parameters (const parameters_type& x);

  void
  parameters (const parameters_optional& x);

  void
  parameters (::std::auto_ptr< parameters_type > p);

  // dialogue-id
  // 
  typedef ::xml_schema::integer dialogue_id_type;
  typedef ::xsd::cxx::tree::optional< dialogue_id_type > dialogue_id_optional;
  typedef ::xsd::cxx::tree::traits< dialogue_id_type, char > dialogue_id_traits;

  const dialogue_id_optional&
  dialogue_id () const;

  dialogue_id_optional&
  dialogue_id ();

  void
  dialogue_id (const dialogue_id_type& x);

  void
  dialogue_id (const dialogue_id_optional& x);

  // invoke-id
  // 
  typedef ::xml_schema::integer invoke_id_type;
  typedef ::xsd::cxx::tree::optional< invoke_id_type > invoke_id_optional;
  typedef ::xsd::cxx::tree::traits< invoke_id_type, char > invoke_id_traits;

  const invoke_id_optional&
  invoke_id () const;

  invoke_id_optional&
  invoke_id ();

  void
  invoke_id (const invoke_id_type& x);

  void
  invoke_id (const invoke_id_optional& x);

  // last-component
  // 
  typedef ::xml_schema::boolean last_component_type;
  typedef ::xsd::cxx::tree::optional< last_component_type > last_component_optional;
  typedef ::xsd::cxx::tree::traits< last_component_type, char > last_component_traits;

  const last_component_optional&
  last_component () const;

  last_component_optional&
  last_component ();

  void
  last_component (const last_component_type& x);

  void
  last_component (const last_component_optional& x);

  // link-id
  // 
  typedef ::xml_schema::integer link_id_type;
  typedef ::xsd::cxx::tree::optional< link_id_type > link_id_optional;
  typedef ::xsd::cxx::tree::traits< link_id_type, char > link_id_traits;

  const link_id_optional&
  link_id () const;

  link_id_optional&
  link_id ();

  void
  link_id (const link_id_type& x);

  void
  link_id (const link_id_optional& x);

  // problem-type
  // 
  typedef ::problem_type1 problem_type_type;
  typedef ::xsd::cxx::tree::traits< problem_type_type, char > problem_type_traits;

  const problem_type_type&
  problem_type () const;

  problem_type_type&
  problem_type ();

  void
  problem_type (const problem_type_type& x);

  void
  problem_type (::std::auto_ptr< problem_type_type > p);

  // problem
  // 
  typedef ::problem1 problem_type1;
  typedef ::xsd::cxx::tree::traits< problem_type1, char > problem_traits;

  const problem_type1&
  problem () const;

  problem_type1&
  problem ();

  void
  problem (const problem_type1& x);

  void
  problem (::std::auto_ptr< problem_type1 > p);

  // reject-type
  // 
  typedef ::reject_type1 reject_type_type;
  typedef ::xsd::cxx::tree::optional< reject_type_type > reject_type_optional;
  typedef ::xsd::cxx::tree::traits< reject_type_type, char > reject_type_traits;

  const reject_type_optional&
  reject_type () const;

  reject_type_optional&
  reject_type ();

  void
  reject_type (const reject_type_type& x);

  void
  reject_type (const reject_type_optional& x);

  void
  reject_type (::std::auto_ptr< reject_type_type > p);

  // Constructors.
  //
  reject_ind_event_type (const problem_type_type&,
                         const problem_type1&);

  reject_ind_event_type (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::type* c = 0);

  reject_ind_event_type (const reject_ind_event_type& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::type* c = 0);

  virtual reject_ind_event_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::type* c = 0) const;

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  private:
  parameters_optional parameters_;
  dialogue_id_optional dialogue_id_;
  invoke_id_optional invoke_id_;
  last_component_optional last_component_;
  link_id_optional link_id_;
  ::xsd::cxx::tree::one< problem_type_type > problem_type_;
  ::xsd::cxx::tree::one< problem_type1 > problem_;
  reject_type_optional reject_type_;
};

class local_cancel_ind_event_type: public ::xml_schema::type
{
  public:
  // dialogue-id
  // 
  typedef ::xml_schema::integer dialogue_id_type;
  typedef ::xsd::cxx::tree::optional< dialogue_id_type > dialogue_id_optional;
  typedef ::xsd::cxx::tree::traits< dialogue_id_type, char > dialogue_id_traits;

  const dialogue_id_optional&
  dialogue_id () const;

  dialogue_id_optional&
  dialogue_id ();

  void
  dialogue_id (const dialogue_id_type& x);

  void
  dialogue_id (const dialogue_id_optional& x);

  // invoke-id
  // 
  typedef ::xml_schema::integer invoke_id_type;
  typedef ::xsd::cxx::tree::optional< invoke_id_type > invoke_id_optional;
  typedef ::xsd::cxx::tree::traits< invoke_id_type, char > invoke_id_traits;

  const invoke_id_optional&
  invoke_id () const;

  invoke_id_optional&
  invoke_id ();

  void
  invoke_id (const invoke_id_type& x);

  void
  invoke_id (const invoke_id_optional& x);

  // last-component
  // 
  typedef ::xml_schema::boolean last_component_type;
  typedef ::xsd::cxx::tree::optional< last_component_type > last_component_optional;
  typedef ::xsd::cxx::tree::traits< last_component_type, char > last_component_traits;

  const last_component_optional&
  last_component () const;

  last_component_optional&
  last_component ();

  void
  last_component (const last_component_type& x);

  void
  last_component (const last_component_optional& x);

  // Constructors.
  //
  local_cancel_ind_event_type ();

  local_cancel_ind_event_type (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::type* c = 0);

  local_cancel_ind_event_type (const local_cancel_ind_event_type& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::type* c = 0);

  virtual local_cancel_ind_event_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::type* c = 0) const;

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  private:
  dialogue_id_optional dialogue_id_;
  invoke_id_optional invoke_id_;
  last_component_optional last_component_;
};

class gtindicator0011_type: public ::xml_schema::type
{
  public:
  // address-information
  // 
  typedef ::xml_schema::hex_binary address_information_type;
  typedef ::xsd::cxx::tree::optional< address_information_type > address_information_optional;
  typedef ::xsd::cxx::tree::traits< address_information_type, char > address_information_traits;

  const address_information_optional&
  address_information () const;

  address_information_optional&
  address_information ();

  void
  address_information (const address_information_type& x);

  void
  address_information (const address_information_optional& x);

  void
  address_information (::std::auto_ptr< address_information_type > p);

  // translation-type
  // 
  typedef ::xml_schema::byte translation_type_type;
  typedef ::xsd::cxx::tree::traits< translation_type_type, char > translation_type_traits;

  const translation_type_type&
  translation_type () const;

  translation_type_type&
  translation_type ();

  void
  translation_type (const translation_type_type& x);

  // numbering-plan
  // 
  typedef ::numbering_plan2 numbering_plan_type;
  typedef ::xsd::cxx::tree::traits< numbering_plan_type, char > numbering_plan_traits;

  const numbering_plan_type&
  numbering_plan () const;

  numbering_plan_type&
  numbering_plan ();

  void
  numbering_plan (const numbering_plan_type& x);

  void
  numbering_plan (::std::auto_ptr< numbering_plan_type > p);

  // encoding-scheme
  // 
  typedef ::encoding_scheme2 encoding_scheme_type;
  typedef ::xsd::cxx::tree::traits< encoding_scheme_type, char > encoding_scheme_traits;

  const encoding_scheme_type&
  encoding_scheme () const;

  encoding_scheme_type&
  encoding_scheme ();

  void
  encoding_scheme (const encoding_scheme_type& x);

  void
  encoding_scheme (::std::auto_ptr< encoding_scheme_type > p);

  // Constructors.
  //
  gtindicator0011_type (const translation_type_type&,
                        const numbering_plan_type&,
                        const encoding_scheme_type&);

  gtindicator0011_type (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::type* c = 0);

  gtindicator0011_type (const gtindicator0011_type& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::type* c = 0);

  virtual gtindicator0011_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::type* c = 0) const;

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  private:
  address_information_optional address_information_;
  ::xsd::cxx::tree::one< translation_type_type > translation_type_;
  ::xsd::cxx::tree::one< numbering_plan_type > numbering_plan_;
  ::xsd::cxx::tree::one< encoding_scheme_type > encoding_scheme_;
};

class continue_req_event_type: public ::xml_schema::type
{
  public:
  // dialogue-portion
  // 
  typedef ::dialogue_portion_type dialogue_portion_type;
  typedef ::xsd::cxx::tree::optional< dialogue_portion_type > dialogue_portion_optional;
  typedef ::xsd::cxx::tree::traits< dialogue_portion_type, char > dialogue_portion_traits;

  const dialogue_portion_optional&
  dialogue_portion () const;

  dialogue_portion_optional&
  dialogue_portion ();

  void
  dialogue_portion (const dialogue_portion_type& x);

  void
  dialogue_portion (const dialogue_portion_optional& x);

  void
  dialogue_portion (::std::auto_ptr< dialogue_portion_type > p);

  // component-req-event
  // 
  typedef ::component_req_event_type component_req_event_type;
  typedef ::xsd::cxx::tree::sequence< component_req_event_type > component_req_event_sequence;
  typedef component_req_event_sequence::iterator component_req_event_iterator;
  typedef component_req_event_sequence::const_iterator component_req_event_const_iterator;
  typedef ::xsd::cxx::tree::traits< component_req_event_type, char > component_req_event_traits;

  const component_req_event_sequence&
  component_req_event () const;

  component_req_event_sequence&
  component_req_event ();

  void
  component_req_event (const component_req_event_sequence& s);

  // originating-address
  // 
  typedef ::sccp_user_address_type originating_address_type;
  typedef ::xsd::cxx::tree::optional< originating_address_type > originating_address_optional;
  typedef ::xsd::cxx::tree::traits< originating_address_type, char > originating_address_traits;

  const originating_address_optional&
  originating_address () const;

  originating_address_optional&
  originating_address ();

  void
  originating_address (const originating_address_type& x);

  void
  originating_address (const originating_address_optional& x);

  void
  originating_address (::std::auto_ptr< originating_address_type > p);

  // dialogue-id
  // 
  typedef ::xml_schema::integer dialogue_id_type;
  typedef ::xsd::cxx::tree::optional< dialogue_id_type > dialogue_id_optional;
  typedef ::xsd::cxx::tree::traits< dialogue_id_type, char > dialogue_id_traits;

  const dialogue_id_optional&
  dialogue_id () const;

  dialogue_id_optional&
  dialogue_id ();

  void
  dialogue_id (const dialogue_id_type& x);

  void
  dialogue_id (const dialogue_id_optional& x);

  // quality-of-service
  // 
  typedef ::xml_schema::byte quality_of_service_type;
  typedef ::xsd::cxx::tree::optional< quality_of_service_type > quality_of_service_optional;
  typedef ::xsd::cxx::tree::traits< quality_of_service_type, char > quality_of_service_traits;

  const quality_of_service_optional&
  quality_of_service () const;

  quality_of_service_optional&
  quality_of_service ();

  void
  quality_of_service (const quality_of_service_type& x);

  void
  quality_of_service (const quality_of_service_optional& x);

  // allowed-permission
  // 
  typedef ::xml_schema::boolean allowed_permission_type;
  typedef ::xsd::cxx::tree::optional< allowed_permission_type > allowed_permission_optional;
  typedef ::xsd::cxx::tree::traits< allowed_permission_type, char > allowed_permission_traits;

  const allowed_permission_optional&
  allowed_permission () const;

  allowed_permission_optional&
  allowed_permission ();

  void
  allowed_permission (const allowed_permission_type& x);

  void
  allowed_permission (const allowed_permission_optional& x);

  // Constructors.
  //
  continue_req_event_type ();

  continue_req_event_type (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::type* c = 0);

  continue_req_event_type (const continue_req_event_type& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::type* c = 0);

  virtual continue_req_event_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::type* c = 0) const;

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  private:
  dialogue_portion_optional dialogue_portion_;
  component_req_event_sequence component_req_event_;
  originating_address_optional originating_address_;
  dialogue_id_optional dialogue_id_;
  quality_of_service_optional quality_of_service_;
  allowed_permission_optional allowed_permission_;
};

class nstate_req_event_type: public ::xml_schema::type
{
  public:
  // affected-user
  // 
  typedef ::sccp_user_address_type affected_user_type;
  typedef ::xsd::cxx::tree::traits< affected_user_type, char > affected_user_traits;

  const affected_user_type&
  affected_user () const;

  affected_user_type&
  affected_user ();

  void
  affected_user (const affected_user_type& x);

  void
  affected_user (::std::auto_ptr< affected_user_type > p);

  // user-status
  // 
  typedef ::user_status1 user_status_type;
  typedef ::xsd::cxx::tree::traits< user_status_type, char > user_status_traits;

  const user_status_type&
  user_status () const;

  user_status_type&
  user_status ();

  void
  user_status (const user_status_type& x);

  void
  user_status (::std::auto_ptr< user_status_type > p);

  // Constructors.
  //
  nstate_req_event_type (const affected_user_type&,
                         const user_status_type&);

  nstate_req_event_type (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::type* c = 0);

  nstate_req_event_type (const nstate_req_event_type& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::type* c = 0);

  virtual nstate_req_event_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::type* c = 0) const;

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  private:
  ::xsd::cxx::tree::one< affected_user_type > affected_user_;
  ::xsd::cxx::tree::one< user_status_type > user_status_;
};

class unidirectional_ind_event_type: public ::xml_schema::type
{
  public:
  // dialogue-portion
  // 
  typedef ::dialogue_portion_type dialogue_portion_type;
  typedef ::xsd::cxx::tree::optional< dialogue_portion_type > dialogue_portion_optional;
  typedef ::xsd::cxx::tree::traits< dialogue_portion_type, char > dialogue_portion_traits;

  const dialogue_portion_optional&
  dialogue_portion () const;

  dialogue_portion_optional&
  dialogue_portion ();

  void
  dialogue_portion (const dialogue_portion_type& x);

  void
  dialogue_portion (const dialogue_portion_optional& x);

  void
  dialogue_portion (::std::auto_ptr< dialogue_portion_type > p);

  // component-ind-event
  // 
  typedef ::component_ind_event_type component_ind_event_type;
  typedef ::xsd::cxx::tree::sequence< component_ind_event_type > component_ind_event_sequence;
  typedef component_ind_event_sequence::iterator component_ind_event_iterator;
  typedef component_ind_event_sequence::const_iterator component_ind_event_const_iterator;
  typedef ::xsd::cxx::tree::traits< component_ind_event_type, char > component_ind_event_traits;

  const component_ind_event_sequence&
  component_ind_event () const;

  component_ind_event_sequence&
  component_ind_event ();

  void
  component_ind_event (const component_ind_event_sequence& s);

  // destination-address
  // 
  typedef ::sccp_user_address_type destination_address_type;
  typedef ::xsd::cxx::tree::traits< destination_address_type, char > destination_address_traits;

  const destination_address_type&
  destination_address () const;

  destination_address_type&
  destination_address ();

  void
  destination_address (const destination_address_type& x);

  void
  destination_address (::std::auto_ptr< destination_address_type > p);

  // originating-address
  // 
  typedef ::sccp_user_address_type originating_address_type;
  typedef ::xsd::cxx::tree::traits< originating_address_type, char > originating_address_traits;

  const originating_address_type&
  originating_address () const;

  originating_address_type&
  originating_address ();

  void
  originating_address (const originating_address_type& x);

  void
  originating_address (::std::auto_ptr< originating_address_type > p);

  // dialogue-id
  // 
  typedef ::xml_schema::integer dialogue_id_type;
  typedef ::xsd::cxx::tree::optional< dialogue_id_type > dialogue_id_optional;
  typedef ::xsd::cxx::tree::traits< dialogue_id_type, char > dialogue_id_traits;

  const dialogue_id_optional&
  dialogue_id () const;

  dialogue_id_optional&
  dialogue_id ();

  void
  dialogue_id (const dialogue_id_type& x);

  void
  dialogue_id (const dialogue_id_optional& x);

  // quality-of-service
  // 
  typedef ::xml_schema::byte quality_of_service_type;
  typedef ::xsd::cxx::tree::optional< quality_of_service_type > quality_of_service_optional;
  typedef ::xsd::cxx::tree::traits< quality_of_service_type, char > quality_of_service_traits;

  const quality_of_service_optional&
  quality_of_service () const;

  quality_of_service_optional&
  quality_of_service ();

  void
  quality_of_service (const quality_of_service_type& x);

  void
  quality_of_service (const quality_of_service_optional& x);

  // Constructors.
  //
  unidirectional_ind_event_type (const destination_address_type&,
                                 const originating_address_type&);

  unidirectional_ind_event_type (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::type* c = 0);

  unidirectional_ind_event_type (const unidirectional_ind_event_type& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::type* c = 0);

  virtual unidirectional_ind_event_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::type* c = 0) const;

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  private:
  dialogue_portion_optional dialogue_portion_;
  component_ind_event_sequence component_ind_event_;
  ::xsd::cxx::tree::one< destination_address_type > destination_address_;
  ::xsd::cxx::tree::one< originating_address_type > originating_address_;
  dialogue_id_optional dialogue_id_;
  quality_of_service_optional quality_of_service_;
};

class continue_ind_event_type: public ::xml_schema::type
{
  public:
  // dialogue-portion
  // 
  typedef ::dialogue_portion_type dialogue_portion_type;
  typedef ::xsd::cxx::tree::optional< dialogue_portion_type > dialogue_portion_optional;
  typedef ::xsd::cxx::tree::traits< dialogue_portion_type, char > dialogue_portion_traits;

  const dialogue_portion_optional&
  dialogue_portion () const;

  dialogue_portion_optional&
  dialogue_portion ();

  void
  dialogue_portion (const dialogue_portion_type& x);

  void
  dialogue_portion (const dialogue_portion_optional& x);

  void
  dialogue_portion (::std::auto_ptr< dialogue_portion_type > p);

  // component-ind-event
  // 
  typedef ::component_ind_event_type component_ind_event_type;
  typedef ::xsd::cxx::tree::sequence< component_ind_event_type > component_ind_event_sequence;
  typedef component_ind_event_sequence::iterator component_ind_event_iterator;
  typedef component_ind_event_sequence::const_iterator component_ind_event_const_iterator;
  typedef ::xsd::cxx::tree::traits< component_ind_event_type, char > component_ind_event_traits;

  const component_ind_event_sequence&
  component_ind_event () const;

  component_ind_event_sequence&
  component_ind_event ();

  void
  component_ind_event (const component_ind_event_sequence& s);

  // dialogue-id
  // 
  typedef ::xml_schema::integer dialogue_id_type;
  typedef ::xsd::cxx::tree::optional< dialogue_id_type > dialogue_id_optional;
  typedef ::xsd::cxx::tree::traits< dialogue_id_type, char > dialogue_id_traits;

  const dialogue_id_optional&
  dialogue_id () const;

  dialogue_id_optional&
  dialogue_id ();

  void
  dialogue_id (const dialogue_id_type& x);

  void
  dialogue_id (const dialogue_id_optional& x);

  // quality-of-service
  // 
  typedef ::xml_schema::byte quality_of_service_type;
  typedef ::xsd::cxx::tree::optional< quality_of_service_type > quality_of_service_optional;
  typedef ::xsd::cxx::tree::traits< quality_of_service_type, char > quality_of_service_traits;

  const quality_of_service_optional&
  quality_of_service () const;

  quality_of_service_optional&
  quality_of_service ();

  void
  quality_of_service (const quality_of_service_type& x);

  void
  quality_of_service (const quality_of_service_optional& x);

  // allowed-permission
  // 
  typedef ::xml_schema::boolean allowed_permission_type;
  typedef ::xsd::cxx::tree::optional< allowed_permission_type > allowed_permission_optional;
  typedef ::xsd::cxx::tree::traits< allowed_permission_type, char > allowed_permission_traits;

  const allowed_permission_optional&
  allowed_permission () const;

  allowed_permission_optional&
  allowed_permission ();

  void
  allowed_permission (const allowed_permission_type& x);

  void
  allowed_permission (const allowed_permission_optional& x);

  // Constructors.
  //
  continue_ind_event_type ();

  continue_ind_event_type (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::type* c = 0);

  continue_ind_event_type (const continue_ind_event_type& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::type* c = 0);

  virtual continue_ind_event_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::type* c = 0) const;

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  private:
  dialogue_portion_optional dialogue_portion_;
  component_ind_event_sequence component_ind_event_;
  dialogue_id_optional dialogue_id_;
  quality_of_service_optional quality_of_service_;
  allowed_permission_optional allowed_permission_;
};

class gtindicator0010_type: public ::xml_schema::type
{
  public:
  // address-information
  // 
  typedef ::xml_schema::hex_binary address_information_type;
  typedef ::xsd::cxx::tree::optional< address_information_type > address_information_optional;
  typedef ::xsd::cxx::tree::traits< address_information_type, char > address_information_traits;

  const address_information_optional&
  address_information () const;

  address_information_optional&
  address_information ();

  void
  address_information (const address_information_type& x);

  void
  address_information (const address_information_optional& x);

  void
  address_information (::std::auto_ptr< address_information_type > p);

  // translation-type
  // 
  typedef ::xml_schema::byte translation_type_type;
  typedef ::xsd::cxx::tree::traits< translation_type_type, char > translation_type_traits;

  const translation_type_type&
  translation_type () const;

  translation_type_type&
  translation_type ();

  void
  translation_type (const translation_type_type& x);

  // Constructors.
  //
  gtindicator0010_type (const translation_type_type&);

  gtindicator0010_type (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::type* c = 0);

  gtindicator0010_type (const gtindicator0010_type& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::type* c = 0);

  virtual gtindicator0010_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::type* c = 0) const;

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  private:
  address_information_optional address_information_;
  ::xsd::cxx::tree::one< translation_type_type > translation_type_;
};

class npcstate_ind_event_type: public ::xml_schema::type
{
  public:
  // affected-dpc
  // 
  typedef ::signaling_point_code_type affected_dpc_type;
  typedef ::xsd::cxx::tree::traits< affected_dpc_type, char > affected_dpc_traits;

  const affected_dpc_type&
  affected_dpc () const;

  affected_dpc_type&
  affected_dpc ();

  void
  affected_dpc (const affected_dpc_type& x);

  void
  affected_dpc (::std::auto_ptr< affected_dpc_type > p);

  // own-point-code
  // 
  typedef ::signaling_point_code_type own_point_code_type;
  typedef ::xsd::cxx::tree::traits< own_point_code_type, char > own_point_code_traits;

  const own_point_code_type&
  own_point_code () const;

  own_point_code_type&
  own_point_code ();

  void
  own_point_code (const own_point_code_type& x);

  void
  own_point_code (::std::auto_ptr< own_point_code_type > p);

  // signaling-point-status
  // 
  typedef ::signaling_point_status signaling_point_status_type;
  typedef ::xsd::cxx::tree::traits< signaling_point_status_type, char > signaling_point_status_traits;

  const signaling_point_status_type&
  signaling_point_status () const;

  signaling_point_status_type&
  signaling_point_status ();

  void
  signaling_point_status (const signaling_point_status_type& x);

  void
  signaling_point_status (::std::auto_ptr< signaling_point_status_type > p);

  // Constructors.
  //
  npcstate_ind_event_type (const affected_dpc_type&,
                           const own_point_code_type&,
                           const signaling_point_status_type&);

  npcstate_ind_event_type (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::type* c = 0);

  npcstate_ind_event_type (const npcstate_ind_event_type& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::type* c = 0);

  virtual npcstate_ind_event_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::type* c = 0) const;

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  private:
  ::xsd::cxx::tree::one< affected_dpc_type > affected_dpc_;
  ::xsd::cxx::tree::one< own_point_code_type > own_point_code_;
  ::xsd::cxx::tree::one< signaling_point_status_type > signaling_point_status_;
};

class begin_req_event_type: public ::xml_schema::type
{
  public:
  // dialogue-portion
  // 
  typedef ::dialogue_portion_type dialogue_portion_type;
  typedef ::xsd::cxx::tree::optional< dialogue_portion_type > dialogue_portion_optional;
  typedef ::xsd::cxx::tree::traits< dialogue_portion_type, char > dialogue_portion_traits;

  const dialogue_portion_optional&
  dialogue_portion () const;

  dialogue_portion_optional&
  dialogue_portion ();

  void
  dialogue_portion (const dialogue_portion_type& x);

  void
  dialogue_portion (const dialogue_portion_optional& x);

  void
  dialogue_portion (::std::auto_ptr< dialogue_portion_type > p);

  // component-req-event
  // 
  typedef ::component_req_event_type component_req_event_type;
  typedef ::xsd::cxx::tree::sequence< component_req_event_type > component_req_event_sequence;
  typedef component_req_event_sequence::iterator component_req_event_iterator;
  typedef component_req_event_sequence::const_iterator component_req_event_const_iterator;
  typedef ::xsd::cxx::tree::traits< component_req_event_type, char > component_req_event_traits;

  const component_req_event_sequence&
  component_req_event () const;

  component_req_event_sequence&
  component_req_event ();

  void
  component_req_event (const component_req_event_sequence& s);

  // destination-address
  // 
  typedef ::sccp_user_address_type destination_address_type;
  typedef ::xsd::cxx::tree::traits< destination_address_type, char > destination_address_traits;

  const destination_address_type&
  destination_address () const;

  destination_address_type&
  destination_address ();

  void
  destination_address (const destination_address_type& x);

  void
  destination_address (::std::auto_ptr< destination_address_type > p);

  // originating-address
  // 
  typedef ::sccp_user_address_type originating_address_type;
  typedef ::xsd::cxx::tree::traits< originating_address_type, char > originating_address_traits;

  const originating_address_type&
  originating_address () const;

  originating_address_type&
  originating_address ();

  void
  originating_address (const originating_address_type& x);

  void
  originating_address (::std::auto_ptr< originating_address_type > p);

  // dialogue-id
  // 
  typedef ::xml_schema::integer dialogue_id_type;
  typedef ::xsd::cxx::tree::optional< dialogue_id_type > dialogue_id_optional;
  typedef ::xsd::cxx::tree::traits< dialogue_id_type, char > dialogue_id_traits;

  const dialogue_id_optional&
  dialogue_id () const;

  dialogue_id_optional&
  dialogue_id ();

  void
  dialogue_id (const dialogue_id_type& x);

  void
  dialogue_id (const dialogue_id_optional& x);

  // quality-of-service
  // 
  typedef ::xml_schema::byte quality_of_service_type;
  typedef ::xsd::cxx::tree::optional< quality_of_service_type > quality_of_service_optional;
  typedef ::xsd::cxx::tree::traits< quality_of_service_type, char > quality_of_service_traits;

  const quality_of_service_optional&
  quality_of_service () const;

  quality_of_service_optional&
  quality_of_service ();

  void
  quality_of_service (const quality_of_service_type& x);

  void
  quality_of_service (const quality_of_service_optional& x);

  // allowed-permission
  // 
  typedef ::xml_schema::boolean allowed_permission_type;
  typedef ::xsd::cxx::tree::optional< allowed_permission_type > allowed_permission_optional;
  typedef ::xsd::cxx::tree::traits< allowed_permission_type, char > allowed_permission_traits;

  const allowed_permission_optional&
  allowed_permission () const;

  allowed_permission_optional&
  allowed_permission ();

  void
  allowed_permission (const allowed_permission_type& x);

  void
  allowed_permission (const allowed_permission_optional& x);

  // Constructors.
  //
  begin_req_event_type (const destination_address_type&,
                        const originating_address_type&);

  begin_req_event_type (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::type* c = 0);

  begin_req_event_type (const begin_req_event_type& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::type* c = 0);

  virtual begin_req_event_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::type* c = 0) const;

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  private:
  dialogue_portion_optional dialogue_portion_;
  component_req_event_sequence component_req_event_;
  ::xsd::cxx::tree::one< destination_address_type > destination_address_;
  ::xsd::cxx::tree::one< originating_address_type > originating_address_;
  dialogue_id_optional dialogue_id_;
  quality_of_service_optional quality_of_service_;
  allowed_permission_optional allowed_permission_;
};

class notice_ind_event_type: public ::xml_schema::type
{
  public:
  // dialogue-portion
  // 
  typedef ::dialogue_portion_type dialogue_portion_type;
  typedef ::xsd::cxx::tree::optional< dialogue_portion_type > dialogue_portion_optional;
  typedef ::xsd::cxx::tree::traits< dialogue_portion_type, char > dialogue_portion_traits;

  const dialogue_portion_optional&
  dialogue_portion () const;

  dialogue_portion_optional&
  dialogue_portion ();

  void
  dialogue_portion (const dialogue_portion_type& x);

  void
  dialogue_portion (const dialogue_portion_optional& x);

  void
  dialogue_portion (::std::auto_ptr< dialogue_portion_type > p);

  // component-ind-event
  // 
  typedef ::component_ind_event_type component_ind_event_type;
  typedef ::xsd::cxx::tree::sequence< component_ind_event_type > component_ind_event_sequence;
  typedef component_ind_event_sequence::iterator component_ind_event_iterator;
  typedef component_ind_event_sequence::const_iterator component_ind_event_const_iterator;
  typedef ::xsd::cxx::tree::traits< component_ind_event_type, char > component_ind_event_traits;

  const component_ind_event_sequence&
  component_ind_event () const;

  component_ind_event_sequence&
  component_ind_event ();

  void
  component_ind_event (const component_ind_event_sequence& s);

  // destination-address
  // 
  typedef ::sccp_user_address_type destination_address_type;
  typedef ::xsd::cxx::tree::optional< destination_address_type > destination_address_optional;
  typedef ::xsd::cxx::tree::traits< destination_address_type, char > destination_address_traits;

  const destination_address_optional&
  destination_address () const;

  destination_address_optional&
  destination_address ();

  void
  destination_address (const destination_address_type& x);

  void
  destination_address (const destination_address_optional& x);

  void
  destination_address (::std::auto_ptr< destination_address_type > p);

  // originating-address
  // 
  typedef ::sccp_user_address_type originating_address_type;
  typedef ::xsd::cxx::tree::optional< originating_address_type > originating_address_optional;
  typedef ::xsd::cxx::tree::traits< originating_address_type, char > originating_address_traits;

  const originating_address_optional&
  originating_address () const;

  originating_address_optional&
  originating_address ();

  void
  originating_address (const originating_address_type& x);

  void
  originating_address (const originating_address_optional& x);

  void
  originating_address (::std::auto_ptr< originating_address_type > p);

  // report-cause
  // 
  typedef ::xml_schema::hex_binary report_cause_type;
  typedef ::xsd::cxx::tree::traits< report_cause_type, char > report_cause_traits;

  const report_cause_type&
  report_cause () const;

  report_cause_type&
  report_cause ();

  void
  report_cause (const report_cause_type& x);

  void
  report_cause (::std::auto_ptr< report_cause_type > p);

  // dialogue-id
  // 
  typedef ::xml_schema::integer dialogue_id_type;
  typedef ::xsd::cxx::tree::optional< dialogue_id_type > dialogue_id_optional;
  typedef ::xsd::cxx::tree::traits< dialogue_id_type, char > dialogue_id_traits;

  const dialogue_id_optional&
  dialogue_id () const;

  dialogue_id_optional&
  dialogue_id ();

  void
  dialogue_id (const dialogue_id_type& x);

  void
  dialogue_id (const dialogue_id_optional& x);

  // Constructors.
  //
  notice_ind_event_type (const report_cause_type&);

  notice_ind_event_type (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::type* c = 0);

  notice_ind_event_type (const notice_ind_event_type& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::type* c = 0);

  virtual notice_ind_event_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::type* c = 0) const;

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  private:
  dialogue_portion_optional dialogue_portion_;
  component_ind_event_sequence component_ind_event_;
  destination_address_optional destination_address_;
  originating_address_optional originating_address_;
  ::xsd::cxx::tree::one< report_cause_type > report_cause_;
  dialogue_id_optional dialogue_id_;
};

class invoke_ind_event_type: public ::xml_schema::type
{
  public:
  // operation
  // 
  typedef ::operation_type_def operation_type;
  typedef ::xsd::cxx::tree::traits< operation_type, char > operation_traits;

  const operation_type&
  operation () const;

  operation_type&
  operation ();

  void
  operation (const operation_type& x);

  void
  operation (::std::auto_ptr< operation_type > p);

  // parameters
  // 
  typedef ::parameters_type parameters_type;
  typedef ::xsd::cxx::tree::optional< parameters_type > parameters_optional;
  typedef ::xsd::cxx::tree::traits< parameters_type, char > parameters_traits;

  const parameters_optional&
  parameters () const;

  parameters_optional&
  parameters ();

  void
  parameters (const parameters_type& x);

  void
  parameters (const parameters_optional& x);

  void
  parameters (::std::auto_ptr< parameters_type > p);

  // dialogue-id
  // 
  typedef ::xml_schema::integer dialogue_id_type;
  typedef ::xsd::cxx::tree::optional< dialogue_id_type > dialogue_id_optional;
  typedef ::xsd::cxx::tree::traits< dialogue_id_type, char > dialogue_id_traits;

  const dialogue_id_optional&
  dialogue_id () const;

  dialogue_id_optional&
  dialogue_id ();

  void
  dialogue_id (const dialogue_id_type& x);

  void
  dialogue_id (const dialogue_id_optional& x);

  // invoke-id
  // 
  typedef ::xml_schema::integer invoke_id_type;
  typedef ::xsd::cxx::tree::optional< invoke_id_type > invoke_id_optional;
  typedef ::xsd::cxx::tree::traits< invoke_id_type, char > invoke_id_traits;

  const invoke_id_optional&
  invoke_id () const;

  invoke_id_optional&
  invoke_id ();

  void
  invoke_id (const invoke_id_type& x);

  void
  invoke_id (const invoke_id_optional& x);

  // last-component
  // 
  typedef ::xml_schema::boolean last_component_type;
  typedef ::xsd::cxx::tree::optional< last_component_type > last_component_optional;
  typedef ::xsd::cxx::tree::traits< last_component_type, char > last_component_traits;

  const last_component_optional&
  last_component () const;

  last_component_optional&
  last_component ();

  void
  last_component (const last_component_type& x);

  void
  last_component (const last_component_optional& x);

  // linked-id
  // 
  typedef ::xml_schema::integer linked_id_type;
  typedef ::xsd::cxx::tree::optional< linked_id_type > linked_id_optional;
  typedef ::xsd::cxx::tree::traits< linked_id_type, char > linked_id_traits;

  const linked_id_optional&
  linked_id () const;

  linked_id_optional&
  linked_id ();

  void
  linked_id (const linked_id_type& x);

  void
  linked_id (const linked_id_optional& x);

  // class-type
  // 
  typedef ::class_type1 class_type_type;
  typedef ::xsd::cxx::tree::optional< class_type_type > class_type_optional;
  typedef ::xsd::cxx::tree::traits< class_type_type, char > class_type_traits;

  const class_type_optional&
  class_type () const;

  class_type_optional&
  class_type ();

  void
  class_type (const class_type_type& x);

  void
  class_type (const class_type_optional& x);

  void
  class_type (::std::auto_ptr< class_type_type > p);

  // last-invoke-event
  // 
  typedef ::xml_schema::boolean last_invoke_event_type;
  typedef ::xsd::cxx::tree::optional< last_invoke_event_type > last_invoke_event_optional;
  typedef ::xsd::cxx::tree::traits< last_invoke_event_type, char > last_invoke_event_traits;

  const last_invoke_event_optional&
  last_invoke_event () const;

  last_invoke_event_optional&
  last_invoke_event ();

  void
  last_invoke_event (const last_invoke_event_type& x);

  void
  last_invoke_event (const last_invoke_event_optional& x);

  // Constructors.
  //
  invoke_ind_event_type (const operation_type&);

  invoke_ind_event_type (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::type* c = 0);

  invoke_ind_event_type (const invoke_ind_event_type& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::type* c = 0);

  virtual invoke_ind_event_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::type* c = 0) const;

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  private:
  ::xsd::cxx::tree::one< operation_type > operation_;
  parameters_optional parameters_;
  dialogue_id_optional dialogue_id_;
  invoke_id_optional invoke_id_;
  last_component_optional last_component_;
  linked_id_optional linked_id_;
  class_type_optional class_type_;
  last_invoke_event_optional last_invoke_event_;
};

class result_ind_event_type: public ::xml_schema::type
{
  public:
  // operation
  // 
  typedef ::operation_type_def operation_type;
  typedef ::xsd::cxx::tree::optional< operation_type > operation_optional;
  typedef ::xsd::cxx::tree::traits< operation_type, char > operation_traits;

  const operation_optional&
  operation () const;

  operation_optional&
  operation ();

  void
  operation (const operation_type& x);

  void
  operation (const operation_optional& x);

  void
  operation (::std::auto_ptr< operation_type > p);

  // parameters
  // 
  typedef ::parameters_type parameters_type;
  typedef ::xsd::cxx::tree::optional< parameters_type > parameters_optional;
  typedef ::xsd::cxx::tree::traits< parameters_type, char > parameters_traits;

  const parameters_optional&
  parameters () const;

  parameters_optional&
  parameters ();

  void
  parameters (const parameters_type& x);

  void
  parameters (const parameters_optional& x);

  void
  parameters (::std::auto_ptr< parameters_type > p);

  // dialogue-id
  // 
  typedef ::xml_schema::integer dialogue_id_type;
  typedef ::xsd::cxx::tree::optional< dialogue_id_type > dialogue_id_optional;
  typedef ::xsd::cxx::tree::traits< dialogue_id_type, char > dialogue_id_traits;

  const dialogue_id_optional&
  dialogue_id () const;

  dialogue_id_optional&
  dialogue_id ();

  void
  dialogue_id (const dialogue_id_type& x);

  void
  dialogue_id (const dialogue_id_optional& x);

  // invoke-id
  // 
  typedef ::xml_schema::integer invoke_id_type;
  typedef ::xsd::cxx::tree::optional< invoke_id_type > invoke_id_optional;
  typedef ::xsd::cxx::tree::traits< invoke_id_type, char > invoke_id_traits;

  const invoke_id_optional&
  invoke_id () const;

  invoke_id_optional&
  invoke_id ();

  void
  invoke_id (const invoke_id_type& x);

  void
  invoke_id (const invoke_id_optional& x);

  // last-component
  // 
  typedef ::xml_schema::boolean last_component_type;
  typedef ::xsd::cxx::tree::optional< last_component_type > last_component_optional;
  typedef ::xsd::cxx::tree::traits< last_component_type, char > last_component_traits;

  const last_component_optional&
  last_component () const;

  last_component_optional&
  last_component ();

  void
  last_component (const last_component_type& x);

  void
  last_component (const last_component_optional& x);

  // link-id
  // 
  typedef ::xml_schema::integer link_id_type;
  typedef ::xsd::cxx::tree::optional< link_id_type > link_id_optional;
  typedef ::xsd::cxx::tree::traits< link_id_type, char > link_id_traits;

  const link_id_optional&
  link_id () const;

  link_id_optional&
  link_id ();

  void
  link_id (const link_id_type& x);

  void
  link_id (const link_id_optional& x);

  // last-result-event
  // 
  typedef ::xml_schema::boolean last_result_event_type;
  typedef ::xsd::cxx::tree::traits< last_result_event_type, char > last_result_event_traits;

  const last_result_event_type&
  last_result_event () const;

  last_result_event_type&
  last_result_event ();

  void
  last_result_event (const last_result_event_type& x);

  // Constructors.
  //
  result_ind_event_type (const last_result_event_type&);

  result_ind_event_type (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::type* c = 0);

  result_ind_event_type (const result_ind_event_type& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::type* c = 0);

  virtual result_ind_event_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::type* c = 0) const;

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  private:
  operation_optional operation_;
  parameters_optional parameters_;
  dialogue_id_optional dialogue_id_;
  invoke_id_optional invoke_id_;
  last_component_optional last_component_;
  link_id_optional link_id_;
  ::xsd::cxx::tree::one< last_result_event_type > last_result_event_;
};

class end_req_event_type: public ::xml_schema::type
{
  public:
  // dialogue-portion
  // 
  typedef ::dialogue_portion_type dialogue_portion_type;
  typedef ::xsd::cxx::tree::optional< dialogue_portion_type > dialogue_portion_optional;
  typedef ::xsd::cxx::tree::traits< dialogue_portion_type, char > dialogue_portion_traits;

  const dialogue_portion_optional&
  dialogue_portion () const;

  dialogue_portion_optional&
  dialogue_portion ();

  void
  dialogue_portion (const dialogue_portion_type& x);

  void
  dialogue_portion (const dialogue_portion_optional& x);

  void
  dialogue_portion (::std::auto_ptr< dialogue_portion_type > p);

  // component-req-event
  // 
  typedef ::component_req_event_type component_req_event_type;
  typedef ::xsd::cxx::tree::sequence< component_req_event_type > component_req_event_sequence;
  typedef component_req_event_sequence::iterator component_req_event_iterator;
  typedef component_req_event_sequence::const_iterator component_req_event_const_iterator;
  typedef ::xsd::cxx::tree::traits< component_req_event_type, char > component_req_event_traits;

  const component_req_event_sequence&
  component_req_event () const;

  component_req_event_sequence&
  component_req_event ();

  void
  component_req_event (const component_req_event_sequence& s);

  // dialogue-id
  // 
  typedef ::xml_schema::integer dialogue_id_type;
  typedef ::xsd::cxx::tree::optional< dialogue_id_type > dialogue_id_optional;
  typedef ::xsd::cxx::tree::traits< dialogue_id_type, char > dialogue_id_traits;

  const dialogue_id_optional&
  dialogue_id () const;

  dialogue_id_optional&
  dialogue_id ();

  void
  dialogue_id (const dialogue_id_type& x);

  void
  dialogue_id (const dialogue_id_optional& x);

  // quality-of-service
  // 
  typedef ::xml_schema::byte quality_of_service_type;
  typedef ::xsd::cxx::tree::optional< quality_of_service_type > quality_of_service_optional;
  typedef ::xsd::cxx::tree::traits< quality_of_service_type, char > quality_of_service_traits;

  const quality_of_service_optional&
  quality_of_service () const;

  quality_of_service_optional&
  quality_of_service ();

  void
  quality_of_service (const quality_of_service_type& x);

  void
  quality_of_service (const quality_of_service_optional& x);

  // termination
  // 
  typedef ::termination termination_type;
  typedef ::xsd::cxx::tree::optional< termination_type > termination_optional;
  typedef ::xsd::cxx::tree::traits< termination_type, char > termination_traits;

  const termination_optional&
  termination () const;

  termination_optional&
  termination ();

  void
  termination (const termination_type& x);

  void
  termination (const termination_optional& x);

  void
  termination (::std::auto_ptr< termination_type > p);

  // Constructors.
  //
  end_req_event_type ();

  end_req_event_type (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::type* c = 0);

  end_req_event_type (const end_req_event_type& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::type* c = 0);

  virtual end_req_event_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::type* c = 0) const;

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  private:
  dialogue_portion_optional dialogue_portion_;
  component_req_event_sequence component_req_event_;
  dialogue_id_optional dialogue_id_;
  quality_of_service_optional quality_of_service_;
  termination_optional termination_;
};

class result_req_event_type: public ::xml_schema::type
{
  public:
  // operation
  // 
  typedef ::operation_type_def operation_type;
  typedef ::xsd::cxx::tree::optional< operation_type > operation_optional;
  typedef ::xsd::cxx::tree::traits< operation_type, char > operation_traits;

  const operation_optional&
  operation () const;

  operation_optional&
  operation ();

  void
  operation (const operation_type& x);

  void
  operation (const operation_optional& x);

  void
  operation (::std::auto_ptr< operation_type > p);

  // parameters
  // 
  typedef ::parameters_type parameters_type;
  typedef ::xsd::cxx::tree::optional< parameters_type > parameters_optional;
  typedef ::xsd::cxx::tree::traits< parameters_type, char > parameters_traits;

  const parameters_optional&
  parameters () const;

  parameters_optional&
  parameters ();

  void
  parameters (const parameters_type& x);

  void
  parameters (const parameters_optional& x);

  void
  parameters (::std::auto_ptr< parameters_type > p);

  // dialogue-id
  // 
  typedef ::xml_schema::integer dialogue_id_type;
  typedef ::xsd::cxx::tree::optional< dialogue_id_type > dialogue_id_optional;
  typedef ::xsd::cxx::tree::traits< dialogue_id_type, char > dialogue_id_traits;

  const dialogue_id_optional&
  dialogue_id () const;

  dialogue_id_optional&
  dialogue_id ();

  void
  dialogue_id (const dialogue_id_type& x);

  void
  dialogue_id (const dialogue_id_optional& x);

  // invoke-id
  // 
  typedef ::xml_schema::integer invoke_id_type;
  typedef ::xsd::cxx::tree::optional< invoke_id_type > invoke_id_optional;
  typedef ::xsd::cxx::tree::traits< invoke_id_type, char > invoke_id_traits;

  const invoke_id_optional&
  invoke_id () const;

  invoke_id_optional&
  invoke_id ();

  void
  invoke_id (const invoke_id_type& x);

  void
  invoke_id (const invoke_id_optional& x);

  // link-id
  // 
  typedef ::xml_schema::integer link_id_type;
  typedef ::xsd::cxx::tree::optional< link_id_type > link_id_optional;
  typedef ::xsd::cxx::tree::traits< link_id_type, char > link_id_traits;

  const link_id_optional&
  link_id () const;

  link_id_optional&
  link_id ();

  void
  link_id (const link_id_type& x);

  void
  link_id (const link_id_optional& x);

  // last-result-event
  // 
  typedef ::xml_schema::boolean last_result_event_type;
  typedef ::xsd::cxx::tree::traits< last_result_event_type, char > last_result_event_traits;

  const last_result_event_type&
  last_result_event () const;

  last_result_event_type&
  last_result_event ();

  void
  last_result_event (const last_result_event_type& x);

  // Constructors.
  //
  result_req_event_type (const last_result_event_type&);

  result_req_event_type (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::type* c = 0);

  result_req_event_type (const result_req_event_type& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::type* c = 0);

  virtual result_req_event_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::type* c = 0) const;

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  private:
  operation_optional operation_;
  parameters_optional parameters_;
  dialogue_id_optional dialogue_id_;
  invoke_id_optional invoke_id_;
  link_id_optional link_id_;
  ::xsd::cxx::tree::one< last_result_event_type > last_result_event_;
};

class sccp_user_address_type: public ::xml_schema::type
{
  public:
  // sub-system-address
  // 
  typedef ::sub_system_address_type sub_system_address_type;
  typedef ::xsd::cxx::tree::optional< sub_system_address_type > sub_system_address_optional;
  typedef ::xsd::cxx::tree::traits< sub_system_address_type, char > sub_system_address_traits;

  const sub_system_address_optional&
  sub_system_address () const;

  sub_system_address_optional&
  sub_system_address ();

  void
  sub_system_address (const sub_system_address_type& x);

  void
  sub_system_address (const sub_system_address_optional& x);

  void
  sub_system_address (::std::auto_ptr< sub_system_address_type > p);

  // global-title
  // 
  typedef ::global_title_type global_title_type;
  typedef ::xsd::cxx::tree::optional< global_title_type > global_title_optional;
  typedef ::xsd::cxx::tree::traits< global_title_type, char > global_title_traits;

  const global_title_optional&
  global_title () const;

  global_title_optional&
  global_title ();

  void
  global_title (const global_title_type& x);

  void
  global_title (const global_title_optional& x);

  void
  global_title (::std::auto_ptr< global_title_type > p);

  // routing-indicator
  // 
  typedef ::routing_indicator routing_indicator_type;
  typedef ::xsd::cxx::tree::traits< routing_indicator_type, char > routing_indicator_traits;

  const routing_indicator_type&
  routing_indicator () const;

  routing_indicator_type&
  routing_indicator ();

  void
  routing_indicator (const routing_indicator_type& x);

  void
  routing_indicator (::std::auto_ptr< routing_indicator_type > p);

  // national-use
  // 
  typedef ::xml_schema::boolean national_use_type;
  typedef ::xsd::cxx::tree::optional< national_use_type > national_use_optional;
  typedef ::xsd::cxx::tree::traits< national_use_type, char > national_use_traits;

  const national_use_optional&
  national_use () const;

  national_use_optional&
  national_use ();

  void
  national_use (const national_use_type& x);

  void
  national_use (const national_use_optional& x);

  // Constructors.
  //
  sccp_user_address_type (const routing_indicator_type&);

  sccp_user_address_type (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::type* c = 0);

  sccp_user_address_type (const sccp_user_address_type& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::type* c = 0);

  virtual sccp_user_address_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::type* c = 0) const;

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  private:
  sub_system_address_optional sub_system_address_;
  global_title_optional global_title_;
  ::xsd::cxx::tree::one< routing_indicator_type > routing_indicator_;
  national_use_optional national_use_;
};

class parameters_type: public ::xml_schema::type
{
  public:
  // parameter
  // 
  typedef ::xml_schema::hex_binary parameter_type;
  typedef ::xsd::cxx::tree::traits< parameter_type, char > parameter_traits;

  const parameter_type&
  parameter () const;

  parameter_type&
  parameter ();

  void
  parameter (const parameter_type& x);

  void
  parameter (::std::auto_ptr< parameter_type > p);

  // parameter-identifier
  // 
  typedef ::parameter_identifier parameter_identifier_type;
  typedef ::xsd::cxx::tree::traits< parameter_identifier_type, char > parameter_identifier_traits;

  const parameter_identifier_type&
  parameter_identifier () const;

  parameter_identifier_type&
  parameter_identifier ();

  void
  parameter_identifier (const parameter_identifier_type& x);

  void
  parameter_identifier (::std::auto_ptr< parameter_identifier_type > p);

  // Constructors.
  //
  parameters_type (const parameter_type&,
                   const parameter_identifier_type&);

  parameters_type (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::type* c = 0);

  parameters_type (const parameters_type& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::type* c = 0);

  virtual parameters_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::type* c = 0) const;

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  private:
  ::xsd::cxx::tree::one< parameter_type > parameter_;
  ::xsd::cxx::tree::one< parameter_identifier_type > parameter_identifier_;
};

class state_req_event_type: public ::xml_schema::type
{
  public:
  // nstate-req-event
  // 
  typedef ::nstate_req_event_type nstate_req_event_type;
  typedef ::xsd::cxx::tree::traits< nstate_req_event_type, char > nstate_req_event_traits;

  const nstate_req_event_type&
  nstate_req_event () const;

  nstate_req_event_type&
  nstate_req_event ();

  void
  nstate_req_event (const nstate_req_event_type& x);

  void
  nstate_req_event (::std::auto_ptr< nstate_req_event_type > p);

  // Constructors.
  //
  state_req_event_type (const nstate_req_event_type&);

  state_req_event_type (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::type* c = 0);

  state_req_event_type (const state_req_event_type& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::type* c = 0);

  virtual state_req_event_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::type* c = 0) const;

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  private:
  ::xsd::cxx::tree::one< nstate_req_event_type > nstate_req_event_;
};

class dialogue_ind_event_type: public ::xml_schema::type
{
  public:
  // user-abort-ind-event
  // 
  typedef ::user_abort_ind_event_type user_abort_ind_event_type;
  typedef ::xsd::cxx::tree::optional< user_abort_ind_event_type > user_abort_ind_event_optional;
  typedef ::xsd::cxx::tree::traits< user_abort_ind_event_type, char > user_abort_ind_event_traits;

  const user_abort_ind_event_optional&
  user_abort_ind_event () const;

  user_abort_ind_event_optional&
  user_abort_ind_event ();

  void
  user_abort_ind_event (const user_abort_ind_event_type& x);

  void
  user_abort_ind_event (const user_abort_ind_event_optional& x);

  void
  user_abort_ind_event (::std::auto_ptr< user_abort_ind_event_type > p);

  // end-ind-event
  // 
  typedef ::end_ind_event_type end_ind_event_type;
  typedef ::xsd::cxx::tree::optional< end_ind_event_type > end_ind_event_optional;
  typedef ::xsd::cxx::tree::traits< end_ind_event_type, char > end_ind_event_traits;

  const end_ind_event_optional&
  end_ind_event () const;

  end_ind_event_optional&
  end_ind_event ();

  void
  end_ind_event (const end_ind_event_type& x);

  void
  end_ind_event (const end_ind_event_optional& x);

  void
  end_ind_event (::std::auto_ptr< end_ind_event_type > p);

  // provider-abort-ind-event
  // 
  typedef ::provider_abort_ind_event_type provider_abort_ind_event_type;
  typedef ::xsd::cxx::tree::optional< provider_abort_ind_event_type > provider_abort_ind_event_optional;
  typedef ::xsd::cxx::tree::traits< provider_abort_ind_event_type, char > provider_abort_ind_event_traits;

  const provider_abort_ind_event_optional&
  provider_abort_ind_event () const;

  provider_abort_ind_event_optional&
  provider_abort_ind_event ();

  void
  provider_abort_ind_event (const provider_abort_ind_event_type& x);

  void
  provider_abort_ind_event (const provider_abort_ind_event_optional& x);

  void
  provider_abort_ind_event (::std::auto_ptr< provider_abort_ind_event_type > p);

  // begin-ind-event
  // 
  typedef ::begin_ind_event_type begin_ind_event_type;
  typedef ::xsd::cxx::tree::optional< begin_ind_event_type > begin_ind_event_optional;
  typedef ::xsd::cxx::tree::traits< begin_ind_event_type, char > begin_ind_event_traits;

  const begin_ind_event_optional&
  begin_ind_event () const;

  begin_ind_event_optional&
  begin_ind_event ();

  void
  begin_ind_event (const begin_ind_event_type& x);

  void
  begin_ind_event (const begin_ind_event_optional& x);

  void
  begin_ind_event (::std::auto_ptr< begin_ind_event_type > p);

  // unidirectional-ind-event
  // 
  typedef ::unidirectional_ind_event_type unidirectional_ind_event_type;
  typedef ::xsd::cxx::tree::optional< unidirectional_ind_event_type > unidirectional_ind_event_optional;
  typedef ::xsd::cxx::tree::traits< unidirectional_ind_event_type, char > unidirectional_ind_event_traits;

  const unidirectional_ind_event_optional&
  unidirectional_ind_event () const;

  unidirectional_ind_event_optional&
  unidirectional_ind_event ();

  void
  unidirectional_ind_event (const unidirectional_ind_event_type& x);

  void
  unidirectional_ind_event (const unidirectional_ind_event_optional& x);

  void
  unidirectional_ind_event (::std::auto_ptr< unidirectional_ind_event_type > p);

  // continue-ind-event
  // 
  typedef ::continue_ind_event_type continue_ind_event_type;
  typedef ::xsd::cxx::tree::optional< continue_ind_event_type > continue_ind_event_optional;
  typedef ::xsd::cxx::tree::traits< continue_ind_event_type, char > continue_ind_event_traits;

  const continue_ind_event_optional&
  continue_ind_event () const;

  continue_ind_event_optional&
  continue_ind_event ();

  void
  continue_ind_event (const continue_ind_event_type& x);

  void
  continue_ind_event (const continue_ind_event_optional& x);

  void
  continue_ind_event (::std::auto_ptr< continue_ind_event_type > p);

  // notice-ind-event
  // 
  typedef ::notice_ind_event_type notice_ind_event_type;
  typedef ::xsd::cxx::tree::optional< notice_ind_event_type > notice_ind_event_optional;
  typedef ::xsd::cxx::tree::traits< notice_ind_event_type, char > notice_ind_event_traits;

  const notice_ind_event_optional&
  notice_ind_event () const;

  notice_ind_event_optional&
  notice_ind_event ();

  void
  notice_ind_event (const notice_ind_event_type& x);

  void
  notice_ind_event (const notice_ind_event_optional& x);

  void
  notice_ind_event (::std::auto_ptr< notice_ind_event_type > p);

  // Constructors.
  //
  dialogue_ind_event_type ();

  dialogue_ind_event_type (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::type* c = 0);

  dialogue_ind_event_type (const dialogue_ind_event_type& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::type* c = 0);

  virtual dialogue_ind_event_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::type* c = 0) const;

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  private:
  user_abort_ind_event_optional user_abort_ind_event_;
  end_ind_event_optional end_ind_event_;
  provider_abort_ind_event_optional provider_abort_ind_event_;
  begin_ind_event_optional begin_ind_event_;
  unidirectional_ind_event_optional unidirectional_ind_event_;
  continue_ind_event_optional continue_ind_event_;
  notice_ind_event_optional notice_ind_event_;
};

class component_ind_event_type: public ::xml_schema::type
{
  public:
  // error-ind-event
  // 
  typedef ::error_ind_event_type error_ind_event_type;
  typedef ::xsd::cxx::tree::optional< error_ind_event_type > error_ind_event_optional;
  typedef ::xsd::cxx::tree::traits< error_ind_event_type, char > error_ind_event_traits;

  const error_ind_event_optional&
  error_ind_event () const;

  error_ind_event_optional&
  error_ind_event ();

  void
  error_ind_event (const error_ind_event_type& x);

  void
  error_ind_event (const error_ind_event_optional& x);

  void
  error_ind_event (::std::auto_ptr< error_ind_event_type > p);

  // reject-ind-event
  // 
  typedef ::reject_ind_event_type reject_ind_event_type;
  typedef ::xsd::cxx::tree::optional< reject_ind_event_type > reject_ind_event_optional;
  typedef ::xsd::cxx::tree::traits< reject_ind_event_type, char > reject_ind_event_traits;

  const reject_ind_event_optional&
  reject_ind_event () const;

  reject_ind_event_optional&
  reject_ind_event ();

  void
  reject_ind_event (const reject_ind_event_type& x);

  void
  reject_ind_event (const reject_ind_event_optional& x);

  void
  reject_ind_event (::std::auto_ptr< reject_ind_event_type > p);

  // local-cancel-ind-event
  // 
  typedef ::local_cancel_ind_event_type local_cancel_ind_event_type;
  typedef ::xsd::cxx::tree::optional< local_cancel_ind_event_type > local_cancel_ind_event_optional;
  typedef ::xsd::cxx::tree::traits< local_cancel_ind_event_type, char > local_cancel_ind_event_traits;

  const local_cancel_ind_event_optional&
  local_cancel_ind_event () const;

  local_cancel_ind_event_optional&
  local_cancel_ind_event ();

  void
  local_cancel_ind_event (const local_cancel_ind_event_type& x);

  void
  local_cancel_ind_event (const local_cancel_ind_event_optional& x);

  void
  local_cancel_ind_event (::std::auto_ptr< local_cancel_ind_event_type > p);

  // invoke-ind-event
  // 
  typedef ::invoke_ind_event_type invoke_ind_event_type;
  typedef ::xsd::cxx::tree::optional< invoke_ind_event_type > invoke_ind_event_optional;
  typedef ::xsd::cxx::tree::traits< invoke_ind_event_type, char > invoke_ind_event_traits;

  const invoke_ind_event_optional&
  invoke_ind_event () const;

  invoke_ind_event_optional&
  invoke_ind_event ();

  void
  invoke_ind_event (const invoke_ind_event_type& x);

  void
  invoke_ind_event (const invoke_ind_event_optional& x);

  void
  invoke_ind_event (::std::auto_ptr< invoke_ind_event_type > p);

  // result-ind-event
  // 
  typedef ::result_ind_event_type result_ind_event_type;
  typedef ::xsd::cxx::tree::optional< result_ind_event_type > result_ind_event_optional;
  typedef ::xsd::cxx::tree::traits< result_ind_event_type, char > result_ind_event_traits;

  const result_ind_event_optional&
  result_ind_event () const;

  result_ind_event_optional&
  result_ind_event ();

  void
  result_ind_event (const result_ind_event_type& x);

  void
  result_ind_event (const result_ind_event_optional& x);

  void
  result_ind_event (::std::auto_ptr< result_ind_event_type > p);

  // Constructors.
  //
  component_ind_event_type ();

  component_ind_event_type (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::type* c = 0);

  component_ind_event_type (const component_ind_event_type& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::type* c = 0);

  virtual component_ind_event_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::type* c = 0) const;

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  private:
  error_ind_event_optional error_ind_event_;
  reject_ind_event_optional reject_ind_event_;
  local_cancel_ind_event_optional local_cancel_ind_event_;
  invoke_ind_event_optional invoke_ind_event_;
  result_ind_event_optional result_ind_event_;
};

class state_ind_event_type: public ::xml_schema::type
{
  public:
  // nstate-ind-event
  // 
  typedef ::nstate_ind_event_type nstate_ind_event_type;
  typedef ::xsd::cxx::tree::optional< nstate_ind_event_type > nstate_ind_event_optional;
  typedef ::xsd::cxx::tree::traits< nstate_ind_event_type, char > nstate_ind_event_traits;

  const nstate_ind_event_optional&
  nstate_ind_event () const;

  nstate_ind_event_optional&
  nstate_ind_event ();

  void
  nstate_ind_event (const nstate_ind_event_type& x);

  void
  nstate_ind_event (const nstate_ind_event_optional& x);

  void
  nstate_ind_event (::std::auto_ptr< nstate_ind_event_type > p);

  // npcstate-ind-event
  // 
  typedef ::npcstate_ind_event_type npcstate_ind_event_type;
  typedef ::xsd::cxx::tree::optional< npcstate_ind_event_type > npcstate_ind_event_optional;
  typedef ::xsd::cxx::tree::traits< npcstate_ind_event_type, char > npcstate_ind_event_traits;

  const npcstate_ind_event_optional&
  npcstate_ind_event () const;

  npcstate_ind_event_optional&
  npcstate_ind_event ();

  void
  npcstate_ind_event (const npcstate_ind_event_type& x);

  void
  npcstate_ind_event (const npcstate_ind_event_optional& x);

  void
  npcstate_ind_event (::std::auto_ptr< npcstate_ind_event_type > p);

  // Constructors.
  //
  state_ind_event_type ();

  state_ind_event_type (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::type* c = 0);

  state_ind_event_type (const state_ind_event_type& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::type* c = 0);

  virtual state_ind_event_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::type* c = 0) const;

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  private:
  nstate_ind_event_optional nstate_ind_event_;
  npcstate_ind_event_optional npcstate_ind_event_;
};

class dialogue_req_event_type: public ::xml_schema::type
{
  public:
  // user-abort-req-event
  // 
  typedef ::user_abort_req_event_type user_abort_req_event_type;
  typedef ::xsd::cxx::tree::optional< user_abort_req_event_type > user_abort_req_event_optional;
  typedef ::xsd::cxx::tree::traits< user_abort_req_event_type, char > user_abort_req_event_traits;

  const user_abort_req_event_optional&
  user_abort_req_event () const;

  user_abort_req_event_optional&
  user_abort_req_event ();

  void
  user_abort_req_event (const user_abort_req_event_type& x);

  void
  user_abort_req_event (const user_abort_req_event_optional& x);

  void
  user_abort_req_event (::std::auto_ptr< user_abort_req_event_type > p);

  // unidirectional-req-event
  // 
  typedef ::unidirectional_req_event_type unidirectional_req_event_type;
  typedef ::xsd::cxx::tree::optional< unidirectional_req_event_type > unidirectional_req_event_optional;
  typedef ::xsd::cxx::tree::traits< unidirectional_req_event_type, char > unidirectional_req_event_traits;

  const unidirectional_req_event_optional&
  unidirectional_req_event () const;

  unidirectional_req_event_optional&
  unidirectional_req_event ();

  void
  unidirectional_req_event (const unidirectional_req_event_type& x);

  void
  unidirectional_req_event (const unidirectional_req_event_optional& x);

  void
  unidirectional_req_event (::std::auto_ptr< unidirectional_req_event_type > p);

  // continue-req-event
  // 
  typedef ::continue_req_event_type continue_req_event_type;
  typedef ::xsd::cxx::tree::optional< continue_req_event_type > continue_req_event_optional;
  typedef ::xsd::cxx::tree::traits< continue_req_event_type, char > continue_req_event_traits;

  const continue_req_event_optional&
  continue_req_event () const;

  continue_req_event_optional&
  continue_req_event ();

  void
  continue_req_event (const continue_req_event_type& x);

  void
  continue_req_event (const continue_req_event_optional& x);

  void
  continue_req_event (::std::auto_ptr< continue_req_event_type > p);

  // begin-req-event
  // 
  typedef ::begin_req_event_type begin_req_event_type;
  typedef ::xsd::cxx::tree::optional< begin_req_event_type > begin_req_event_optional;
  typedef ::xsd::cxx::tree::traits< begin_req_event_type, char > begin_req_event_traits;

  const begin_req_event_optional&
  begin_req_event () const;

  begin_req_event_optional&
  begin_req_event ();

  void
  begin_req_event (const begin_req_event_type& x);

  void
  begin_req_event (const begin_req_event_optional& x);

  void
  begin_req_event (::std::auto_ptr< begin_req_event_type > p);

  // end-req-event
  // 
  typedef ::end_req_event_type end_req_event_type;
  typedef ::xsd::cxx::tree::optional< end_req_event_type > end_req_event_optional;
  typedef ::xsd::cxx::tree::traits< end_req_event_type, char > end_req_event_traits;

  const end_req_event_optional&
  end_req_event () const;

  end_req_event_optional&
  end_req_event ();

  void
  end_req_event (const end_req_event_type& x);

  void
  end_req_event (const end_req_event_optional& x);

  void
  end_req_event (::std::auto_ptr< end_req_event_type > p);

  // Constructors.
  //
  dialogue_req_event_type ();

  dialogue_req_event_type (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::type* c = 0);

  dialogue_req_event_type (const dialogue_req_event_type& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::type* c = 0);

  virtual dialogue_req_event_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::type* c = 0) const;

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  private:
  user_abort_req_event_optional user_abort_req_event_;
  unidirectional_req_event_optional unidirectional_req_event_;
  continue_req_event_optional continue_req_event_;
  begin_req_event_optional begin_req_event_;
  end_req_event_optional end_req_event_;
};

class global_title_type: public ::xml_schema::type
{
  public:
  // gtindicator0001
  // 
  typedef ::gtindicator0001_type gtindicator0001_type;
  typedef ::xsd::cxx::tree::optional< gtindicator0001_type > gtindicator0001_optional;
  typedef ::xsd::cxx::tree::traits< gtindicator0001_type, char > gtindicator0001_traits;

  const gtindicator0001_optional&
  gtindicator0001 () const;

  gtindicator0001_optional&
  gtindicator0001 ();

  void
  gtindicator0001 (const gtindicator0001_type& x);

  void
  gtindicator0001 (const gtindicator0001_optional& x);

  void
  gtindicator0001 (::std::auto_ptr< gtindicator0001_type > p);

  // gtindicator0100
  // 
  typedef ::gtindicator0100_type gtindicator0100_type;
  typedef ::xsd::cxx::tree::optional< gtindicator0100_type > gtindicator0100_optional;
  typedef ::xsd::cxx::tree::traits< gtindicator0100_type, char > gtindicator0100_traits;

  const gtindicator0100_optional&
  gtindicator0100 () const;

  gtindicator0100_optional&
  gtindicator0100 ();

  void
  gtindicator0100 (const gtindicator0100_type& x);

  void
  gtindicator0100 (const gtindicator0100_optional& x);

  void
  gtindicator0100 (::std::auto_ptr< gtindicator0100_type > p);

  // gtindicator0011
  // 
  typedef ::gtindicator0011_type gtindicator0011_type;
  typedef ::xsd::cxx::tree::optional< gtindicator0011_type > gtindicator0011_optional;
  typedef ::xsd::cxx::tree::traits< gtindicator0011_type, char > gtindicator0011_traits;

  const gtindicator0011_optional&
  gtindicator0011 () const;

  gtindicator0011_optional&
  gtindicator0011 ();

  void
  gtindicator0011 (const gtindicator0011_type& x);

  void
  gtindicator0011 (const gtindicator0011_optional& x);

  void
  gtindicator0011 (::std::auto_ptr< gtindicator0011_type > p);

  // gtindicator0010
  // 
  typedef ::gtindicator0010_type gtindicator0010_type;
  typedef ::xsd::cxx::tree::optional< gtindicator0010_type > gtindicator0010_optional;
  typedef ::xsd::cxx::tree::traits< gtindicator0010_type, char > gtindicator0010_traits;

  const gtindicator0010_optional&
  gtindicator0010 () const;

  gtindicator0010_optional&
  gtindicator0010 ();

  void
  gtindicator0010 (const gtindicator0010_type& x);

  void
  gtindicator0010 (const gtindicator0010_optional& x);

  void
  gtindicator0010 (::std::auto_ptr< gtindicator0010_type > p);

  // Constructors.
  //
  global_title_type ();

  global_title_type (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::type* c = 0);

  global_title_type (const global_title_type& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::type* c = 0);

  virtual global_title_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::type* c = 0) const;

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  private:
  gtindicator0001_optional gtindicator0001_;
  gtindicator0100_optional gtindicator0100_;
  gtindicator0011_optional gtindicator0011_;
  gtindicator0010_optional gtindicator0010_;
};

class component_req_event_type: public ::xml_schema::type
{
  public:
  // error-req-event
  // 
  typedef ::error_req_event_type error_req_event_type;
  typedef ::xsd::cxx::tree::optional< error_req_event_type > error_req_event_optional;
  typedef ::xsd::cxx::tree::traits< error_req_event_type, char > error_req_event_traits;

  const error_req_event_optional&
  error_req_event () const;

  error_req_event_optional&
  error_req_event ();

  void
  error_req_event (const error_req_event_type& x);

  void
  error_req_event (const error_req_event_optional& x);

  void
  error_req_event (::std::auto_ptr< error_req_event_type > p);

  // timer-reset-req-event
  // 
  typedef ::timer_reset_req_event_type timer_reset_req_event_type;
  typedef ::xsd::cxx::tree::optional< timer_reset_req_event_type > timer_reset_req_event_optional;
  typedef ::xsd::cxx::tree::traits< timer_reset_req_event_type, char > timer_reset_req_event_traits;

  const timer_reset_req_event_optional&
  timer_reset_req_event () const;

  timer_reset_req_event_optional&
  timer_reset_req_event ();

  void
  timer_reset_req_event (const timer_reset_req_event_type& x);

  void
  timer_reset_req_event (const timer_reset_req_event_optional& x);

  void
  timer_reset_req_event (::std::auto_ptr< timer_reset_req_event_type > p);

  // reject-req-event
  // 
  typedef ::reject_req_event_type reject_req_event_type;
  typedef ::xsd::cxx::tree::optional< reject_req_event_type > reject_req_event_optional;
  typedef ::xsd::cxx::tree::traits< reject_req_event_type, char > reject_req_event_traits;

  const reject_req_event_optional&
  reject_req_event () const;

  reject_req_event_optional&
  reject_req_event ();

  void
  reject_req_event (const reject_req_event_type& x);

  void
  reject_req_event (const reject_req_event_optional& x);

  void
  reject_req_event (::std::auto_ptr< reject_req_event_type > p);

  // user-cancel-req-event
  // 
  typedef ::user_cancel_req_event_type user_cancel_req_event_type;
  typedef ::xsd::cxx::tree::optional< user_cancel_req_event_type > user_cancel_req_event_optional;
  typedef ::xsd::cxx::tree::traits< user_cancel_req_event_type, char > user_cancel_req_event_traits;

  const user_cancel_req_event_optional&
  user_cancel_req_event () const;

  user_cancel_req_event_optional&
  user_cancel_req_event ();

  void
  user_cancel_req_event (const user_cancel_req_event_type& x);

  void
  user_cancel_req_event (const user_cancel_req_event_optional& x);

  void
  user_cancel_req_event (::std::auto_ptr< user_cancel_req_event_type > p);

  // invoke-req-event
  // 
  typedef ::invoke_req_event_type invoke_req_event_type;
  typedef ::xsd::cxx::tree::optional< invoke_req_event_type > invoke_req_event_optional;
  typedef ::xsd::cxx::tree::traits< invoke_req_event_type, char > invoke_req_event_traits;

  const invoke_req_event_optional&
  invoke_req_event () const;

  invoke_req_event_optional&
  invoke_req_event ();

  void
  invoke_req_event (const invoke_req_event_type& x);

  void
  invoke_req_event (const invoke_req_event_optional& x);

  void
  invoke_req_event (::std::auto_ptr< invoke_req_event_type > p);

  // result-req-event
  // 
  typedef ::result_req_event_type result_req_event_type;
  typedef ::xsd::cxx::tree::optional< result_req_event_type > result_req_event_optional;
  typedef ::xsd::cxx::tree::traits< result_req_event_type, char > result_req_event_traits;

  const result_req_event_optional&
  result_req_event () const;

  result_req_event_optional&
  result_req_event ();

  void
  result_req_event (const result_req_event_type& x);

  void
  result_req_event (const result_req_event_optional& x);

  void
  result_req_event (::std::auto_ptr< result_req_event_type > p);

  // Constructors.
  //
  component_req_event_type ();

  component_req_event_type (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::type* c = 0);

  component_req_event_type (const component_req_event_type& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::type* c = 0);

  virtual component_req_event_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::type* c = 0) const;

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  private:
  error_req_event_optional error_req_event_;
  timer_reset_req_event_optional timer_reset_req_event_;
  reject_req_event_optional reject_req_event_;
  user_cancel_req_event_optional user_cancel_req_event_;
  invoke_req_event_optional invoke_req_event_;
  result_req_event_optional result_req_event_;
};

class tcap_type: public ::xml_schema::type
{
  public:
  // dialogue-req-event
  // 
  typedef ::dialogue_req_event_type dialogue_req_event_type;
  typedef ::xsd::cxx::tree::optional< dialogue_req_event_type > dialogue_req_event_optional;
  typedef ::xsd::cxx::tree::traits< dialogue_req_event_type, char > dialogue_req_event_traits;

  const dialogue_req_event_optional&
  dialogue_req_event () const;

  dialogue_req_event_optional&
  dialogue_req_event ();

  void
  dialogue_req_event (const dialogue_req_event_type& x);

  void
  dialogue_req_event (const dialogue_req_event_optional& x);

  void
  dialogue_req_event (::std::auto_ptr< dialogue_req_event_type > p);

  // dialogue-ind-event
  // 
  typedef ::dialogue_ind_event_type dialogue_ind_event_type;
  typedef ::xsd::cxx::tree::optional< dialogue_ind_event_type > dialogue_ind_event_optional;
  typedef ::xsd::cxx::tree::traits< dialogue_ind_event_type, char > dialogue_ind_event_traits;

  const dialogue_ind_event_optional&
  dialogue_ind_event () const;

  dialogue_ind_event_optional&
  dialogue_ind_event ();

  void
  dialogue_ind_event (const dialogue_ind_event_type& x);

  void
  dialogue_ind_event (const dialogue_ind_event_optional& x);

  void
  dialogue_ind_event (::std::auto_ptr< dialogue_ind_event_type > p);

  // state-req-event
  // 
  typedef ::state_req_event_type state_req_event_type;
  typedef ::xsd::cxx::tree::optional< state_req_event_type > state_req_event_optional;
  typedef ::xsd::cxx::tree::traits< state_req_event_type, char > state_req_event_traits;

  const state_req_event_optional&
  state_req_event () const;

  state_req_event_optional&
  state_req_event ();

  void
  state_req_event (const state_req_event_type& x);

  void
  state_req_event (const state_req_event_optional& x);

  void
  state_req_event (::std::auto_ptr< state_req_event_type > p);

  // state-ind-event
  // 
  typedef ::state_ind_event_type state_ind_event_type;
  typedef ::xsd::cxx::tree::optional< state_ind_event_type > state_ind_event_optional;
  typedef ::xsd::cxx::tree::traits< state_ind_event_type, char > state_ind_event_traits;

  const state_ind_event_optional&
  state_ind_event () const;

  state_ind_event_optional&
  state_ind_event ();

  void
  state_ind_event (const state_ind_event_type& x);

  void
  state_ind_event (const state_ind_event_optional& x);

  void
  state_ind_event (::std::auto_ptr< state_ind_event_type > p);

  // local-cancel-ind-event
  // 
  typedef ::local_cancel_ind_event_type local_cancel_ind_event_type;
  typedef ::xsd::cxx::tree::optional< local_cancel_ind_event_type > local_cancel_ind_event_optional;
  typedef ::xsd::cxx::tree::traits< local_cancel_ind_event_type, char > local_cancel_ind_event_traits;

  const local_cancel_ind_event_optional&
  local_cancel_ind_event () const;

  local_cancel_ind_event_optional&
  local_cancel_ind_event ();

  void
  local_cancel_ind_event (const local_cancel_ind_event_type& x);

  void
  local_cancel_ind_event (const local_cancel_ind_event_optional& x);

  void
  local_cancel_ind_event (::std::auto_ptr< local_cancel_ind_event_type > p);

  // reject-ind-event
  // 
  typedef ::reject_ind_event_type reject_ind_event_type;
  typedef ::xsd::cxx::tree::optional< reject_ind_event_type > reject_ind_event_optional;
  typedef ::xsd::cxx::tree::traits< reject_ind_event_type, char > reject_ind_event_traits;

  const reject_ind_event_optional&
  reject_ind_event () const;

  reject_ind_event_optional&
  reject_ind_event ();

  void
  reject_ind_event (const reject_ind_event_type& x);

  void
  reject_ind_event (const reject_ind_event_optional& x);

  void
  reject_ind_event (::std::auto_ptr< reject_ind_event_type > p);

  // configuration
  // 
  typedef ::tcap_config_type configuration_type;
  typedef ::xsd::cxx::tree::optional< configuration_type > configuration_optional;
  typedef ::xsd::cxx::tree::traits< configuration_type, char > configuration_traits;

  const configuration_optional&
  configuration () const;

  configuration_optional&
  configuration ();

  void
  configuration (const configuration_type& x);

  void
  configuration (const configuration_optional& x);

  void
  configuration (::std::auto_ptr< configuration_type > p);

  // Constructors.
  //
  tcap_type ();

  tcap_type (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::type* c = 0);

  tcap_type (const tcap_type& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::type* c = 0);

  virtual tcap_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::type* c = 0) const;

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  private:
  dialogue_req_event_optional dialogue_req_event_;
  dialogue_ind_event_optional dialogue_ind_event_;
  state_req_event_optional state_req_event_;
  state_ind_event_optional state_ind_event_;
  local_cancel_ind_event_optional local_cancel_ind_event_;
  reject_ind_event_optional reject_ind_event_;
  configuration_optional configuration_;
};

class tcap_config_type: public ::xml_schema::type
{
  public:
  // local-user-address
  // 
  typedef ::sub_system_address_type local_user_address_type;
  typedef ::xsd::cxx::tree::sequence< local_user_address_type > local_user_address_sequence;
  typedef local_user_address_sequence::iterator local_user_address_iterator;
  typedef local_user_address_sequence::const_iterator local_user_address_const_iterator;
  typedef ::xsd::cxx::tree::traits< local_user_address_type, char > local_user_address_traits;

  const local_user_address_sequence&
  local_user_address () const;

  local_user_address_sequence&
  local_user_address ();

  void
  local_user_address (const local_user_address_sequence& s);

  // Constructors.
  //
  tcap_config_type ();

  tcap_config_type (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::type* c = 0);

  tcap_config_type (const tcap_config_type& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::type* c = 0);

  virtual tcap_config_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::type* c = 0) const;

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  private:
  local_user_address_sequence local_user_address_;
};

class error_type: public ::xml_schema::nmtoken
{
  public:
  enum value
  {
    ERROR_LOCAL,
    ERROR_GLOBAL
  };

  error_type (value v);

  error_type (const ::xml_schema::nmtoken& v);

  error_type (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::type* c = 0);

  error_type (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f = 0,
              ::xml_schema::type* c = 0);

  error_type (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f = 0,
              ::xml_schema::type* c = 0);

  error_type (const error_type& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::type* c = 0);

  virtual error_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::type* c = 0) const;

  error_type&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_error_type_convert ();
  }

  protected:
  value
  _xsd_error_type_convert () const;

  public:
  static const char* const _xsd_error_type_literals_[2];
  static const value _xsd_error_type_indexes_[2];
};

class numbering_plan: public ::xml_schema::nmtoken
{
  public:
  enum value
  {
    NP_UNKNOWN,
    NP_ISDN_TEL,
    NP_GENERIC,
    NP_DATA,
    NP_TELEX,
    NP_MARITIME_MOBILE,
    NP_LAND_MOBILE,
    NP_ISDN_MOBILE,
    NP_NETWORK
  };

  numbering_plan (value v);

  numbering_plan (const ::xml_schema::nmtoken& v);

  numbering_plan (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::type* c = 0);

  numbering_plan (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::type* c = 0);

  numbering_plan (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::type* c = 0);

  numbering_plan (const numbering_plan& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::type* c = 0);

  virtual numbering_plan*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::type* c = 0) const;

  numbering_plan&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_numbering_plan_convert ();
  }

  protected:
  value
  _xsd_numbering_plan_convert () const;

  public:
  static const char* const _xsd_numbering_plan_literals_[9];
  static const value _xsd_numbering_plan_indexes_[9];
};

class nature_of_addr_ind: public ::xml_schema::nmtoken
{
  public:
  enum value
  {
    NA_UNKNOWN,
    NA_SUBSCRIBER,
    NA_RESERVED,
    NA_NATIONAL_SIGNIFICANT,
    NA_INTERNATIONAL
  };

  nature_of_addr_ind (value v);

  nature_of_addr_ind (const ::xml_schema::nmtoken& v);

  nature_of_addr_ind (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::type* c = 0);

  nature_of_addr_ind (const ::xercesc::DOMAttr& a,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::type* c = 0);

  nature_of_addr_ind (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::type* c = 0);

  nature_of_addr_ind (const nature_of_addr_ind& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::type* c = 0);

  virtual nature_of_addr_ind*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::type* c = 0) const;

  nature_of_addr_ind&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_nature_of_addr_ind_convert ();
  }

  protected:
  value
  _xsd_nature_of_addr_ind_convert () const;

  public:
  static const char* const _xsd_nature_of_addr_ind_literals_[5];
  static const value _xsd_nature_of_addr_ind_indexes_[5];
};

class encoding_scheme: public ::xml_schema::nmtoken
{
  public:
  enum value
  {
    ES_UNKNOWN,
    ES_ODD,
    ES_EVEN,
    ES_NATIONAL_SPECIFIC
  };

  encoding_scheme (value v);

  encoding_scheme (const ::xml_schema::nmtoken& v);

  encoding_scheme (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::type* c = 0);

  encoding_scheme (const ::xercesc::DOMAttr& a,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::type* c = 0);

  encoding_scheme (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::type* c = 0);

  encoding_scheme (const encoding_scheme& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::type* c = 0);

  virtual encoding_scheme*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::type* c = 0) const;

  encoding_scheme&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_encoding_scheme_convert ();
  }

  protected:
  value
  _xsd_encoding_scheme_convert () const;

  public:
  static const char* const _xsd_encoding_scheme_literals_[4];
  static const value _xsd_encoding_scheme_indexes_[4];
};

class abort_reason: public ::xml_schema::nmtoken
{
  public:
  enum value
  {
    ABORT_REASON_ACN_NOT_SUPPORTED,
    ABORT_REASON_USER_SPECIFIC
  };

  abort_reason (value v);

  abort_reason (const ::xml_schema::nmtoken& v);

  abort_reason (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::type* c = 0);

  abort_reason (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f = 0,
                ::xml_schema::type* c = 0);

  abort_reason (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f = 0,
                ::xml_schema::type* c = 0);

  abort_reason (const abort_reason& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::type* c = 0);

  virtual abort_reason*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::type* c = 0) const;

  abort_reason&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_abort_reason_convert ();
  }

  protected:
  value
  _xsd_abort_reason_convert () const;

  public:
  static const char* const _xsd_abort_reason_literals_[2];
  static const value _xsd_abort_reason_indexes_[2];
};

class problem_type: public ::xml_schema::nmtoken
{
  public:
  enum value
  {
    PROBLEM_TYPE_GENERAL,
    PROBLEM_TYPE_INVOKE,
    PROBLEM_TYPE_RETURN_RESULT,
    PROBLEM_TYPE_RETURN_ERROR,
    PROBLEM_TYPE_TRANSACTION
  };

  problem_type (value v);

  problem_type (const ::xml_schema::nmtoken& v);

  problem_type (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::type* c = 0);

  problem_type (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f = 0,
                ::xml_schema::type* c = 0);

  problem_type (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f = 0,
                ::xml_schema::type* c = 0);

  problem_type (const problem_type& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::type* c = 0);

  virtual problem_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::type* c = 0) const;

  problem_type&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_problem_type_convert ();
  }

  protected:
  value
  _xsd_problem_type_convert () const;

  public:
  static const char* const _xsd_problem_type_literals_[5];
  static const value _xsd_problem_type_indexes_[5];
};

class problem: public ::xml_schema::nmtoken
{
  public:
  enum value
  {
    PROBLEM_CODE_BADLY_STRUCTURED_COMPONENT,
    PROBLEM_CODE_MISTYPED_COMPONENT,
    PROBLEM_CODE_UNRECOGNISED_COMPONENT,
    PROBLEM_CODE_DUPLICATE_INVOKE_ID,
    PROBLEM_CODE_INITIATING_RELEASE,
    PROBLEM_CODE_LINKED_RESPONSE_UNEXPECTED,
    PROBLEM_CODE_MISTYPED_PARAMETER,
    PROBLEM_CODE_RESOURCE_LIMITATION,
    PROBLEM_CODE_UNEXPECTED_LINKED_OPERATION,
    PROBLEM_CODE_UNRECOGNIZED_INVOKE_ID,
    PROBLEM_CODE_UNRECOGNIZED_LINKED_ID,
    PROBLEM_CODE_UNRECOGNIZED_OPERATION,
    PROBLEM_CODE_RETURN_RESULT_UNEXPECTED,
    PROBLEM_CODE_RETURN_ERROR_UNEXPECTED,
    PROBLEM_CODE_UNRECOGNIZED_ERROR,
    PROBLEM_CODE_BADLY_STRUCTURED_TRANSACTION,
    PROBLEM_CODE_INCORRECT_TRANSACTION,
    PROBLEM_CODE_PERMISSION_TO_RELEASE,
    PROBLEM_CODE_RESOURCE_UNAVAILABLE,
    PROBLEM_CODE_UNASSIGNED_RESPONDING_ID,
    PROBLEM_CODE_UNRECOGNIZED_PACKAGE_TYPE
  };

  problem (value v);

  problem (const ::xml_schema::nmtoken& v);

  problem (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::type* c = 0);

  problem (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f = 0,
           ::xml_schema::type* c = 0);

  problem (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f = 0,
           ::xml_schema::type* c = 0);

  problem (const problem& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::type* c = 0);

  virtual problem*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::type* c = 0) const;

  problem&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_problem_convert ();
  }

  protected:
  value
  _xsd_problem_convert () const;

  public:
  static const char* const _xsd_problem_literals_[21];
  static const value _xsd_problem_indexes_[21];
};

class reject_type: public ::xml_schema::nmtoken
{
  public:
  enum value
  {
    REJECT_TYPE_USER,
    REJECT_TYPE_REMOTE,
    REJECT_TYPE_LOCAL
  };

  reject_type (value v);

  reject_type (const ::xml_schema::nmtoken& v);

  reject_type (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::type* c = 0);

  reject_type (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f = 0,
               ::xml_schema::type* c = 0);

  reject_type (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f = 0,
               ::xml_schema::type* c = 0);

  reject_type (const reject_type& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::type* c = 0);

  virtual reject_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::type* c = 0) const;

  reject_type&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_reject_type_convert ();
  }

  protected:
  value
  _xsd_reject_type_convert () const;

  public:
  static const char* const _xsd_reject_type_literals_[3];
  static const value _xsd_reject_type_indexes_[3];
};

class operation_type: public ::xml_schema::nmtoken
{
  public:
  enum value
  {
    OPERATIONTYPE_GLOBAL,
    OPERATIONTYPE_LOCAL
  };

  operation_type (value v);

  operation_type (const ::xml_schema::nmtoken& v);

  operation_type (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::type* c = 0);

  operation_type (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::type* c = 0);

  operation_type (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::type* c = 0);

  operation_type (const operation_type& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::type* c = 0);

  virtual operation_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::type* c = 0) const;

  operation_type&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_operation_type_convert ();
  }

  protected:
  value
  _xsd_operation_type_convert () const;

  public:
  static const char* const _xsd_operation_type_literals_[2];
  static const value _xsd_operation_type_indexes_[2];
};

class error_type1: public ::xml_schema::nmtoken
{
  public:
  enum value
  {
    ERROR_LOCAL,
    ERROR_GLOBAL
  };

  error_type1 (value v);

  error_type1 (const ::xml_schema::nmtoken& v);

  error_type1 (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::type* c = 0);

  error_type1 (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f = 0,
               ::xml_schema::type* c = 0);

  error_type1 (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f = 0,
               ::xml_schema::type* c = 0);

  error_type1 (const error_type1& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::type* c = 0);

  virtual error_type1*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::type* c = 0) const;

  error_type1&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_error_type1_convert ();
  }

  protected:
  value
  _xsd_error_type1_convert () const;

  public:
  static const char* const _xsd_error_type1_literals_[2];
  static const value _xsd_error_type1_indexes_[2];
};

class protocol_version: public ::xml_schema::nmtoken
{
  public:
  enum value
  {
    DP_PROTOCOL_VERSION_ANSI_96
  };

  protocol_version (value v);

  protocol_version (const ::xml_schema::nmtoken& v);

  protocol_version (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::type* c = 0);

  protocol_version (const ::xercesc::DOMAttr& a,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::type* c = 0);

  protocol_version (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::type* c = 0);

  protocol_version (const protocol_version& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::type* c = 0);

  virtual protocol_version*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::type* c = 0) const;

  protocol_version&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_protocol_version_convert ();
  }

  protected:
  value
  _xsd_protocol_version_convert () const;

  public:
  static const char* const _xsd_protocol_version_literals_[1];
  static const value _xsd_protocol_version_indexes_[1];
};

class app_context_identifier: public ::xml_schema::nmtoken
{
  public:
  enum value
  {
    APPLICATION_CONTEXT_INTEGER,
    APPLICATION_CONTEXT_OBJECT
  };

  app_context_identifier (value v);

  app_context_identifier (const ::xml_schema::nmtoken& v);

  app_context_identifier (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::type* c = 0);

  app_context_identifier (const ::xercesc::DOMAttr& a,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::type* c = 0);

  app_context_identifier (const ::std::string& s,
                          const ::xercesc::DOMElement* e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::type* c = 0);

  app_context_identifier (const app_context_identifier& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::type* c = 0);

  virtual app_context_identifier*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::type* c = 0) const;

  app_context_identifier&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_app_context_identifier_convert ();
  }

  protected:
  value
  _xsd_app_context_identifier_convert () const;

  public:
  static const char* const _xsd_app_context_identifier_literals_[2];
  static const value _xsd_app_context_identifier_indexes_[2];
};

class security_context_identifier: public ::xml_schema::nmtoken
{
  public:
  enum value
  {
    SECURITY_CONTEXT_INTEGER,
    SECURITY_CONTEXT_OBJECT
  };

  security_context_identifier (value v);

  security_context_identifier (const ::xml_schema::nmtoken& v);

  security_context_identifier (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::type* c = 0);

  security_context_identifier (const ::xercesc::DOMAttr& a,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::type* c = 0);

  security_context_identifier (const ::std::string& s,
                               const ::xercesc::DOMElement* e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::type* c = 0);

  security_context_identifier (const security_context_identifier& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::type* c = 0);

  virtual security_context_identifier*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::type* c = 0) const;

  security_context_identifier&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_security_context_identifier_convert ();
  }

  protected:
  value
  _xsd_security_context_identifier_convert () const;

  public:
  static const char* const _xsd_security_context_identifier_literals_[2];
  static const value _xsd_security_context_identifier_indexes_[2];
};

class user_status: public ::xml_schema::nmtoken
{
  public:
  enum value
  {
    USER_OUT_OF_SERVICE,
    USER_IN_SERVICE
  };

  user_status (value v);

  user_status (const ::xml_schema::nmtoken& v);

  user_status (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::type* c = 0);

  user_status (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f = 0,
               ::xml_schema::type* c = 0);

  user_status (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f = 0,
               ::xml_schema::type* c = 0);

  user_status (const user_status& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::type* c = 0);

  virtual user_status*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::type* c = 0) const;

  user_status&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_user_status_convert ();
  }

  protected:
  value
  _xsd_user_status_convert () const;

  public:
  static const char* const _xsd_user_status_literals_[2];
  static const value _xsd_user_status_indexes_[2];
};

class p_abort: public ::xml_schema::nmtoken
{
  public:
  enum value
  {
    P_ABORT_UNRCGNZ_MSG_TYPE,
    P_ABORT_UNRECOGNIZED_TRANSACTION_ID,
    P_ABORT_BADLY_FORMATTED_TRANSACTION_PORTION,
    P_ABORT_INCORRECT_TRANSACTION_PORTION,
    P_ABORT_RESOURCE_LIMIT,
    P_ABORT_ABNORMAL_DIALOGUE,
    P_ABORT_UNRECOG_DIALOGUE_PORTION_ID,
    P_ABORT_BADLY_STRUCTURED_DIALOGUE_PORTION,
    P_ABORT_MISSING_DIALOGUE_PORTION,
    P_ABORT_INCONSISTENT_DIALOGUE_PORTION,
    P_ABORT_PERMISSION_TO_RELEASE_PROBLEM
  };

  p_abort (value v);

  p_abort (const ::xml_schema::nmtoken& v);

  p_abort (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::type* c = 0);

  p_abort (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f = 0,
           ::xml_schema::type* c = 0);

  p_abort (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f = 0,
           ::xml_schema::type* c = 0);

  p_abort (const p_abort& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::type* c = 0);

  virtual p_abort*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::type* c = 0) const;

  p_abort&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_p_abort_convert ();
  }

  protected:
  value
  _xsd_p_abort_convert () const;

  public:
  static const char* const _xsd_p_abort_literals_[11];
  static const value _xsd_p_abort_indexes_[11];
};

class abort_reason1: public ::xml_schema::nmtoken
{
  public:
  enum value
  {
    ABORT_REASON_ACN_NOT_SUPPORTED,
    ABORT_REASON_USER_SPECIFIC
  };

  abort_reason1 (value v);

  abort_reason1 (const ::xml_schema::nmtoken& v);

  abort_reason1 (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::type* c = 0);

  abort_reason1 (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::type* c = 0);

  abort_reason1 (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::type* c = 0);

  abort_reason1 (const abort_reason1& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::type* c = 0);

  virtual abort_reason1*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::type* c = 0) const;

  abort_reason1&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_abort_reason1_convert ();
  }

  protected:
  value
  _xsd_abort_reason1_convert () const;

  public:
  static const char* const _xsd_abort_reason1_literals_[2];
  static const value _xsd_abort_reason1_indexes_[2];
};

class class_type: public ::xml_schema::nmtoken
{
  public:
  enum value
  {
    CLASS_1,
    CLASS_2,
    CLASS_3,
    CLASS_4
  };

  class_type (value v);

  class_type (const ::xml_schema::nmtoken& v);

  class_type (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::type* c = 0);

  class_type (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f = 0,
              ::xml_schema::type* c = 0);

  class_type (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f = 0,
              ::xml_schema::type* c = 0);

  class_type (const class_type& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::type* c = 0);

  virtual class_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::type* c = 0) const;

  class_type&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_class_type_convert ();
  }

  protected:
  value
  _xsd_class_type_convert () const;

  public:
  static const char* const _xsd_class_type_literals_[4];
  static const value _xsd_class_type_indexes_[4];
};

class numbering_plan1: public ::xml_schema::nmtoken
{
  public:
  enum value
  {
    NP_UNKNOWN,
    NP_ISDN_TEL,
    NP_GENERIC,
    NP_DATA,
    NP_TELEX,
    NP_MARITIME_MOBILE,
    NP_LAND_MOBILE,
    NP_ISDN_MOBILE,
    NP_NETWORK
  };

  numbering_plan1 (value v);

  numbering_plan1 (const ::xml_schema::nmtoken& v);

  numbering_plan1 (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::type* c = 0);

  numbering_plan1 (const ::xercesc::DOMAttr& a,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::type* c = 0);

  numbering_plan1 (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::type* c = 0);

  numbering_plan1 (const numbering_plan1& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::type* c = 0);

  virtual numbering_plan1*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::type* c = 0) const;

  numbering_plan1&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_numbering_plan1_convert ();
  }

  protected:
  value
  _xsd_numbering_plan1_convert () const;

  public:
  static const char* const _xsd_numbering_plan1_literals_[9];
  static const value _xsd_numbering_plan1_indexes_[9];
};

class nature_of_addr_ind1: public ::xml_schema::nmtoken
{
  public:
  enum value
  {
    NA_UNKNOWN,
    NA_SUBSCRIBER,
    NA_RESERVED,
    NA_NATIONAL_SIGNIFICANT,
    NA_INTERNATIONAL
  };

  nature_of_addr_ind1 (value v);

  nature_of_addr_ind1 (const ::xml_schema::nmtoken& v);

  nature_of_addr_ind1 (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::type* c = 0);

  nature_of_addr_ind1 (const ::xercesc::DOMAttr& a,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::type* c = 0);

  nature_of_addr_ind1 (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::type* c = 0);

  nature_of_addr_ind1 (const nature_of_addr_ind1& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::type* c = 0);

  virtual nature_of_addr_ind1*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::type* c = 0) const;

  nature_of_addr_ind1&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_nature_of_addr_ind1_convert ();
  }

  protected:
  value
  _xsd_nature_of_addr_ind1_convert () const;

  public:
  static const char* const _xsd_nature_of_addr_ind1_literals_[5];
  static const value _xsd_nature_of_addr_ind1_indexes_[5];
};

class encoding_scheme1: public ::xml_schema::nmtoken
{
  public:
  enum value
  {
    ES_UNKNOWN,
    ES_ODD,
    ES_EVEN,
    ES_NATIONAL_SPECIFIC
  };

  encoding_scheme1 (value v);

  encoding_scheme1 (const ::xml_schema::nmtoken& v);

  encoding_scheme1 (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::type* c = 0);

  encoding_scheme1 (const ::xercesc::DOMAttr& a,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::type* c = 0);

  encoding_scheme1 (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::type* c = 0);

  encoding_scheme1 (const encoding_scheme1& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::type* c = 0);

  virtual encoding_scheme1*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::type* c = 0) const;

  encoding_scheme1&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_encoding_scheme1_convert ();
  }

  protected:
  value
  _xsd_encoding_scheme1_convert () const;

  public:
  static const char* const _xsd_encoding_scheme1_literals_[4];
  static const value _xsd_encoding_scheme1_indexes_[4];
};

class problem_type1: public ::xml_schema::nmtoken
{
  public:
  enum value
  {
    PROBLEM_TYPE_GENERAL,
    PROBLEM_TYPE_INVOKE,
    PROBLEM_TYPE_RETURN_RESULT,
    PROBLEM_TYPE_RETURN_ERROR,
    PROBLEM_TYPE_TRANSACTION
  };

  problem_type1 (value v);

  problem_type1 (const ::xml_schema::nmtoken& v);

  problem_type1 (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::type* c = 0);

  problem_type1 (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::type* c = 0);

  problem_type1 (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::type* c = 0);

  problem_type1 (const problem_type1& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::type* c = 0);

  virtual problem_type1*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::type* c = 0) const;

  problem_type1&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_problem_type1_convert ();
  }

  protected:
  value
  _xsd_problem_type1_convert () const;

  public:
  static const char* const _xsd_problem_type1_literals_[5];
  static const value _xsd_problem_type1_indexes_[5];
};

class problem1: public ::xml_schema::nmtoken
{
  public:
  enum value
  {
    PROBLEM_CODE_BADLY_STRUCTURED_COMPONENT,
    PROBLEM_CODE_MISTYPED_COMPONENT,
    PROBLEM_CODE_UNRECOGNISED_COMPONENT,
    PROBLEM_CODE_DUPLICATE_INVOKE_ID,
    PROBLEM_CODE_INITIATING_RELEASE,
    PROBLEM_CODE_LINKED_RESPONSE_UNEXPECTED,
    PROBLEM_CODE_MISTYPED_PARAMETER,
    PROBLEM_CODE_RESOURCE_LIMITATION,
    PROBLEM_CODE_UNEXPECTED_LINKED_OPERATION,
    PROBLEM_CODE_UNRECOGNIZED_INVOKE_ID,
    PROBLEM_CODE_UNRECOGNIZED_LINKED_ID,
    PROBLEM_CODE_UNRECOGNIZED_OPERATION,
    PROBLEM_CODE_RETURN_RESULT_UNEXPECTED,
    PROBLEM_CODE_RETURN_ERROR_UNEXPECTED,
    PROBLEM_CODE_UNRECOGNIZED_ERROR,
    PROBLEM_CODE_BADLY_STRUCTURED_TRANSACTION,
    PROBLEM_CODE_INCORRECT_TRANSACTION,
    PROBLEM_CODE_PERMISSION_TO_RELEASE,
    PROBLEM_CODE_RESOURCE_UNAVAILABLE,
    PROBLEM_CODE_UNASSIGNED_RESPONDING_ID,
    PROBLEM_CODE_UNRECOGNIZED_PACKAGE_TYPE
  };

  problem1 (value v);

  problem1 (const ::xml_schema::nmtoken& v);

  problem1 (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::type* c = 0);

  problem1 (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f = 0,
            ::xml_schema::type* c = 0);

  problem1 (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f = 0,
            ::xml_schema::type* c = 0);

  problem1 (const problem1& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::type* c = 0);

  virtual problem1*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::type* c = 0) const;

  problem1&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_problem1_convert ();
  }

  protected:
  value
  _xsd_problem1_convert () const;

  public:
  static const char* const _xsd_problem1_literals_[21];
  static const value _xsd_problem1_indexes_[21];
};

class reject_type1: public ::xml_schema::nmtoken
{
  public:
  enum value
  {
    REJECT_TYPE_USER,
    REJECT_TYPE_REMOTE,
    REJECT_TYPE_LOCAL
  };

  reject_type1 (value v);

  reject_type1 (const ::xml_schema::nmtoken& v);

  reject_type1 (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::type* c = 0);

  reject_type1 (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f = 0,
                ::xml_schema::type* c = 0);

  reject_type1 (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f = 0,
                ::xml_schema::type* c = 0);

  reject_type1 (const reject_type1& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::type* c = 0);

  virtual reject_type1*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::type* c = 0) const;

  reject_type1&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_reject_type1_convert ();
  }

  protected:
  value
  _xsd_reject_type1_convert () const;

  public:
  static const char* const _xsd_reject_type1_literals_[3];
  static const value _xsd_reject_type1_indexes_[3];
};

class numbering_plan2: public ::xml_schema::nmtoken
{
  public:
  enum value
  {
    NP_UNKNOWN,
    NP_ISDN_TEL,
    NP_GENERIC,
    NP_DATA,
    NP_TELEX,
    NP_MARITIME_MOBILE,
    NP_LAND_MOBILE,
    NP_ISDN_MOBILE,
    NP_NETWORK
  };

  numbering_plan2 (value v);

  numbering_plan2 (const ::xml_schema::nmtoken& v);

  numbering_plan2 (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::type* c = 0);

  numbering_plan2 (const ::xercesc::DOMAttr& a,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::type* c = 0);

  numbering_plan2 (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::type* c = 0);

  numbering_plan2 (const numbering_plan2& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::type* c = 0);

  virtual numbering_plan2*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::type* c = 0) const;

  numbering_plan2&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_numbering_plan2_convert ();
  }

  protected:
  value
  _xsd_numbering_plan2_convert () const;

  public:
  static const char* const _xsd_numbering_plan2_literals_[9];
  static const value _xsd_numbering_plan2_indexes_[9];
};

class encoding_scheme2: public ::xml_schema::nmtoken
{
  public:
  enum value
  {
    ES_UNKNOWN,
    ES_ODD,
    ES_EVEN,
    ES_NATIONAL_SPECIFIC
  };

  encoding_scheme2 (value v);

  encoding_scheme2 (const ::xml_schema::nmtoken& v);

  encoding_scheme2 (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::type* c = 0);

  encoding_scheme2 (const ::xercesc::DOMAttr& a,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::type* c = 0);

  encoding_scheme2 (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::type* c = 0);

  encoding_scheme2 (const encoding_scheme2& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::type* c = 0);

  virtual encoding_scheme2*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::type* c = 0) const;

  encoding_scheme2&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_encoding_scheme2_convert ();
  }

  protected:
  value
  _xsd_encoding_scheme2_convert () const;

  public:
  static const char* const _xsd_encoding_scheme2_literals_[4];
  static const value _xsd_encoding_scheme2_indexes_[4];
};

class user_status1: public ::xml_schema::nmtoken
{
  public:
  enum value
  {
    USER_OUT_OF_SERVICE,
    USER_IN_SERVICE
  };

  user_status1 (value v);

  user_status1 (const ::xml_schema::nmtoken& v);

  user_status1 (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::type* c = 0);

  user_status1 (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f = 0,
                ::xml_schema::type* c = 0);

  user_status1 (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f = 0,
                ::xml_schema::type* c = 0);

  user_status1 (const user_status1& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::type* c = 0);

  virtual user_status1*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::type* c = 0) const;

  user_status1&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_user_status1_convert ();
  }

  protected:
  value
  _xsd_user_status1_convert () const;

  public:
  static const char* const _xsd_user_status1_literals_[2];
  static const value _xsd_user_status1_indexes_[2];
};

class signaling_point_status: public ::xml_schema::nmtoken
{
  public:
  enum value
  {
    DESTINATION_CONGESTED,
    DESTINATION_CONGESTION_ABATEMENT,
    DESTINATION_INACCESSIBLE,
    DESTINATION_ACCESSIBLE
  };

  signaling_point_status (value v);

  signaling_point_status (const ::xml_schema::nmtoken& v);

  signaling_point_status (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::type* c = 0);

  signaling_point_status (const ::xercesc::DOMAttr& a,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::type* c = 0);

  signaling_point_status (const ::std::string& s,
                          const ::xercesc::DOMElement* e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::type* c = 0);

  signaling_point_status (const signaling_point_status& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::type* c = 0);

  virtual signaling_point_status*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::type* c = 0) const;

  signaling_point_status&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_signaling_point_status_convert ();
  }

  protected:
  value
  _xsd_signaling_point_status_convert () const;

  public:
  static const char* const _xsd_signaling_point_status_literals_[4];
  static const value _xsd_signaling_point_status_indexes_[4];
};

class class_type1: public ::xml_schema::nmtoken
{
  public:
  enum value
  {
    CLASS_1,
    CLASS_2,
    CLASS_3,
    CLASS_4
  };

  class_type1 (value v);

  class_type1 (const ::xml_schema::nmtoken& v);

  class_type1 (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::type* c = 0);

  class_type1 (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f = 0,
               ::xml_schema::type* c = 0);

  class_type1 (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f = 0,
               ::xml_schema::type* c = 0);

  class_type1 (const class_type1& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::type* c = 0);

  virtual class_type1*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::type* c = 0) const;

  class_type1&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_class_type1_convert ();
  }

  protected:
  value
  _xsd_class_type1_convert () const;

  public:
  static const char* const _xsd_class_type1_literals_[4];
  static const value _xsd_class_type1_indexes_[4];
};

class termination: public ::xml_schema::nmtoken
{
  public:
  enum value
  {
    TC_BASIC_END,
    TC_PRE_ARRANGED_END
  };

  termination (value v);

  termination (const ::xml_schema::nmtoken& v);

  termination (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::type* c = 0);

  termination (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f = 0,
               ::xml_schema::type* c = 0);

  termination (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f = 0,
               ::xml_schema::type* c = 0);

  termination (const termination& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::type* c = 0);

  virtual termination*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::type* c = 0) const;

  termination&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_termination_convert ();
  }

  protected:
  value
  _xsd_termination_convert () const;

  public:
  static const char* const _xsd_termination_literals_[2];
  static const value _xsd_termination_indexes_[2];
};

class routing_indicator: public ::xml_schema::nmtoken
{
  public:
  enum value
  {
    ROUTING_SUBSYSTEM,
    ROUTING_GLOBALTITLE
  };

  routing_indicator (value v);

  routing_indicator (const ::xml_schema::nmtoken& v);

  routing_indicator (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::type* c = 0);

  routing_indicator (const ::xercesc::DOMAttr& a,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::type* c = 0);

  routing_indicator (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::type* c = 0);

  routing_indicator (const routing_indicator& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::type* c = 0);

  virtual routing_indicator*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::type* c = 0) const;

  routing_indicator&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_routing_indicator_convert ();
  }

  protected:
  value
  _xsd_routing_indicator_convert () const;

  public:
  static const char* const _xsd_routing_indicator_literals_[2];
  static const value _xsd_routing_indicator_indexes_[2];
};

class parameter_identifier: public ::xml_schema::nmtoken
{
  public:
  enum value
  {
    PARAMETERTYPE_SINGLE,
    PARAMETERTYPE_SEQUENCE,
    PARAMETERTYPE_SET
  };

  parameter_identifier (value v);

  parameter_identifier (const ::xml_schema::nmtoken& v);

  parameter_identifier (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::type* c = 0);

  parameter_identifier (const ::xercesc::DOMAttr& a,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::type* c = 0);

  parameter_identifier (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::type* c = 0);

  parameter_identifier (const parameter_identifier& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::type* c = 0);

  virtual parameter_identifier*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::type* c = 0) const;

  parameter_identifier&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_parameter_identifier_convert ();
  }

  protected:
  value
  _xsd_parameter_identifier_convert () const;

  public:
  static const char* const _xsd_parameter_identifier_literals_[3];
  static const value _xsd_parameter_identifier_indexes_[3];
};

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMInputSource.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

// Parse a URI or a local file.
//

::std::auto_ptr< ::tcap_type >
tcap (const ::std::string& uri,
      ::xml_schema::flags f = 0,
      const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::tcap_type >
tcap (const ::std::string& uri,
      ::xml_schema::error_handler& eh,
      ::xml_schema::flags f = 0,
      const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::tcap_type >
tcap (const ::std::string& uri,
      ::xercesc::DOMErrorHandler& eh,
      ::xml_schema::flags f = 0,
      const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse std::istream.
//

::std::auto_ptr< ::tcap_type >
tcap (::std::istream& is,
      ::xml_schema::flags f = 0,
      const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::tcap_type >
tcap (::std::istream& is,
      ::xml_schema::error_handler& eh,
      ::xml_schema::flags f = 0,
      const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::tcap_type >
tcap (::std::istream& is,
      ::xercesc::DOMErrorHandler& eh,
      ::xml_schema::flags f = 0,
      const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::tcap_type >
tcap (::std::istream& is,
      const ::std::string& id,
      ::xml_schema::flags f = 0,
      const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::tcap_type >
tcap (::std::istream& is,
      const ::std::string& id,
      ::xml_schema::error_handler& eh,
      ::xml_schema::flags f = 0,
      const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::tcap_type >
tcap (::std::istream& is,
      const ::std::string& id,
      ::xercesc::DOMErrorHandler& eh,
      ::xml_schema::flags f = 0,
      const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse xercesc::DOMInputSource.
//

::std::auto_ptr< ::tcap_type >
tcap (const ::xercesc::DOMInputSource& is,
      ::xml_schema::flags f = 0,
      const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::tcap_type >
tcap (const ::xercesc::DOMInputSource& is,
      ::xml_schema::error_handler& eh,
      ::xml_schema::flags f = 0,
      const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::tcap_type >
tcap (const ::xercesc::DOMInputSource& is,
      ::xercesc::DOMErrorHandler& eh,
      ::xml_schema::flags f = 0,
      const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse xercesc::DOMDocument.
//

::std::auto_ptr< ::tcap_type >
tcap (const ::xercesc::DOMDocument& d,
      ::xml_schema::flags f = 0,
      const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::tcap_type >
tcap (::xercesc::DOMDocument* d,
      ::xml_schema::flags f = 0,
      const ::xml_schema::properties& p = ::xml_schema::properties ());

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

void
operator<< (::xercesc::DOMElement&, const error_req_event_type&);

void
operator<< (::xercesc::DOMElement&, const timer_reset_req_event_type&);

void
operator<< (::xercesc::DOMElement&, const gtindicator0001_type&);

void
operator<< (::xercesc::DOMElement&, const user_abort_ind_event_type&);

void
operator<< (::xercesc::DOMElement&, const reject_req_event_type&);

void
operator<< (::xercesc::DOMElement&, const end_ind_event_type&);

void
operator<< (::xercesc::DOMElement&, const user_cancel_req_event_type&);

void
operator<< (::xercesc::DOMElement&, const operation_type_def&);

void
operator<< (::xercesc::DOMElement&, const error_ind_event_type&);

void
operator<< (::xercesc::DOMElement&, const dialogue_portion_type&);

void
operator<< (::xercesc::DOMElement&, const tcap_user_address_type&);

void
operator<< (::xercesc::DOMAttr&, const tcap_user_address_type&);

void
operator<< (::xsd::cxx::tree::list_stream< char >&,
            const tcap_user_address_type&);

void
operator<< (::xercesc::DOMElement&, const nstate_ind_event_type&);

void
operator<< (::xercesc::DOMElement&, const provider_abort_ind_event_type&);

void
operator<< (::xercesc::DOMElement&, const user_abort_req_event_type&);

void
operator<< (::xercesc::DOMElement&, const begin_ind_event_type&);

void
operator<< (::xercesc::DOMElement&, const invoke_req_event_type&);

void
operator<< (::xercesc::DOMElement&, const gtindicator0100_type&);

void
operator<< (::xercesc::DOMElement&, const sub_system_address_type&);

void
operator<< (::xercesc::DOMElement&, const signaling_point_code_type&);

void
operator<< (::xercesc::DOMElement&, const unidirectional_req_event_type&);

void
operator<< (::xercesc::DOMElement&, const reject_ind_event_type&);

void
operator<< (::xercesc::DOMElement&, const local_cancel_ind_event_type&);

void
operator<< (::xercesc::DOMElement&, const gtindicator0011_type&);

void
operator<< (::xercesc::DOMElement&, const continue_req_event_type&);

void
operator<< (::xercesc::DOMElement&, const nstate_req_event_type&);

void
operator<< (::xercesc::DOMElement&, const unidirectional_ind_event_type&);

void
operator<< (::xercesc::DOMElement&, const continue_ind_event_type&);

void
operator<< (::xercesc::DOMElement&, const gtindicator0010_type&);

void
operator<< (::xercesc::DOMElement&, const npcstate_ind_event_type&);

void
operator<< (::xercesc::DOMElement&, const begin_req_event_type&);

void
operator<< (::xercesc::DOMElement&, const notice_ind_event_type&);

void
operator<< (::xercesc::DOMElement&, const invoke_ind_event_type&);

void
operator<< (::xercesc::DOMElement&, const result_ind_event_type&);

void
operator<< (::xercesc::DOMElement&, const end_req_event_type&);

void
operator<< (::xercesc::DOMElement&, const result_req_event_type&);

void
operator<< (::xercesc::DOMElement&, const sccp_user_address_type&);

void
operator<< (::xercesc::DOMElement&, const parameters_type&);

void
operator<< (::xercesc::DOMElement&, const state_req_event_type&);

void
operator<< (::xercesc::DOMElement&, const dialogue_ind_event_type&);

void
operator<< (::xercesc::DOMElement&, const component_ind_event_type&);

void
operator<< (::xercesc::DOMElement&, const state_ind_event_type&);

void
operator<< (::xercesc::DOMElement&, const dialogue_req_event_type&);

void
operator<< (::xercesc::DOMElement&, const global_title_type&);

void
operator<< (::xercesc::DOMElement&, const component_req_event_type&);

// Serialize to std::ostream.
//

void
tcap (::std::ostream& os,
      const ::tcap_type& x, 
      const ::xml_schema::namespace_infomap& m,
      const ::std::string& e = "UTF-8",
      ::xml_schema::flags f = 0);

void
tcap (::std::ostream& os,
      const ::tcap_type& x, 
      const ::xml_schema::namespace_infomap& m,
      ::xml_schema::error_handler& eh,
      const ::std::string& e = "UTF-8",
      ::xml_schema::flags f = 0);

void
tcap (::std::ostream& os,
      const ::tcap_type& x, 
      const ::xml_schema::namespace_infomap& m,
      ::xercesc::DOMErrorHandler& eh,
      const ::std::string& e = "UTF-8",
      ::xml_schema::flags f = 0);

// Serialize to xercesc::XMLFormatTarget.
//

void
tcap (::xercesc::XMLFormatTarget& ft,
      const ::tcap_type& x, 
      const ::xml_schema::namespace_infomap& m,
      const ::std::string& e = "UTF-8",
      ::xml_schema::flags f = 0);

void
tcap (::xercesc::XMLFormatTarget& ft,
      const ::tcap_type& x, 
      const ::xml_schema::namespace_infomap& m,
      ::xml_schema::error_handler& eh,
      const ::std::string& e = "UTF-8",
      ::xml_schema::flags f = 0);

void
tcap (::xercesc::XMLFormatTarget& ft,
      const ::tcap_type& x, 
      const ::xml_schema::namespace_infomap& m,
      ::xercesc::DOMErrorHandler& eh,
      const ::std::string& e = "UTF-8",
      ::xml_schema::flags f = 0);

// Serialize to an existing xercesc::DOMDocument.
//

void
tcap (::xercesc::DOMDocument& d,
      const ::tcap_type& x,
      ::xml_schema::flags f = 0);

// Serialize to a new xercesc::DOMDocument.
//

::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
tcap (const ::tcap_type& x, 
      const ::xml_schema::namespace_infomap& m,
      ::xml_schema::flags f = 0);

void
operator<< (::xercesc::DOMElement&, const tcap_type&);

void
operator<< (::xercesc::DOMElement&, const tcap_config_type&);

void
operator<< (::xercesc::DOMElement&, const error_type&);

void
operator<< (::xercesc::DOMAttr&, const error_type&);

void
operator<< (::xsd::cxx::tree::list_stream< char >&,
            const error_type&);

void
operator<< (::xercesc::DOMElement&, const numbering_plan&);

void
operator<< (::xercesc::DOMAttr&, const numbering_plan&);

void
operator<< (::xsd::cxx::tree::list_stream< char >&,
            const numbering_plan&);

void
operator<< (::xercesc::DOMElement&, const nature_of_addr_ind&);

void
operator<< (::xercesc::DOMAttr&, const nature_of_addr_ind&);

void
operator<< (::xsd::cxx::tree::list_stream< char >&,
            const nature_of_addr_ind&);

void
operator<< (::xercesc::DOMElement&, const encoding_scheme&);

void
operator<< (::xercesc::DOMAttr&, const encoding_scheme&);

void
operator<< (::xsd::cxx::tree::list_stream< char >&,
            const encoding_scheme&);

void
operator<< (::xercesc::DOMElement&, const abort_reason&);

void
operator<< (::xercesc::DOMAttr&, const abort_reason&);

void
operator<< (::xsd::cxx::tree::list_stream< char >&,
            const abort_reason&);

void
operator<< (::xercesc::DOMElement&, const problem_type&);

void
operator<< (::xercesc::DOMAttr&, const problem_type&);

void
operator<< (::xsd::cxx::tree::list_stream< char >&,
            const problem_type&);

void
operator<< (::xercesc::DOMElement&, const problem&);

void
operator<< (::xercesc::DOMAttr&, const problem&);

void
operator<< (::xsd::cxx::tree::list_stream< char >&,
            const problem&);

void
operator<< (::xercesc::DOMElement&, const reject_type&);

void
operator<< (::xercesc::DOMAttr&, const reject_type&);

void
operator<< (::xsd::cxx::tree::list_stream< char >&,
            const reject_type&);

void
operator<< (::xercesc::DOMElement&, const operation_type&);

void
operator<< (::xercesc::DOMAttr&, const operation_type&);

void
operator<< (::xsd::cxx::tree::list_stream< char >&,
            const operation_type&);

void
operator<< (::xercesc::DOMElement&, const error_type1&);

void
operator<< (::xercesc::DOMAttr&, const error_type1&);

void
operator<< (::xsd::cxx::tree::list_stream< char >&,
            const error_type1&);

void
operator<< (::xercesc::DOMElement&, const protocol_version&);

void
operator<< (::xercesc::DOMAttr&, const protocol_version&);

void
operator<< (::xsd::cxx::tree::list_stream< char >&,
            const protocol_version&);

void
operator<< (::xercesc::DOMElement&, const app_context_identifier&);

void
operator<< (::xercesc::DOMAttr&, const app_context_identifier&);

void
operator<< (::xsd::cxx::tree::list_stream< char >&,
            const app_context_identifier&);

void
operator<< (::xercesc::DOMElement&, const security_context_identifier&);

void
operator<< (::xercesc::DOMAttr&, const security_context_identifier&);

void
operator<< (::xsd::cxx::tree::list_stream< char >&,
            const security_context_identifier&);

void
operator<< (::xercesc::DOMElement&, const user_status&);

void
operator<< (::xercesc::DOMAttr&, const user_status&);

void
operator<< (::xsd::cxx::tree::list_stream< char >&,
            const user_status&);

void
operator<< (::xercesc::DOMElement&, const p_abort&);

void
operator<< (::xercesc::DOMAttr&, const p_abort&);

void
operator<< (::xsd::cxx::tree::list_stream< char >&,
            const p_abort&);

void
operator<< (::xercesc::DOMElement&, const abort_reason1&);

void
operator<< (::xercesc::DOMAttr&, const abort_reason1&);

void
operator<< (::xsd::cxx::tree::list_stream< char >&,
            const abort_reason1&);

void
operator<< (::xercesc::DOMElement&, const class_type&);

void
operator<< (::xercesc::DOMAttr&, const class_type&);

void
operator<< (::xsd::cxx::tree::list_stream< char >&,
            const class_type&);

void
operator<< (::xercesc::DOMElement&, const numbering_plan1&);

void
operator<< (::xercesc::DOMAttr&, const numbering_plan1&);

void
operator<< (::xsd::cxx::tree::list_stream< char >&,
            const numbering_plan1&);

void
operator<< (::xercesc::DOMElement&, const nature_of_addr_ind1&);

void
operator<< (::xercesc::DOMAttr&, const nature_of_addr_ind1&);

void
operator<< (::xsd::cxx::tree::list_stream< char >&,
            const nature_of_addr_ind1&);

void
operator<< (::xercesc::DOMElement&, const encoding_scheme1&);

void
operator<< (::xercesc::DOMAttr&, const encoding_scheme1&);

void
operator<< (::xsd::cxx::tree::list_stream< char >&,
            const encoding_scheme1&);

void
operator<< (::xercesc::DOMElement&, const problem_type1&);

void
operator<< (::xercesc::DOMAttr&, const problem_type1&);

void
operator<< (::xsd::cxx::tree::list_stream< char >&,
            const problem_type1&);

void
operator<< (::xercesc::DOMElement&, const problem1&);

void
operator<< (::xercesc::DOMAttr&, const problem1&);

void
operator<< (::xsd::cxx::tree::list_stream< char >&,
            const problem1&);

void
operator<< (::xercesc::DOMElement&, const reject_type1&);

void
operator<< (::xercesc::DOMAttr&, const reject_type1&);

void
operator<< (::xsd::cxx::tree::list_stream< char >&,
            const reject_type1&);

void
operator<< (::xercesc::DOMElement&, const numbering_plan2&);

void
operator<< (::xercesc::DOMAttr&, const numbering_plan2&);

void
operator<< (::xsd::cxx::tree::list_stream< char >&,
            const numbering_plan2&);

void
operator<< (::xercesc::DOMElement&, const encoding_scheme2&);

void
operator<< (::xercesc::DOMAttr&, const encoding_scheme2&);

void
operator<< (::xsd::cxx::tree::list_stream< char >&,
            const encoding_scheme2&);

void
operator<< (::xercesc::DOMElement&, const user_status1&);

void
operator<< (::xercesc::DOMAttr&, const user_status1&);

void
operator<< (::xsd::cxx::tree::list_stream< char >&,
            const user_status1&);

void
operator<< (::xercesc::DOMElement&, const signaling_point_status&);

void
operator<< (::xercesc::DOMAttr&, const signaling_point_status&);

void
operator<< (::xsd::cxx::tree::list_stream< char >&,
            const signaling_point_status&);

void
operator<< (::xercesc::DOMElement&, const class_type1&);

void
operator<< (::xercesc::DOMAttr&, const class_type1&);

void
operator<< (::xsd::cxx::tree::list_stream< char >&,
            const class_type1&);

void
operator<< (::xercesc::DOMElement&, const termination&);

void
operator<< (::xercesc::DOMAttr&, const termination&);

void
operator<< (::xsd::cxx::tree::list_stream< char >&,
            const termination&);

void
operator<< (::xercesc::DOMElement&, const routing_indicator&);

void
operator<< (::xercesc::DOMAttr&, const routing_indicator&);

void
operator<< (::xsd::cxx::tree::list_stream< char >&,
            const routing_indicator&);

void
operator<< (::xercesc::DOMElement&, const parameter_identifier&);

void
operator<< (::xercesc::DOMAttr&, const parameter_identifier&);

void
operator<< (::xsd::cxx::tree::list_stream< char >&,
            const parameter_identifier&);

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // JAIN_TCAP_HXX
