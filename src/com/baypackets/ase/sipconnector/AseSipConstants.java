/*
 * @(#)AseSipConstants.java        1.0 2004/08/10
 *
 */
package com.baypackets.ase.sipconnector;

import java.net.InetAddress;
import java.net.UnknownHostException;
import java.util.HashMap;

import org.apache.log4j.Logger;
import org.w3c.dom.Element;
import org.w3c.dom.NodeList;

import com.baypackets.ase.common.Registry;
import com.baypackets.ase.startup.ServerConfigUtil;
import com.baypackets.ase.util.DOMUtils;
import com.dynamicsoft.DsLibs.DsSipObject.DsByteString;
import com.dynamicsoft.DsLibs.DsSipObject.DsSipMessage;
import com.dynamicsoft.DsLibs.DsUtil.DsBindingInfo;
/**
 * Class AseSipConstants manages various constant values 
 *	and mappings for SipConnector module in a Singleton.
 *
 * @version 	1.0 10 Aug 2004 
 * @author 	Vimal Mishra
 *
 */

public class AseSipConstants {

	/**
	 * This class is to be used as a central repository for
	 * various constant values and constant mappings for 
	 * SipConnector module in a Singleton.
	 *
	 */

	////////////////////////// public static constants ////////////////////////

        private static Logger _logger = Logger.getLogger(AseSipConstants.class);
    
	// --
	// ASE SIP Message sources
	// --

	/** Messages received from the network. */
	public static final int SRC_NETWORK = 0;

	/** Messages generated by servlets. */
	public static final int SRC_SERVLET = 1;

	/** Messages generated by ASE. */
	public static final int SRC_ASE = 2;

	// --
	// ASE SIP pseudo transaction timer parameters in millisecs
	// --
	public static final int T1 = 500;
	public static final int T2 = 4000;

	// --
	// ASE SIP connector config parameter names
	// --

	/** ASE run mode */
	public static final String ASE_MODE = "ASE_MODE";

	/** Sip simulator test run mode */
	public static final String SIPSIM_TEST = "SIPSIM_TEST";

	/** No. of threads in SIP connector pool size */
	public static final String SIPCONN_THREADNUM = "mt.connector.thread.pool.size";

	///////////////////////////////////////////////////////////////////////////

	public static final DsByteString BS_REASON = new DsByteString("Reason");

	///////////////////////////////////////////////////////////////////////////

	/** Singleton insatnce of this class. */
	private static AseSipConstants m_Singleton = null;

	/** Lock for the Singleton insatnce of this class. */
	private static Object m_Singleton_Lock = new Object();

        /** Array of SIP methods supported by the SAS */
        private static String[] _methods;
        
	/** Table meant for String objects to DsByteString objects mapping. */
	private HashMap m_StringToDsByteStringMap;

	/** Table meant for DsByteString objects to String objects mapping. */
	private HashMap m_DsByteStringToStringMap;

	/** Name of Well-Known SIP Methods */
	public static final String STR_ACK = "ACK";
	public static final String STR_CANCEL = "CANCEL";
	public static final String STR_REGISTER = "REGISTER";
	public static final String STR_MESSAGE = "MESSAGE";
	public static final String STR_PUBLISH = "PUBLISH";

	/** Warning message on an attempt to modify an Immutable object. */
	public static final String STR_WARN_IMMUTABLE = "Attempt to modify Immutable Object: ";

	/** Error message on detecting a NULL parameter. */
	public static final String STR_ERR_NULL_PARAM = "Null parameter passed.";

	/** Header name to be inserted in Record-Route URI **/
	public static final String RR_URI_PARAM = "asasrr";

	public static AseSipConstants getInstance() {
		if(m_Singleton != null) {
			return m_Singleton;
		}

		synchronized(m_Singleton_Lock) {
			if(m_Singleton != null) {
				return m_Singleton;
			}

			m_Singleton = new AseSipConstants();
		}

		return m_Singleton;
	}

	/**
	 * Construct and initialize this class.
	 *
	 */
	protected AseSipConstants(){

		m_StringToDsByteStringMap = new HashMap();
		m_DsByteStringToStringMap = new HashMap();
		
		String methods[] = AseSipConstants.getSupportedMethods();
		for (int i = 0; i < methods.length; i++) {
            //bug# BPInd09232 TBD??
		    // Initialize m_StringToDsByteStringMap
			m_StringToDsByteStringMap.put(methods[i], new DsByteString(methods[i]) );

		    // Initialize m_DsByteStringToStringMap
			m_StringToDsByteStringMap.put(new DsByteString(methods[i]), methods[i]);
		}
	}
	
        
        /**
         * Returns an array of the SIP methods that are supported by the SAS.
         */
	public static String[] getSupportedMethods() {
            if (_methods == null) {
                if (_logger.isDebugEnabled()) {
                    _logger.debug("Reading supported SIP methods from XML config file...");
                }
                                
                NodeList nodes = ServerConfigUtil.instance().getNodeList("Supported-Methods");
                
                if (nodes != null && nodes.getLength() > 0) {
                    nodes = ((Element)nodes.item(0)).getElementsByTagName("Method");                    
                    
                    if (nodes != null && nodes.getLength() > 0) {
                        _methods = new String[nodes.getLength()];
                        
                        for (int i = 0; i < nodes.getLength(); i++) {
                            String method = DOMUtils.getChildCharacterData((Element)nodes.item(i)).trim();
                            
                            if (_logger.isDebugEnabled()) {
                                _logger.debug("Reading SIP method: " + method);
                            }
                            _methods[i] = method;
                        }
                    } else {
                        _logger.warn("No SIP methods listed in XML config file!");
                    }
                }                                
            }
            return _methods;
	}

        
	/**
	 * Returns a reference to a DsByteString object that 
	 *	represents the same string as the passed java.lang.String object.
	 *
	 * @param strStr java.lang.String object
	 *
	 * @return DsByteString object reference.
	 *
	 */
	public static DsByteString getDsByteString( String strStr){
		return (DsByteString)m_Singleton.m_StringToDsByteStringMap.get(strStr);
	}

	/**
	 * Returns a reference to a java.lang.String object that 
	 *	represents the same string as the passed DsByteString object.
	 *
	 * @param strDsByteStr DsByteString object reference
	 *
	 * @return java.lang.String object
	 *
	 */
	public static String getString( DsByteString strDsByteStr){
		return (String)m_Singleton.m_DsByteStringToStringMap.get(strDsByteStr);
	}
	
	
	private static AseSipConnector connector  = null;
	
	public static AseSipConnector getConnector(){
		if(connector != null )
			return connector;
		connector = (AseSipConnector) Registry.lookup("SIP.Connector");
		return connector;
	}
	
	public static AseConnectorSipFactory getSipFactory(){
		return (AseConnectorSipFactory) (getConnector() == null ? null : connector.getFactory());
	}
	
	//Fix for the BPUsa07694.
	//When SAS is deployed on a multihomed m/c, 
	//the outgoing request/response is send using any available IP.
	//So the local address is not set explicitely in the Binding Info,
	//This method will set the  SIP Connector IP Address as the Local Address.
	//This method will be called from the Server and Client Transaction Classes.
	public static void fixLocalIPAddress(DsSipMessage message){

		if(message == null) {
			if (_logger.isDebugEnabled()) _logger.debug("Message is null. Returning.");
			return;
		}
		
		DsBindingInfo bInfo = message.getBindingInfo();
		if(bInfo == null){
			if (_logger.isDebugEnabled()) _logger.debug("Binding Info is not Set, So not fixing the Local Address.");
			return;
		}
		if( bInfo.getLocalAddress() != null ){
			if (_logger.isDebugEnabled()) _logger.debug("Local Address is already set. So not fixing the Local Address.");
			return;
		}
		
		InetAddress localAddr = null;
		String ipAddress = getConnector().getIPAddress();
		try{
			localAddr = ipAddress == null ? null : InetAddress.getByName(ipAddress);
		}catch(UnknownHostException e){
			//This should not happen. Lets log it, if it happens.
			_logger.error(e.getMessage(), e);
		}	 
		
		if(localAddr == null){
			if (_logger.isDebugEnabled()) _logger.debug("Local IP Address is NULL. So not fixing the Local Address.");
			return;
		}
		
		if(_logger.isDebugEnabled()){
			_logger.debug("Local IP Address is NOT NULL. So fixing the Local Address. " + localAddr.toString() );
		}
		bInfo.setLocalAddress(localAddr);
	}
	
}

