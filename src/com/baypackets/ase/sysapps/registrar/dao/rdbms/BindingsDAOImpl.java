package com.baypackets.ase.sysapps.registrar.dao.rdbms;


import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.InputStream;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import javax.crypto.spec.SecretKeySpec;
import javax.naming.Context;
import javax.naming.InitialContext;
import javax.sql.DataSource;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import org.apache.log4j.Logger;
import com.baypackets.ase.common.Registry;
import com.baypackets.ase.sysapps.registrar.common.Binding;
import com.baypackets.ase.sysapps.registrar.common.Configuration;
import com.baypackets.ase.sysapps.registrar.common.GRUUConstructionUtility;
import com.baypackets.ase.sysapps.registrar.common.Registration;
import com.baypackets.ase.sysapps.registrar.common.GRUUConstructionUtility.TempGruuAlgoritm;
import com.baypackets.ase.sysapps.registrar.dao.BindingsDAO;
import com.baypackets.ase.sysapps.registrar.presence.Note;
import com.baypackets.ase.sysapps.registrar.presence.Person;
import com.baypackets.ase.sysapps.registrar.presence.Presence;
import com.baypackets.ase.sysapps.registrar.presence.Tuple;
import com.baypackets.ase.util.Constants;
import com.baypackets.bayprocessor.slee.common.ConfigRepository;


/** This class implements the BindingsDAO interface. It access the relational database to retrieve and persists bindings objects.
*/
public class BindingsDAOImpl implements BindingsDAO  
{

	Configuration m_config=null;
	String initialContextFactory=null;
	String providerUrl=null;
	Context ctx=null;
	Hashtable environment=null;
	static DataSource  regDataSource;

	static Logger logger=Logger.getLogger(BindingsDAOImpl.class);

	public BindingsDAOImpl() {
		m_config = Configuration.getInstance();
		environment = new Hashtable();
		logger.debug("BindingsDAOImpl has been initialized");
		String fileName = null; // to read datasource configuration.
		DocumentBuilderFactory documentBuilderFactory = null;
		DocumentBuilder documentBuilder = null;
		InputStream inputStream = null;
		try {
			ConfigRepository m_configRepository = (ConfigRepository) Registry
					.lookup(Constants.NAME_CONFIG_REPOSITORY);
			String aseHome = (String) m_configRepository
					.getValue(Constants.PROP_ASE_HOME);
			logger.debug("ASEHOME ====> " + aseHome);
			fileName = aseHome + "/conf/datasources.xml";
			logger.debug("The file to be read for datasource configuration  is "
					+ fileName);
			documentBuilderFactory = DocumentBuilderFactory.newInstance();
			documentBuilder = documentBuilderFactory.newDocumentBuilder();
			inputStream = new FileInputStream(fileName);

			initialContextFactory = (String) m_configRepository
					.getValue(Constants.OID_JNDI_JDBC_CONTEXT_FACTORY);
			providerUrl = (String) m_configRepository
					.getValue(Constants.OID_JNDI_JDBC_PROVIDER_URL);

		} catch (FileNotFoundException e) {
			logger.error(e.toString(), e);
		} catch (Exception e) {
			logger.error(e.toString(), e);
		}
		// Properties jndiInfo=new Properties();
		try {
			logger.debug("INITIAL_CONTEXT_FACTORy===> " + initialContextFactory);
			logger.debug("PROVIDER_URL======> " + providerUrl);
			environment.put(Context.INITIAL_CONTEXT_FACTORY,
					initialContextFactory);
			environment.put(Context.PROVIDER_URL, providerUrl);
			ctx = new InitialContext(environment);
			String dataSourceName = m_config
					.getParamValue(com.baypackets.ase.sysapps.registrar.common.Constants.PROP_REGISTRAR_DATASOURCE_NAME);
			dataSourceName = (dataSourceName != null && !dataSourceName.trim()
					.isEmpty()) ? dataSourceName
							: com.baypackets.ase.sysapps.registrar.common.Constants.PATH_DATASOURCE;
			regDataSource = (DataSource) ctx.lookup(dataSourceName);
		} catch (Exception e) {
			logger.error(e.toString(), e);
			logger.error("Unable to read from the datasources.xml file");
		}

	}

	
	/**
	 * This method get the bindings for a particular address of record
	 * 
	 * @param addressOfRecord
	 *            This is the address of record uri.
	 */
	public synchronized ArrayList getBindingsFor(String addressOfRecord)
			throws SQLException, Exception {
		/*
		 * Reason for using two statement objects,
		 * 
		 * By default, only one ResultSet object per Statement object can be
		 * open at the same time. Therefore, if the reading of one ResultSet
		 * object is interleaved with the reading of another, each must have
		 * been generated by different Statement objects. All execution methods
		 * in the Statement interface implicitly close a statment's current
		 * ResultSet object if an open one exists.
		 */

		ArrayList bindings = null;
		Connection conn = null;
		ResultSet rset = null;
		ResultSet rs1 = null;
		PreparedStatement pstmt = null;
		PreparedStatement pstmt1 = null;
		// Replace all "'" in AOR for avoiding sql syntex error
		String aor = addressOfRecord.replaceAll("'", "''");		

		bindings = new ArrayList();

		try {
			conn = regDataSource.getConnection();
			if (conn == null) {
				logger.error("There are no bindings for " + addressOfRecord);
				return bindings;
			}
			pstmt = conn
					.prepareStatement("select REGISTRATIONID,CallId,Cseq,FIRST_CSEQ,ContactId,ContactUri,DisplayName,UnknownParam,Expires,Priority,insertiontime,Path,state,event,featuretags,reg_id,SIPINSTANCEID from reg_binding where registrationId=(select registrationId from reg_registrations where addressofrecord=?)");
			pstmt.setString(1, aor);
			rset = pstmt.executeQuery();
			// passociateduri is added for P-Associated-URI Header support

			logger.debug("Result set is selected from the table");

			int i = 1;
			while (rset.next()) {
				Binding binding = new Binding();

				int registrationId = rset.getInt("REGISTRATIONID");
				String Obj_CID = rset.getString("callid");
				int Obj_CSEQ = rset.getInt("cseq");
				int Obj_FCSEQ = rset.getInt("FIRST_CSEQ");
				String Obj_CONID = rset.getString("contactid");
				String Obj_CAD = rset.getString("contacturi");
				String Obj_DISP = rset.getString("displayname");
				String Obj_UKP = rset.getString("unknownparam");
				int Obj_EXP = rset.getInt("expires");
				float Obj_PRIO = rset.getFloat("priority");
				long Obj_INSERTION_TIME = rset.getLong("insertiontime");				
				String Obj_Path = rset.getString("path");				
				String Obj_STA = rset.getString("state");				
				String Obj_EVE = rset.getString("event");
				String Obj_FeatTags = rset.getString("featuretags");
				int Obj_REG_ID = rset.getInt("reg_id");
				String Obj_SIPINSTANCE = rset.getString("SIPINSTANCEID");
				
				if(logger.isDebugEnabled()){
				logger.debug("registrationId=====> " + registrationId);				
				logger.debug("Call Id=====> " + Obj_CID);				
				logger.debug("CSEQ=====> " + Obj_CSEQ);				
				logger.debug("CSEQ=====> " + Obj_FCSEQ);
				logger.debug("Contact id===> " + Obj_CONID);				
				logger.debug("CAD====> " + Obj_CAD);			
				logger.debug("DISP====> " + Obj_DISP);				
				logger.debug("UKP====>" + Obj_UKP);
				logger.debug("Expiration time====> " + Obj_EXP);
				logger.debug("Priority====> " + Obj_PRIO);		
				logger.debug("Record insertion time in seconds ====> "
						+ Obj_INSERTION_TIME);			
				logger.debug("Path====>" + Obj_Path);
				logger.debug("STA====>" + Obj_STA);
				logger.debug("EVE====>" + Obj_EVE);		
				logger.debug("Feature Tags ====>" + Obj_FeatTags);
				logger.debug("reg-id=====> " + Obj_REG_ID);
				logger.debug("SIPINSTANCEID====>" + Obj_SIPINSTANCE);
				}
				
				java.util.Date date = new java.util.Date();
				// System time in seconds
				long currentSystemTime = (date.getTime()) / 1000; 
				if (currentSystemTime > (Obj_EXP + Obj_INSERTION_TIME)) {
					// This binding has been expired.
					// The expiration time has been crossed.
					continue;
				}

				 
				
				binding.setCallID(Obj_CID.trim());
				binding.setBindingID(Obj_CONID.trim());
				binding.setCSeq(Obj_CSEQ);
				binding.setFirstCSeq(Obj_FCSEQ);
				if (Obj_DISP != null)
					binding.setDisplayName(Obj_DISP.trim());
				if (Obj_UKP != null)
					binding.setUnknownParam(Obj_UKP.trim());
				binding.setContactURI(Obj_CAD.trim());

				binding.setExpires(Obj_EXP);
				binding.setPriority(Obj_PRIO);
				binding.setEvent(Obj_EVE.trim());
				binding.setState(Obj_STA.trim());
				if (Obj_Path != null)
					binding.setPath(Obj_Path.trim());
				binding.setDurationRegistered(currentSystemTime
						- Obj_INSERTION_TIME);
				if (Obj_FeatTags != null)
					binding.setFeatureTags(Obj_FeatTags.trim());
				binding.setReg_id(Obj_REG_ID);
				if (Obj_SIPINSTANCE != null)
					binding.setSipinstanceId(Obj_SIPINSTANCE.trim());

				String Obj_PUBGRUU = null;
				if (Obj_SIPINSTANCE != null) {
					String sipInstance = Obj_SIPINSTANCE.trim().replaceAll("'",
							"''");
					try {
						pstmt1 = conn
								.prepareStatement("select GRUU_URI from reg_pubgruu where REGISTRATIONID=? AND SIP_INSTANCE_ID=?");
						pstmt1.setInt(1, registrationId);
						pstmt1.setString(2, sipInstance);
						rs1 = pstmt1.executeQuery();
						while (rs1.next()) {
							Obj_PUBGRUU = rs1.getString("GRUU_URI");
							if(logger.isDebugEnabled())
								logger.debug("PUBGRUU====>" + Obj_PUBGRUU);
						}
					} catch (Exception e) {
						logger.error(e.toString(), e);
					} finally {
						try {
							if (rs1 != null) {
								rs1.close();
							}
						} catch (SQLException e) {
							logger.error(e.toString(), e);
						}
						try {
							if (pstmt1 != null) {
								pstmt1.close();
							}
						} catch (SQLException e) {
							logger.error(e.toString(), e);
						}
					}
				}
				if (Obj_PUBGRUU != null) {
					binding.setPubGRUU(Obj_PUBGRUU.trim());
				}
				bindings.add(binding);
				if(logger.isDebugEnabled())
					logger.debug("bindings size: " + bindings.size());
				i++;
			}
			if(logger.isDebugEnabled())
				logger.debug("There are " + i + " records for this " + aor+ " address of record");
			
		} catch (SQLException e) {
			logger.error("SQLException occurred");
			logger.error(e.toString(), e);
			throw e;
		} catch (Exception e) {
			logger.error(e.toString(), e);
			throw e;
		} finally {
			try {
				if (rset != null) {
					rset.close();
				}
			} catch (SQLException e) {
				logger.error(e.toString(), e);
			}
			try {
				if (pstmt != null) {
					pstmt.close();
				}
			} catch (SQLException e) {
				logger.error(e.toString(), e);
			}
			try {
				if (conn != null) {
					conn.close();
				}
			} catch (SQLException e) {
				logger.error(e.toString(), e);
			}
		}		
		return bindings;
	}

	/** This method updates the bindings 
	* @param inserts These bindings are inserted
	* @param updates These bindings are updated
	* @param remove These bindings are removed
	*/
	public synchronized void persist(ArrayList inserts,ArrayList updates, ArrayList remove,String addressOfRecord) throws SQLException,Exception
	{
		String addressofrecord=null;
        Connection connection=null;
        ResultSet rset=null;
        Statement stmt=null;
		String aor=addressOfRecord.replaceAll("'", "''");				

		try
		{
			try {
				connection = regDataSource.getConnection();

				if (connection == null) {
					logger.error("persist()::could not get connection");
					return;
				}

				connection.setAutoCommit(false);

				stmt = connection.createStatement();
			} catch (Exception e) {
				logger.error(e.toString(), e);
				logger.error("Not able to create connections");
				throw e;
			}
              
			if (remove != null && remove.size() != 0) {
				logger.debug("About to remove bindings...");
				PreparedStatement pstmt1 = null;
				ResultSet regs_id = null;
				try {
					pstmt1 = connection
							.prepareStatement("select registrationid from reg_registrations where addressofrecord=?");
					pstmt1.setString(1, aor);
					regs_id = pstmt1.executeQuery();

					if (regs_id.next()) {
						int regs_Id = regs_id.getInt(1);
						PreparedStatement pstmt2 = null;
						PreparedStatement pstmt3 = null;						

						try {
							Iterator rem_iterator = remove.iterator();
							pstmt2 = connection
									.prepareStatement("delete from reg_binding where reg_binding.contactId=? and reg_binding.registrationid=?");
							pstmt3 = connection
									.prepareStatement("select count(*) from reg_binding where sipinstanceid=? and reg_binding.registrationid=?");
							while (rem_iterator.hasNext()) {
								Binding bind = (Binding) rem_iterator.next();
								String bindingid_str = bind.getBindingID();
								String sipInstanceId = bind.getSipinstanceId();
								// deleting a row .
								ResultSet res = null;
								try {
									pstmt2.setString(1, bindingid_str);
									pstmt2.setInt(2, regs_Id);
									pstmt2.addBatch();
									if (sipInstanceId != null) {
										sipInstanceId = sipInstanceId
												.replaceAll("'", "''");
										if (bind.getCallId_Changed()) {
											invalidateGRUU(connection, aor,
													sipInstanceId, regs_Id);
										} else {
											pstmt3.setString(1, sipInstanceId);
											pstmt3.setInt(2, regs_Id);
											res = pstmt3.executeQuery();
											while (res.next()) {
												int count = res.getInt(1);
												if (count == 0) {
													invalidateGRUU(connection,
															aor, sipInstanceId,
															regs_Id);
												}
											}
										}
									}
								} catch (SQLException sse) {
									throw sse;
								} catch (Exception excep) {
									connection.rollback();
									throw excep;

								} finally {
									try {
										if (res != null) {
											res.close();
										}
									} catch (SQLException e) {
										logger.error(e.toString(), e);
									}
								}
							}
							pstmt2.executeBatch();
						} catch (SQLException sse) {
							throw sse;
						} catch (Exception excep) {
							connection.rollback();
							throw excep;

						} finally {
							try {
								if (pstmt2 != null) {
									pstmt2.close();
								}
							} catch (SQLException e) {
								logger.error(e.toString(), e);
							}
							try {
								if (pstmt3 != null) {
									pstmt3.close();
								}
							} catch (SQLException e) {
								logger.error(e.toString(), e);
							}
						}
					} else {
						logger.debug("There is no record for this address of record in the database");

					}
				} catch (Exception e) {
					logger.error(e.toString(), e);
					throw e;
				} finally {
					try {
						if (pstmt1 != null) {
							pstmt1.close();
						}
					} catch (SQLException e) {
						logger.error(e.toString(), e);
					}
					try {
						if (regs_id != null) {
							regs_id.close();
						}
					} catch (SQLException e) {
						logger.error(e.toString(), e);
					}
				}
			} else {
				logger.debug("There is no bindings ro be deleted");

			}

			String contact="";
			int cseq,fcseq;
			String callid="";
			String bindingId=null;
			int exp=0;
			float priority;
			String displayName = null;
			String unknownParam = null;
			String state = null;
			String event = null;	
			String path = null;
			String tags = null;
			int reg_id=0;
			String sipinstance="";
			String pubgruu="";
		
			if(updates!=null && updates.size()!=0)
			{

				logger.debug("Updating the binding in the database");
			 
				Iterator up_iterator=updates.iterator();

				PreparedStatement pstmnt = null;				
				ResultSet resultSet = null;
				
				try{
				pstmnt = connection.prepareStatement("select registrationid from reg_registrations where addressofrecord=?");	
				pstmnt.setString(1, aor);	
				resultSet = pstmnt.executeQuery();
				if(resultSet.next())
				{					
					int regs_Id_up=resultSet.getInt(1);
			
					while(up_iterator.hasNext())
					{
						 Binding bindup=(Binding)up_iterator.next();
						
						 String bindingId1=bindup.getBindingID();
						 exp=bindup.getExpires();
						 priority=bindup.getPriority();
						 logger.debug("New Priority==>"+priority);
						 callid=bindup.getCallID().replaceAll("'", "''");
						 cseq=bindup.getCSeq();
						 fcseq=bindup.getFirstCSeq();
						 contact=bindup.getContactURI().replaceAll("'", "''");
						 displayName = (bindup.getDisplayName()!=null)?bindup.getDisplayName().replaceAll("'", "''"):"";
						 unknownParam = (bindup.getUnknownParam()!=null)?bindup.getUnknownParam().replaceAll("'", "''"):"";
						 state = bindup.getState();
						 event = bindup.getEvent();
						 path = (bindup.getPath()!=null)?bindup.getPath().replaceAll("'", "''"):"";
						 reg_id=bindup.getReg_id();
						 tags = (bindup.getFeatureTags()!=null)?bindup.getFeatureTags().replaceAll("'", "''"):"";
//********************************************BPInd13279*****************************************

						java.util.Date date_update = new java.util.Date();
						long currentSystemTime_update = (date_update.getTime())/1000;
						sipinstance=(bindup.getSipinstanceId()!=null)?bindup.getSipinstanceId().replaceAll("'", "''"):"";
						pubgruu=(bindup.getPubGRUU()!=null)?bindup.getPubGRUU().replaceAll("'", "''"):"";
//****************************************************************************************

						

						try {
							stmt.execute("update reg_binding set reg_binding.contactURI='"
									+ contact
									+ "',reg_binding.expires='"
									+ exp
									+ "',reg_binding.insertiontime='"
									+ currentSystemTime_update
									+ "',reg_binding.priority='"
									+ priority
									+ "',reg_binding.state='"
									+ state
									+ "',reg_binding.event='"
									+ event
									+ "',reg_binding.displayname='"
									+ displayName
									+ "',reg_binding.path='"
									+ path
									+ "',reg_binding.unknownParam='"
									+ unknownParam
									+ "',reg_binding.callid='"
									+ callid
									+ "',reg_binding.cseq='"
									+ cseq
									+ "',reg_binding.first_cseq='"
									+ fcseq
									+ "',reg_binding.SIPINSTANCEID='"
									+ sipinstance
									+ "', reg_binding.featuretags='"
									+ tags
									+ "', reg_binding.reg_id='"
									+ reg_id
									+ "' where reg_binding.contactid='"
									+ bindingId1
									+ "' and reg_binding.registrationid='"
									+ regs_Id_up + "'");
							if (bindup.getGruuRequested()) {
								if (bindup.getCallId_Changed()) {
									invalidateGRUU(connection, aor,
											sipinstance, regs_Id_up);
								}
								insertGRUU(connection, aor, sipinstance,
										pubgruu, regs_Id_up,
										currentSystemTime_update);
							}
						}
						catch (SQLException se) {
							logger.error(se.toString(), se);
							throw se;
						} catch (Exception excep) {
							connection.rollback();
							logger.error("Connection is rolled back");
							logger.error(excep.toString(), excep);
							throw excep;
						}
          			
				 	}	
				 }else {
					logger.debug("There is no record to be updated");
				}
				} catch (SQLException se) {
					logger.error(se.toString(), se);
					throw se;
				} catch (Exception excep) {
					connection.rollback();
					logger.error("Connection is rolled back");
					logger.error(excep.toString(), excep);
					throw excep;
				} finally {
					try {
						if (resultSet != null) {
							resultSet.close();
						}
					} catch (SQLException e) {
						logger.error(e.toString(), e);
					}
					try {
						if (pstmnt != null) {
							pstmnt.close();
						}
					} catch (SQLException e) {
						logger.error(e.toString(), e);
					}
				}
			} else {
				logger.debug("The update record is empty");
			}

			 if(inserts!=null && inserts.size()!=0)
			  {
			  	ResultSet resultSet=stmt.executeQuery("select registrationid from reg_registrations where addressofrecord='"+aor+"'");
				if(resultSet.next())
				{
					int regs_Id_insert=resultSet.getInt(1);
                                        
					Iterator insert_iterator=inserts.iterator();
					logger.debug("inserting the reg_binding into the database");
					while(insert_iterator.hasNext())
					{
					
						 Binding bindup=(Binding)insert_iterator.next();
						// bindup.setBindingId(contact_Id);
						 //bindingId=bindup.getBindingId();
						 bindingId = bindup.getBindingID();
						  exp=bindup.getExpires();
						  priority=bindup.getPriority();
						  logger.debug("the priority==>"+priority);
						  callid=bindup.getCallID().replaceAll("'", "''");
						  cseq=bindup.getCSeq();
						  fcseq=bindup.getFirstCSeq();
						  contact=bindup.getContactURI().replaceAll("'", "''");					 
						 displayName = (bindup.getDisplayName()!=null)?bindup.getDisplayName().replaceAll("'", "''"):"";
						 unknownParam = (bindup.getUnknownParam()!=null)?bindup.getUnknownParam().replaceAll("'", "''"):"";
						 state = bindup.getState();
						 event = bindup.getEvent();
						 path = (bindup.getPath()!=null)?bindup.getPath().replaceAll("'", "''"):"";
						 reg_id=bindup.getReg_id();
						 tags = (bindup.getFeatureTags()!=null)?bindup.getFeatureTags().replaceAll("'", "''"):"";
						 sipinstance=(bindup.getSipinstanceId()!=null)?bindup.getSipinstanceId().replaceAll("'", "''"):"";
						 pubgruu=(bindup.getPubGRUU()!=null)?bindup.getPubGRUU().replaceAll("'", "''"):"";
//******************************************************BPInd13279***********************

						java.util.Date date_insert = new java.util.Date();
						long currentSystemTimeInsert = (date_insert.getTime())/1000;				
				
						PreparedStatement pstmnt12 = null;
						PreparedStatement pstmnt13 = null;
						try
						{
							//stmt.execute("delete from reg_binding where reg_binding.contactId='"+bindingId+"' and reg_binding.registrationid='"+regs_Id_insert+"'");
						
							stmt.execute("insert into reg_binding (contacturi,expires,priority,insertiontime,registrationid,displayname,unknownparam,state,event,callid,cseq,first_cseq,path,featuretags,reg_id,SIPINSTANCEID) values('"+contact+"','"+exp+"','"+priority+"','"+currentSystemTimeInsert+"','"+regs_Id_insert+"','"+displayName+"','"+unknownParam+"','"+state+"','"+event+"','"+callid+"','"+cseq+"','"+fcseq+"','"+path+"','"+tags+"','"+reg_id+"','"+sipinstance+"') ");
							if(!sipinstance.equals("")&& !pubgruu.equals(""))
							{
								insertGRUU(connection, aor, sipinstance, pubgruu, regs_Id_insert, currentSystemTimeInsert);
							}
						
						}
						catch(SQLException se)
						{
							connection.rollback();
							logger.error(se.toString(),se);
							throw se;
						}
						catch(Exception excep)
						{
							connection.rollback();
							logger.error(excep.toString(),excep);
							throw excep;
						}
				
				       }
				 }
				}
			 else
			 {
				logger.debug("There is no binding to be inserted");
				
			 }

			 try {
				 connection.commit();
			 } catch (SQLException se) {
				 connection.rollback();
				 logger.error(se.toString(), se);
				 throw se;
			 } catch (Exception eeeecommit) {
				 connection.rollback();
				 logger.debug(eeeecommit.toString(), eeeecommit);
				 throw eeeecommit;
			 }
			
		  }
		  catch(SQLException sqle)
		  {
			logger.error(sqle.toString(),sqle);	
			throw sqle;
		  }

		  catch(Exception eqq)
		  {
			logger.error(eqq.toString(),eqq);
			throw eqq;	
		  }finally {
				try {
					if (stmt != null) {
						stmt.close();
					}
				} catch (SQLException e) {
					logger.error(e.toString(), e);
				}
				try {
					if (connection != null) {
						connection.close();
					}
				} catch (SQLException e) {
					logger.error(e.toString(), e);
				}
			}
		
	}

	

	/** This method does the authorization i.e. it determines whether the client is authorized to access the bindings.
	* @param toaddr The address of record
	* @param fromaddr The from header of the register request
	*/

	public boolean authorization(String toaddr, String fromaddr)
			throws SQLException, Exception {

		Connection conn = null;
		ResultSet rset = null;
		PreparedStatement pstmt = null;
		toaddr = toaddr.replaceAll("'", "''");

		try {
			conn = regDataSource.getConnection();

			if (conn == null) {
				logger.error("authorization():: could not get connection");
				return false;
			}
			pstmt = conn
					.prepareStatement("select authorizeaddress from reg_authorizations where reg_authorizations.addressofrecord=?");
			pstmt.setString(1, toaddr);
			rset = pstmt.executeQuery();
			logger.debug("Result set is selected from the table");

		}

		catch (SQLException e) {
			logger.error(e.toString(), e);
			try {
				if (pstmt != null) {
					pstmt.close();
				}
			} catch (SQLException ex) {
				logger.error(e.toString(), e);
			}
			try {
				if (conn != null) {
					conn.close();
				}
			} catch (SQLException ex) {
				logger.error(e.toString(), ex);
			}
			throw e;
		}

		catch (Exception ee) {
			try {
				if (pstmt != null) {
					pstmt.close();
				}
			} catch (SQLException e) {
				logger.error(e.toString(), e);
			}
			try {
				if (conn != null) {
					conn.close();
				}
			} catch (SQLException e) {
				logger.error(e.toString(), e);
			}
			logger.debug(ee.toString(), ee);
			throw ee;

		}

		if (rset == null)

			return false;
		try {
			while (rset.next()) {
				String authorizeaddress = (rset.getString(1)).trim();
				if ((authorizeaddress.trim()).equals(fromaddr)) {
					return true;
				}
			}
			return false;
		} catch (SQLException sqe) {
			logger.error(sqe.toString(), sqe);
			throw sqe;
		} catch (Exception e) {
			logger.error(e.toString(), e);

			throw e;
		} finally {
			try {
				if (rset != null) {
					rset.close();
				}
			} catch (SQLException e) {
				logger.error(e.toString(), e);
			}
			try {
				if (pstmt != null) {
					pstmt.close();
				}
			} catch (SQLException e) {
				logger.error(e.toString(), e);
			}
			try {
				if (conn != null) {
					conn.close();
				}
			} catch (SQLException e) {
				logger.error(e.toString(), e);
			}
		}

	}
		
	public Registration getRegistrationFor(String addressOfRecord)
			throws SQLException, Exception {
		Registration registration = null;
		Connection connection = null;
		PreparedStatement pstmt = null;
		ResultSet rs = null;
		String sqlQuery;
		int registrationId;
		String aor = "";
		String userName = "";
		addressOfRecord = addressOfRecord.replaceAll("'", "''");
		logger.debug("Inside getRegistrationFor() of BindingsDAOImpl");
		try {
			connection = regDataSource.getConnection();
			if (connection == null) {
				logger.error("getRegistrationFor()::couldnot get connection");
				return null;
			}
			logger.debug("BindingsDAOImpl::getRegistrationFor(), Connection: "
					+ connection.toString());
			sqlQuery = "SELECT a.REGISTRATIONID,a.ADDRESSOFRECORD,a.USERNAME FROM reg_registrations a WHERE a.ADDRESSOFRECORD=? AND a.IS_PUBLIC='true'";
			pstmt = connection.prepareStatement(sqlQuery);
			pstmt.setString(1, addressOfRecord);
			logger.debug("BindingsDAOImpl::getRegistrationFor(), Going to select data from REGISTRATIONS table: ");
			rs = pstmt.executeQuery();
			while (rs.next()) {
				registrationId = rs.getInt(1);
				aor = (rs.getString(2)).trim();
				userName = (rs.getString(3)).trim();
				registration = new Registration();
				registration.setRegistrationID((new Integer(registrationId))
						.toString());
				registration.setAddressOfRecord(aor);
				registration.setUserName(userName);
			}
		} catch (Exception e) {
			logger.error(e.toString(), e);
			logger.error("Not able to create connections");
			throw e;
		} finally {
			try {
				if (rs != null) {
					rs.close();
				}
			} catch (SQLException e) {
				logger.error(e.toString(), e);
			}
			try {
				if (pstmt != null) {
					pstmt.close();
				}
			} catch (SQLException e) {
				logger.error(e.toString(), e);
			}
			try {
				if (connection != null) {
					connection.close();
				}
			} catch (SQLException e) {
				logger.error(e.toString(), e);
			}
		}
		return registration;
	}
	
	public ArrayList deleteExpiredRegistrations() throws SQLException, Exception	{
		ArrayList deletedRegistrations = new ArrayList();
		String queryExpiredContacts = "";
		//DataSource dataSource = null;
		Connection connection = null;
		Statement stmtOuter = null;
		Statement stmtInner = null;
		ResultSet rs = null;
		String contactAddress;
		String addressOfRecord;
		float priority;
		long contactId;
		long registrationId;
		String contactRegistrationId;
		long tempRegId =0;
		int expires;
		long insertionTime;
		long registeredDuration;
		Binding contact = null;
		Registration reg = null;
		int rowsAffected = 0;
		
		
		
		java.util.Date date = new java.util.Date();
		long currentSystemTime = (date.getTime())/1000;
		
		//String acquireLock = "LOCK TABLE BINDING,REGISTRATIONS IN EXCLUSIVE MODE";
		queryExpiredContacts ="SELECT a.registrationid,a.addressofrecord,b.contactid,"
							  + "b.contacturi,b.expires,b.priority,b.registrationid,"
							  +"b.insertiontime,b.displayname,b.unknownparam,b.state,b.event,b.reg_id,b.SIPINSTANCEID FROM reg_registrations a,"
							  +"reg_binding b WHERE (b.expires+b.insertiontime)<" 
							  + currentSystemTime +" AND a.registrationid=b.registrationid"
							  +" ORDER BY b.registrationid";
		
		try	{

			//dataSource=(DataSource)ctx.lookup("com.baypackets.registrar");
			connection = regDataSource.getConnection();
			if(connection == null)
			{
				logger.error("deleteExpiredRegistrations()::could not get connections");
				return null;
			}
			connection.setAutoCommit(false);
			stmtOuter = connection.createStatement();
			stmtInner = connection.createStatement();
			rs = stmtOuter.executeQuery(queryExpiredContacts);
			while(rs!=null && rs.next())	{
				registrationId = rs.getLong(1);
				addressOfRecord = (rs.getString(2)).trim();
				//create Registration object, one for each distinct registration-id
				if((tempRegId == 0)||(tempRegId!= registrationId))	{
				
					reg = new Registration();
					reg.setRegistrationID((new Long(registrationId)).toString());
					reg.setAddressOfRecord(addressOfRecord);
					deletedRegistrations.add(reg);
				}
				//store current value of registrationid to tempRegId
				tempRegId = registrationId;

				contactId = rs.getLong(3);
				contactAddress = (rs.getString(4)).trim();
				expires = rs.getInt(5);
				priority = rs.getFloat(6);
				contactRegistrationId = (rs.getString(7)).trim();
				insertionTime = rs.getLong(8);
				String displayName = (rs.getString(9));
				if (displayName != null)
					displayName = displayName.trim();
				String unknownParam = (rs.getString(10));
				if (unknownParam != null)
					unknownParam = unknownParam.trim();
				String state = (rs.getString(11));
				String event = (rs.getString(12));
				int reg_id = rs.getInt(13);
				String SipinstanceId = (rs.getString(14));
				contact = new Binding();
				contact.setBindingID((new Long(contactId)).toString());
				contact.setContactURI(contactAddress);
				contact.setDisplayName(displayName);
				contact.setUnknownParam(unknownParam);
				contact.setExpires(expires);
				contact.setPriority(priority);
				registeredDuration = (currentSystemTime - insertionTime);
				contact.setDurationRegistered(registeredDuration);
				contact.setEvent(event);
				contact.setState(state);
				contact.setReg_id(reg_id);
				contact.setSipinstanceId(SipinstanceId);
				if((new Long(contactRegistrationId)).compareTo(new Long(registrationId))== 0)	{
					//add this contact object to arraylist maintined by Registration object
					if(SipinstanceId!=null||!SipinstanceId.equals(""))
				 	{
						SipinstanceId=SipinstanceId.replaceAll("'", "''");
						addressOfRecord=addressOfRecord.replaceAll("'", "''");
				 		ResultSet res=stmtInner.executeQuery("select count(*) from reg_binding where sipinstanceid='"+SipinstanceId+"'and reg_binding.registrationid='"+contactRegistrationId+"'");
				 		while(res.next())
				 		{
				 			int count=res.getInt(1);
				 			if(count==1)
				 			{
				 				invalidateGRUU(connection, addressOfRecord, SipinstanceId,Integer.valueOf(contactRegistrationId));
				 			}
				 		}
				 		stmtInner.execute("delete from reg_binding where reg_binding.contactId='"+contact.getBindingID()+"' and reg_binding.registrationid='"+contactRegistrationId+"'");
				 	}
					reg.addContact(contact);
				}
				}
			// For remove temp gruu and counter if no row in binding has same sip instance id
			stmtOuter.execute("update reg_tempgruu set reg_tempgruu.IS_VALID='false' where reg_tempgruu.SIP_INSTANCE_ID not in (select reg_binding.SIPINSTANCEID from reg_binding)");
			stmtOuter.execute("delete from reg_temp_gruu_counter where  reg_temp_gruu_counter.SIP_INSTANCE_ID not in (select reg_binding.SIPINSTANCEID from reg_binding)");
			
			if(rs != null)	{
				rs.close();
			}
			connection.commit();
			//close DB related objects
			stmtOuter.close();
			stmtInner.close();
			//rs.close();
			connection.close();
		}catch(Exception e)	{
			logger.error(e.toString(),e);
			logger.error("Not able to create connections");
			throw e;
		}
		//Iterate over list of registration objects & delete entries from 
		//registration table for matching registrationid
		return deletedRegistrations;
	}
	
	
	public LinkedHashMap<String, String> getPAssociatedURI(
			String addressOfRecord) throws SQLException, Exception {
		LinkedHashMap<String, String> pAssociatedUri = new LinkedHashMap<String, String>();

		Connection connection = null;
		PreparedStatement pstmt = null;
		ResultSet rs = null;
		addressOfRecord = addressOfRecord.replaceAll("'", "''");
		try {
			connection = regDataSource.getConnection();
			if (connection == null) {
				logger.error("getPAssociatedURI()::could not get connection");
				return null;
			}
			connection.setAutoCommit(false);
			String select_Query = "select P_ASSOCIATED_URI, r.registrationid from reg_passociateduri p, reg_registrations r where p.AOR =? and p.p_associated_uri= r.addressofrecord and r.is_public='false' ORDER BY ORDER_OF_PASSOCIATED_URIS ASC";
			pstmt = connection.prepareStatement(select_Query);
			pstmt.setString(1, addressOfRecord);
			logger.debug("SELECT QUERY for P_ASSOCIATED_URI ===>"
					+ select_Query);
			rs = pstmt.executeQuery();

			while (rs != null && rs.next()) {
				pAssociatedUri.put((rs.getString("P_ASSOCIATED_URI")).trim(),
						(rs.getString("Registrationid")).trim());
			}
			connection.commit();
		} catch (Exception exp) {
			logger.error(exp.toString(), exp);
		} finally {
			try {
				if (rs != null) {
					rs.close();
				}
			} catch (SQLException e) {
				logger.error(e.toString(), e);
			}
			try {
				if (pstmt != null) {
					pstmt.close();
				}
			} catch (SQLException e) {
				logger.error(e.toString(), e);
			}
			try {
				if (connection != null) {
					connection.close();
				}
			} catch (SQLException e) {
				logger.error(e.toString(), e);
			}
		}

		return pAssociatedUri;
	}
	

	public ArrayList getServiceRoute(String addressOfRecord)
			throws SQLException, Exception {
		ArrayList serviceRoute = new ArrayList();

		Connection connection = null;
		PreparedStatement pstmt = null;
		ResultSet rs = null;
		addressOfRecord = addressOfRecord.replaceAll("'", "''");
		try {
			connection = regDataSource.getConnection();
			if (connection == null) {
				logger.error("getServiceRoute()::could not get connections");
				return null;
			}
			connection.setAutoCommit(false);
			String select_Query = "select SERVICE_ROUTE from reg_serviceroute where AOR = ? ORDER BY ORDER_OF_SERVICE_ROUTES ASC";
			pstmt = connection.prepareStatement(select_Query);
			pstmt.setString(1, addressOfRecord);

			logger.debug("SELECT QUERY for Service-Route ===>" + select_Query);
			rs = pstmt.executeQuery();
			int i = 0;
			while (rs != null && rs.next()) {
				serviceRoute.add((rs.getString("SERVICE_ROUTE")).trim());
				logger.debug("Service-Route ==" + serviceRoute.get(i));
				i++;
			}

			connection.commit();
		} catch (Exception exp) {
			logger.error(exp.toString(), exp);
		} finally {
			try {
				if (rs != null) {
					rs.close();
				}
			} catch (SQLException e) {
				logger.error(e.toString(), e);
			}
			try {
				if (pstmt != null) {
					pstmt.close();
				}
			} catch (SQLException e) {
				logger.error(e.toString(), e);
			}
			try {
				if (connection != null) {
					connection.close();
				}
			} catch (SQLException e) {
				logger.error(e.toString(), e);
			}
		}

		return serviceRoute;
	}

	public ArrayList getValidDomains() throws SQLException, Exception {
		ArrayList validDomains = new ArrayList();

		Connection connection = null;
		PreparedStatement pstmt = null;
		ResultSet rs = null;
		try {
			connection = regDataSource.getConnection();
			if (connection == null) {
				logger.error("getValidDomains():: could not get connections");
				return null;
			}
			String select_Query = "select DOMAIN from reg_validdomains ";
			logger.debug("SELECT QUERY for ValidDomains ===>" + select_Query);
			pstmt = connection.prepareStatement(select_Query);
			rs = pstmt.executeQuery();
			int i = 0;
			while (rs != null && rs.next()) {
				validDomains.add((rs.getString(1)).trim());
				logger.debug("Valid-Domains ==" + validDomains.get(i));
				i++;
			}
		} catch (Exception exp) {
			logger.error(exp.toString(), exp);
			throw exp;
		} finally {
			try {
				if (rs != null) {
					rs.close();
				}
			} catch (SQLException e) {
				logger.error(e.toString(), e);
			}
			try {
				if (pstmt != null) {
					pstmt.close();
				}
			} catch (SQLException e) {
				logger.error(e.toString(), e);
			}
			try {
				if (connection != null) {
					connection.close();
				}
			} catch (SQLException e) {
				logger.error(e.toString(), e);
			}
		}

		return validDomains;
	}



	public String getUserName(String addressOfRecord) throws SQLException,
	Exception {
		Connection connection = null;
		PreparedStatement pstmt = null;
		ResultSet rs = null;
		String sqlQuery;
		String user = "";
		addressOfRecord = addressOfRecord.replaceAll("'", "''");
		logger.debug("Inside getUserName() of BindingsDAOImpl");

		try {
			connection = regDataSource.getConnection();
			if (connection == null) {
				logger.error("getUserName()::couldnot get connection");
				return null;
			}
			logger.debug("BindingsDAOImpl::getUserName(), Connection: "
					+ connection.toString());
			sqlQuery = "SELECT a.USERNAME FROM reg_registrations a WHERE a.ADDRESSOFRECORD=? AND a.IS_PUBLIC='true'";
			pstmt = connection.prepareStatement(sqlQuery);
			pstmt.setString(1, addressOfRecord);
			logger.debug("BindingsDAOImpl::getUserName(), Going to select data from REGISTRATIONS table: ");
			rs = pstmt.executeQuery();
			while (rs.next()) {
				user = new String((rs.getString(1)).trim());
			}
		} catch (Exception e) {
			logger.error(e.toString(), e);
			logger.error("Not able to create connections");
			throw e;
		} finally {
			try {
				if (rs != null) {
					rs.close();
				}
			} catch (SQLException e) {
				logger.error(e.toString(), e);
			}
			try {
				if (pstmt != null) {
					pstmt.close();
				}
			} catch (SQLException e) {
				logger.error(e.toString(), e);
			}
			try {
				if (connection != null) {
					connection.close();
				}
			} catch (SQLException e) {
				logger.error(e.toString(), e);
			}
		}
		return user;
	}

	//BpInd 185961
	
	/** adds registration into the database and returns false when addition was not successful */
	public boolean addRegistration(Registration regObj) throws SQLException,
	Exception {
		Connection connection = null;
		PreparedStatement pstmt = null;
		String sqlQuery;
		String addressofrecord = regObj.getAddressOfRecord();
		if (addressofrecord == null) {
			return false;
		}
		addressofrecord = addressofrecord.replaceAll("'", "''");
		String user = regObj.getUserName();
		if (user != null) {
			user = user.replaceAll("'", "''");
		}
		logger.debug("Inside addRegistration() of BindingsDAOImpl");
		try {
			connection = regDataSource.getConnection();
			if (connection == null) {
				logger.error("addRegistration()::couldnot get connection");
				return false;
			}
			logger.debug("BindingsDAOImpl::addResgistration(), Connection: "
					+ connection.toString());
			sqlQuery = "INSERT INTO reg_registrations (REGISTRATIONID,ADDRESSOFRECORD,USERNAME,IS_PUBLIC) VALUES(?,?,?,'true')";
			pstmt = connection.prepareStatement(sqlQuery);
			pstmt.setString(1, regObj.getRegistrationID());
			pstmt.setString(2, addressofrecord);
			pstmt.setString(3, user);
			logger.debug("BindingsDAOImpl::addRegistration(), Going to insert data into REGISTRATIONS table: ");
			pstmt.executeUpdate();
		} catch (Exception e) {
			logger.error(e.toString(), e);
			logger.error("Not able to create connections");
			throw e;
		} finally {
			try {
				if (pstmt != null) {
					pstmt.close();
				}
			} catch (SQLException e) {
				logger.error(e.toString(), e);
			}
			try {
				if (connection != null) {
					connection.close();
				}
			} catch (SQLException e) {
				logger.error(e.toString(), e);
			}
		}
		return true;
	}

	
	public boolean modifyRegistration(Registration regObj) throws SQLException,
	Exception {
		Connection connection = null;
		PreparedStatement pstmt = null;
		String sqlQuery;
		String addressofrecord = regObj.getAddressOfRecord();
		if (addressofrecord != null) {
			addressofrecord = addressofrecord.replaceAll("'", "''");
		}
		String user = regObj.getUserName();
		if (user != null) {
			user = user.replaceAll("'", "''");
		}
		logger.debug("Inside modifyRegistration() of BindingsDAOImpl");

		try {
			connection = regDataSource.getConnection();
			if (connection == null) {
				logger.error("modifyRegistration()::couldnot get connection");
				return false;
			}
			logger.debug("BindingsDAOImpl::modifyResgistration(), Connection: "
					+ connection.toString());
			sqlQuery = "UPDATE reg_registrations SET ADDRESSOFRECORD=?,USERNAME=? WHERE REGISTRATIONID=?";
			pstmt = connection.prepareStatement(sqlQuery);
			pstmt.setString(1, addressofrecord);
			pstmt.setString(2, user);
			pstmt.setString(2, regObj.getRegistrationID());
			logger.debug("BindingsDAOImpl::modifyRegistration(), Going to insert data into REGISTRATIONS table: ");
			pstmt.executeUpdate();
		} catch (Exception e) {
			logger.error(e.toString(), e);
			logger.error("Not able to create connections");
			throw e;
		} finally {
			try {
				if (pstmt != null) {
					pstmt.close();
				}
			} catch (SQLException e) {
				logger.error(e.toString(), e);
			}
			try {
				if (connection != null) {
					connection.close();
				}
			} catch (SQLException e) {
				logger.error(e.toString(), e);
			}
		}
		return true;
	}

	
	public boolean deleteRegistration(String aor) throws SQLException, Exception	{
		if (aor == null) {
			logger.debug("deleteRegistration()exit: for null aor");
			return false;
		}
		Connection connection = null;
		Statement stmt = null;
		String sqlQuery;
		aor=aor.replaceAll("'", "''");
		logger.debug("Inside deleteRegistration() of BindingsDAOImpl");

		//first remove the bindings that are associated 
		ArrayList removeBindings = getBindingsFor(aor);
		persist(null,null,removeBindings,aor);
		
		//now delete the registration
		sqlQuery = "DELETE FROM reg_registrations WHERE ADDRESSOFRECORD='"+aor+"'"  ;
		
		try	{

			//DataSource regDataSource=(DataSource)ctx.lookup("com.baypackets.registrar");
			connection=regDataSource.getConnection();
			if(connection==null)
			{
				logger.error("deleteRegistration()::couldnot get connection");
				return false;
			}
			logger.debug("BindingsDAOImpl::deleteResgistration(), Connection: " + connection.toString());
			stmt = connection.createStatement();
			logger.debug("BindingsDAOImpl::deleteRegistration(), Going to insert data into REGISTRATIONS table: ");
			int result = stmt.executeUpdate(sqlQuery);

			//close DB related objects
			stmt.close();
			connection.close();

		}catch(Exception e)	{
			logger.error(e.toString(),e);
			logger.error("Not able to create connections");
			throw e;
		}
		return true;
	}


	public boolean addDomain(String domain) throws SQLException, Exception	{
		Connection connection = null;
		Statement stmt = null;
		String sqlQuery;
		if (domain == null) {
			logger.debug("addDomain()exit: for null domain");
			return false;
		}
		domain=domain.replaceAll("'", "''");
		logger.debug("Inside addDomain() of BindingsDAOImpl");
		sqlQuery = "INSERT INTO reg_validdomains VALUES('"+domain+"')" ;
		
		try	{

			//DataSource regDataSource=(DataSource)ctx.lookup("com.baypackets.registrar");
			connection=regDataSource.getConnection();
			if(connection==null)
			{
				logger.error("addDomain()::couldnot get connection");
				return false;
			}
			logger.debug("BindingsDAOImpl::addDomain(), Connection: " + connection.toString());
			stmt = connection.createStatement();
			logger.debug("BindingsDAOImpl::addDomain(), Going to insert data into REGISTRATIONS table: ");
			int result = stmt.executeUpdate(sqlQuery);

			//close DB related objects
			stmt.close();
			connection.close();

		}catch(Exception e)	{
			logger.error(e.toString(),e);
			logger.error("Not able to create connections");
			throw e;
		}
		return true;
	}

	public boolean deleteDomain(String domain) throws SQLException, Exception	{
		Connection connection = null;
		Statement stmt = null;
		String sqlQuery;
		if (domain == null) {
			logger.debug("deleteDomain()exit: for null domain");
			return false;
		}
		domain=domain.replaceAll("'", "''");
		logger.debug("Inside deleteDomain() of BindingsDAOImpl");

		sqlQuery = "DELETE FROM reg_validdomains WHERE DOMAIN='"+domain+"'"  ;
		
		try	{

			//DataSource regDataSource=(DataSource)ctx.lookup("com.baypackets.registrar");
			connection=regDataSource.getConnection();
			if(connection==null)
			{
				logger.error("deleteDomain()::couldnot get connection");
				return false;
			}
			logger.debug("BindingsDAOImpl::deleteDomain(), Connection: " + connection.toString());
			stmt = connection.createStatement();
			logger.debug("BindingsDAOImpl::deleteDomain(), Going to insert data into REGISTRATIONS table: ");
			int result = stmt.executeUpdate(sqlQuery);

			//close DB related objects
			stmt.close();
			connection.close();

		}catch(Exception e)	{
			logger.error(e.toString(),e);
			logger.error("Not able to create connections");
			throw e;
		}
		return true;
	}


	public boolean addAuthorization(String aor , String authorizeAddr) throws SQLException, Exception	{
		
		if (aor == null || authorizeAddr == null) {
			logger.debug("addAuthorization()exit: for null aor/authorizeAddr");
			return false;
		}
		Connection connection = null;
		Statement stmt = null;
		String sqlQuery;		
		aor=aor.replaceAll("'", "''");
		authorizeAddr=authorizeAddr.replaceAll("'", "''");
		logger.debug("Inside addAuthorization() of BindingsDAOImpl");
		sqlQuery = "INSERT INTO reg_authorizations (ADDRESSOFRECORD,AUTHORIZEADDRESS) VALUES('"+aor+"','"+authorizeAddr+"')" ;
		
		try	{

			//DataSource regDataSource=(DataSource)ctx.lookup("com.baypackets.registrar");
			connection=regDataSource.getConnection();
			if(connection==null)
			{
				logger.error("addAuthorization()::couldnot get connection");
				return false;
			}
			logger.debug("BindingsDAOImpl::addAuthorization(), Connection: " + connection.toString());
			stmt = connection.createStatement();
			logger.debug("BindingsDAOImpl::addAuthorization(), Going to insert data into REGISTRATIONS table: ");
			int result = stmt.executeUpdate(sqlQuery);

			//close DB related objects
			stmt.close();
			connection.close();

		}catch(Exception e)	{
			logger.error(e.toString(),e);
			logger.error("Not able to create connections");
			throw e;
		}
		return true;
	}


	public boolean deleteAuthorization(String aor) throws SQLException, Exception		{
		
		if (aor == null) {
			logger.debug("deleteAuthorization()exit: for null aor");
			return false;
		}		
		Connection connection = null;
		Statement stmt = null;
		String sqlQuery;		
		aor=aor.replaceAll("'", "''");
		logger.debug("Inside deleteAuthorization() of BindingsDAOImpl");

		sqlQuery = "DELETE FROM reg_authorizations WHERE ADDRESSOFRECORD='"+aor+"'"  ;
		
		try	{

			//DataSource regDataSource=(DataSource)ctx.lookup("com.baypackets.registrar");
			connection=regDataSource.getConnection();
			if(connection==null)
			{
				logger.error("deleteAuthorization()::couldnot get connection");
				return false;
			}
			logger.debug("BindingsDAOImpl::deleteAuthorization(), Connection: " + connection.toString());
			stmt = connection.createStatement();
			logger.debug("BindingsDAOImpl::deleteAuthorization(), Going to insert data into REGISTRATIONS table: ");
			int result = stmt.executeUpdate(sqlQuery);

			//close DB related objects
			stmt.close();
			connection.close();

		}catch(Exception e)	{
			logger.error(e.toString(),e);
			logger.error("Not able to create connections");
			throw e;
		}
		return true;
	}

	public boolean addServiceRoute(String id,String aor,String serviceRoute,String order) throws SQLException, Exception	{
		Connection connection = null;
		Statement stmt = null;
		String sqlQuery;
		if (aor == null || serviceRoute == null) {
			logger.debug("addServiceRoute()exit: for null aor/serviceRoute");
			return false;
		}
		serviceRoute=serviceRoute.replaceAll("'", "''");
		aor=aor.replaceAll("'", "''");

		logger.debug("Inside addServiceRoute() of BindingsDAOImpl");
		sqlQuery = "INSERT INTO reg_serviceroute (SERVICEROUTE_ID,AOR,SERVICE_ROUTE,ORDER_OF_SERVICE_ROUTES) VALUES('"+id+"','"+aor+"','"+serviceRoute+"','"+order+"')" ;	
		try	{

			//DataSource regDataSource=(DataSource)ctx.lookup("com.baypackets.registrar");
			connection=regDataSource.getConnection();
			if(connection==null)
			{
				logger.error("addServiceRoute()::couldnot get connection");
				return false;
			}
			logger.debug("BindingsDAOImpl::addServiceRoute(), Connection: " + connection.toString());
			stmt = connection.createStatement();
			logger.debug("BindingsDAOImpl::addServiceRoute(), Going to insert data into REGISTRATIONS table: ");
			int result = stmt.executeUpdate(sqlQuery);

			//close DB related objects
			stmt.close();
			connection.close();

		}catch(Exception e)	{
			logger.error(e.toString(),e);
			logger.error("Not able to create connections");
			throw e;
		}
		return true;
	}


	public boolean deleteServiceRoute(String aor) throws SQLException, Exception		{
		
		if (aor == null ) {
			logger.debug("deleteServiceRoute()exit: for null aor");
			return false;
		}
		
		Connection connection = null;
		Statement stmt = null;
		String sqlQuery;
		
		aor=aor.replaceAll("'", "''");
		logger.debug("Inside deleteServiceRoute() of BindingsDAOImpl");

		sqlQuery = "DELETE FROM reg_serviceroute WHERE AOR='"+aor+"'"  ;
		
		try	{

			//DataSource regDataSource=(DataSource)ctx.lookup("com.baypackets.registrar");
			connection=regDataSource.getConnection();
			if(connection==null)
			{
				logger.error("deleteServiceRoute()::couldnot get connection");
				return false;
			}
			logger.debug("BindingsDAOImpl::deleteServiceRoute(), Connection: " + connection.toString());
			stmt = connection.createStatement();
			logger.debug("BindingsDAOImpl::deleteServiceRoute(), Going to insert data into REGISTRATIONS table: ");
			int result = stmt.executeUpdate(sqlQuery);

			//close DB related objects
			stmt.close();
			connection.close();

		}catch(Exception e)	{
			logger.error(e.toString(),e);
			logger.error("Not able to create connections");
			throw e;
		}
		return true;
	}

	public boolean addPAssociatedURI(int id,String aor,String pAssociatedURI,int order) throws SQLException, Exception	{
		Connection connection = null;
		Statement stmt = null;
		String sqlQuery;
		if (aor == null || pAssociatedURI==null ) {
			logger.debug("addPAssociatedURI()exit: for null aor/pAssociatedURI");
			return false;
		}
		aor=aor.replaceAll("'", "''");
		pAssociatedURI=pAssociatedURI.replaceAll("'", "''");
		logger.debug("Inside addPAssociatedURI() of BindingsDAOImpl");
		sqlQuery = "INSERT INTO reg_passociateduri (P_ASSOCIATED_URI_ID,AOR,P_ASSOCIATED_URI,ORDER_OF_PASSOCIATED_URIS) VALUES('"+id+"','"+aor+"','"+pAssociatedURI+"','"+order+"')" ;	
		try	{

			//DataSource regDataSource=(DataSource)ctx.lookup("com.baypackets.registrar");
			connection=regDataSource.getConnection();
			if(connection==null)
			{
				logger.error("addPAssociatedURI()::couldnot get connection");
				return false;
			}
			logger.debug("BindingsDAOImpl::addPAssociatedURI(), Connection: " + connection.toString());
			stmt = connection.createStatement();
			logger.debug("BindingsDAOImpl::addPAssociatedURI(), Going to insert data into REGISTRATIONS table: ");
			int result = stmt.executeUpdate(sqlQuery);

			//close DB related objects
			stmt.close();
			connection.close();

		}catch(Exception e)	{
			logger.error(e.toString(),e);
			logger.error("Not able to create connections");
			throw e;
		}
		return true;
	}


	public boolean deletePAssociatedURI(String aor) throws SQLException, Exception		{
		
		if (aor == null) {
			logger.debug("deletePAssociatedURI()exit: for null aor");
			return false;
		}
		Connection connection = null;
		Statement stmt = null;
		String sqlQuery;
		aor=aor.replaceAll("'", "''");
		logger.debug("Inside deletePAssociatedURI() of BindingsDAOImpl");

		sqlQuery = "DELETE FROM reg_passociateduri WHERE AOR='"+aor+"'"  ;
		
		try	{

			//DataSource regDataSource=(DataSource)ctx.lookup("com.baypackets.registrar");
			connection=regDataSource.getConnection();
			if(connection==null)
			{
				logger.error("deletePAssociatedURI()::couldnot get connection");
				return false;
			}
			logger.debug("BindingsDAOImpl::deletePAssociatedURI(), Connection: " + connection.toString());
			stmt = connection.createStatement();
			logger.debug("BindingsDAOImpl::deletePAssociatedURI(), Going to insert data into REGISTRATIONS table: ");
			int result = stmt.executeUpdate(sqlQuery);

			//close DB related objects
			stmt.close();
			connection.close();

		}catch(Exception e)	{
			logger.error(e.toString(),e);
			logger.error("Not able to create connections");
			throw e;
		}
		return true;
	}

	
	@Override
	/**
	 * This method returns latest created Temp GRUU for the AOR and +sipInstanceId  
	 *
	 * @return value of TEMPGRUU ( String )
	 */
	
	public String getTempGRUU(String sipInstanceId, String addressOfRecord)
			throws SQLException, Exception {
		logger.debug("TEMP GRUU FATCH =============> started");
		Connection conn = null;
		ResultSet rset = null;
		PreparedStatement pstmt = null;
		String aor = addressOfRecord.replaceAll("'", "''");
		sipInstanceId = sipInstanceId.replaceAll("'", "''");
		String tempgruu = null;

		try {
			conn = regDataSource.getConnection();

			if (conn == null) {
				logger.error("There are no gruu for " + addressOfRecord);
				return tempgruu;
			}

			pstmt = conn.prepareStatement("select GRUU_URI from reg_tempgruu where reg_tempgruu.REGISTRATIONID in (select REGISTRATIONID from reg_registrations where ADDRESSOFRECORD=?) and reg_tempgruu.SIP_INSTANCE_ID=? and reg_tempgruu.IS_VALID='true' and INSERTIONTIME=(select max(INSERTIONTIME) from reg_tempgruu where reg_tempgruu.REGISTRATIONID in (select REGISTRATIONID from reg_registrations where ADDRESSOFRECORD=?) and reg_tempgruu.SIP_INSTANCE_ID=? and reg_tempgruu.IS_VALID='true')");
			pstmt.setString(1, aor);
			pstmt.setString(2, sipInstanceId);
			pstmt.setString(3, aor);
			pstmt.setString(4, sipInstanceId);
			rset = pstmt.executeQuery();
			while (rset.next()) {
				tempgruu = (rset.getString("GRUU_URI")).trim();
			}
		} catch (SQLException sqle) {
			logger.error(sqle.toString(), sqle);
			throw sqle;
		} catch (Exception ioe) {
			logger.error(ioe.toString(), ioe);
			throw ioe;
		} finally {
			try {
				if (rset != null) {
					rset.close();
				}
			} catch (SQLException e) {
				logger.error(e.toString(), e);
			}
			try {
				if (pstmt != null) {
					pstmt.close();
				}
			} catch (SQLException e) {
				logger.error(e.toString(), e);
			}
			try {
				if (conn != null) {
					conn.close();
				}
			} catch (SQLException e) {
				logger.error(e.toString(), e);
			}
		}
		logger.debug("TEMP GRUU FATCHED =============>" + tempgruu);
		return tempgruu;
	}
	
	@Override
	/**
	 * This method returns list of GRUU Temp GRUU for the AOR 
	 *
	 * @return value of temgruuList ( ArrayList<String> )
	 */
	
	public ArrayList getTempGRUUListFor(String addressOfRecord)
			throws SQLException, Exception {
		Connection conn = null;
		ResultSet rset = null;
		PreparedStatement pstmt = null;		
		String aor = addressOfRecord.replaceAll("'", "''");
		ArrayList<String> temgruuList = new ArrayList<String>();

		try {
			conn = regDataSource.getConnection();

			if (conn == null) {
				logger.error("There are no gruu for " + addressOfRecord);
				return temgruuList;
			}
			pstmt = conn
					.prepareStatement("select GRUU_URI from reg_tempgruu where reg_tempgruu.REGISTRATIONID in (select REGISTRATIONID from reg_registrations where ADDRESSOFRECORD=?) and reg_tempgruu.IS_VALID='true'");
			pstmt.setString(1, aor);
			rset = pstmt.executeQuery();

			while (rset.next()) {
				String gruuURI = rset.getString("GRUU_URI");
				temgruuList.add(gruuURI.trim());
			}
		} catch (SQLException sqle) {
			logger.error(sqle.toString(), sqle);
			throw sqle;
		} catch (Exception ioe) {
			logger.error(ioe.toString(), ioe);
			throw ioe;
		} finally {
			try {
				if (rset != null) {
					rset.close();
				}
			} catch (SQLException e) {
				logger.error(e.toString(), e);
			}
			try {
				if (pstmt != null) {
					pstmt.close();
				}
			} catch (SQLException e) {
				logger.error(e.toString(), e);
			}
			try {
				if (conn != null) {
					conn.close();
				}
			} catch (SQLException e) {
				logger.error(e.toString(), e);
			}
		}
		logger.debug("TEMP GRUU LIST FATCHED =============>" + temgruuList);
		return temgruuList;
	}

//	@Override
//	/**
//	 * This method returns list of used contactId
//	 *
//	 * @return value of contactIdList ( ArrayList<Integer> )
//	 */
//	
//	public ArrayList getcontactIdList() throws SQLException, Exception {
//		logger.debug("ContactIdList FATCH start =============>");
//		Connection conn = null;
//		ResultSet rset = null;
//		PreparedStatement pstmt = null;
//		ArrayList<Integer> contactIdList = new ArrayList<Integer>();
//		try {
//			conn = regDataSource.getConnection();
//			if (conn == null) {
//				logger.error("There are no contact id's in db");
//				return contactIdList;
//			}
//			pstmt = conn.prepareStatement("select CONTACTID from reg_binding");
//			rset = pstmt.executeQuery();
//			while (rset.next()) {
//				int id = rset.getInt("CONTACTID");
//				contactIdList.add(new Integer(id));
//			}
//		} catch (SQLException sqle) {
//			logger.error(sqle.toString(), sqle);
//			throw sqle;
//		} catch (Exception ioe) {
//			logger.error(ioe.toString(), ioe);
//			throw ioe;
//		} finally {
//			try {
//				if (rset != null) {
//					rset.close();
//				}
//			} catch (SQLException e) {
//				logger.error(e.toString(), e);
//			}
//			try {
//				if (pstmt != null) {
//					pstmt.close();
//				}
//			} catch (SQLException e) {
//				logger.error(e.toString(), e);
//			}
//			try {
//				if (conn != null) {
//					conn.close();
//				}
//			} catch (SQLException e) {
//				logger.error(e.toString(), e);
//			}
//		}
//		logger.debug("ContactIdList FATCHED =============>" + contactIdList);
//		return contactIdList;
//	}

	
	@Override
	/**
	 * This method returns I, KA and KE from database Corresponding to max value of I in database
	 */
	
	
	public ArrayList getMaxIdRow() throws SQLException, Exception {
		logger.debug("Counter Row FATCH start =============>");
		Connection conn = null;
		ResultSet rset = null;
		Statement stmt = null;
		ArrayList row = new ArrayList();
		try {
			//DataSource regDataSource = (DataSource) ctx
				//	.lookup("com.baypackets.registrar");
			conn = regDataSource.getConnection();
			if (conn == null) {
				logger.error("There are no contact id's in db");
				return row;
			}
			stmt = conn.createStatement();
			rset = stmt
					.executeQuery("select COUNTER,KA,KE from reg_temp_gruu_counter where COUNTER=(select max(COUNTER) from reg_temp_gruu_counter)");
		} catch (Exception e) {
			logger.error(e.toString(), e);
			// BPInd
			throw e;
		}
		try {

			while (rset.next()) {
				long I = rset.getLong(1);
				row.add(I);											// Add Counter to ArrayList
				String Ka = rset.getString(2).trim();
				String temp[] = Ka.split(",");
				byte Ka_byte[] = new byte[temp.length];
				for (int j = 0; j < Ka_byte.length; j++) {
					Ka_byte[j] = new Byte(temp[j]);
				}
				row.add(new SecretKeySpec(Ka_byte, "HMACSHA256"));	// Add Ka to ArrayList
				String Ke = rset.getString(3).trim();
				temp = Ke.split(",");
				byte Ke_byte[] = new byte[temp.length];
				for (int j = 0; j < Ke_byte.length; j++) {
					Ke_byte[j] = new Byte(temp[j]);
				}
				row.add(new SecretKeySpec(Ke_byte, "AES"));			// Add Ke to ArrayList
			}
			rset.close();
			stmt.close();
			conn.close();
		} catch (SQLException sqle) {
			logger.error(sqle.toString(), sqle);
			throw sqle;
		} catch (Exception ioe) {
			logger.error(ioe.toString(), ioe);
			throw ioe;
		}
		logger.debug("Counter Row FATCHED =============>" + row);
		return row;
	}
	
	/*
	 * Reason for using two statement objects,
	 * 
	 * By default, only one ResultSet object per Statement object can be open at
	 * the same time. Therefore, if the reading of one ResultSet object is
	 * interleaved with the reading of another, each must have been generated by
	 * different Statement objects. All execution methods in the Statement
	 * interface implicitly close a statment's current ResultSet object if an
	 * open one exists.
	 * 
	 * 	 
	 * This method invalidates tempGRUU and delete counter from reg_temp_gruu_counter table 
	 * for an AOR and its Associated AORs	 
	 */
	
	
	private void invalidateGRUU(Connection conn,String aor,String sipinstance,int registrationId) throws SQLException,Exception
	{
		Statement stmtOuter=conn.createStatement();
		Statement stmtInner=conn.createStatement();
		logger.debug("invalidateGRUU(): called.....");
			stmtOuter.execute("update reg_tempgruu set reg_tempgruu.IS_VALID='false' where reg_tempgruu.SIP_INSTANCE_ID='"+sipinstance+"' and reg_tempgruu.REGISTRATIONID='"+registrationId+"'");
			stmtOuter.execute("delete from reg_temp_gruu_counter where REGISTRATIONID='"+registrationId+"' AND SIP_INSTANCE_ID='"+sipinstance+"'");
			ResultSet res=stmtOuter.executeQuery("select r.REGISTRATIONID from reg_registrations r, reg_passociateduri p where p.aor='"+aor+"'and p.P_ASSOCIATED_URI=r.ADDRESSOFRECORD and r.is_public='false'");			
			while(res.next())
			{
				int p_regId=res.getInt(1);
				stmtInner.execute("update reg_tempgruu set reg_tempgruu.IS_VALID='false' where reg_tempgruu.SIP_INSTANCE_ID='"+sipinstance+"' and reg_tempgruu.REGISTRATIONID='"+p_regId+"'");
				stmtInner.execute("delete from reg_temp_gruu_counter where REGISTRATIONID='"+p_regId+"' AND SIP_INSTANCE_ID='"+sipinstance+"'");				
			}
			stmtOuter.close();
			stmtInner.close();
			logger.debug("invalidateGRUU(): exit.....");
	}
	

	/* 
	 * This method creates and inserts pubGRUU and tempGRUU for an AOR and its
	 * Associated AORs
	 */
	
	private void insertGRUU(Connection conn,String aor,String sipinstance,String pubgruu,int registrationId,long inserttime) throws SQLException,Exception
	{
		logger.debug("insertGRUU(): called.....Aor " +aor +" sipinstance "+sipinstance +" pubgruu "+pubgruu +" registrationId "+registrationId);
							
		logger.debug("Creating temp gruu and inserting");
		GRUUConstructionUtility constructgruu=new GRUUConstructionUtility();
		TempGruuAlgoritm tga=constructgruu.createTempGruu();
		String tempgruu=tga.getTempGruu();
		Statement stmtOuter=conn.createStatement();
		Statement stmtInner=conn.createStatement();
		Statement tmpStmt=conn.createStatement();
		stmtOuter.execute("insert into reg_tempgruu (GRUU_URI,REGISTRATIONID,SIP_INSTANCE_ID,IS_VALID,INSERTIONTIME) values('"+tempgruu+"','"+registrationId+"','"+sipinstance+"','true','"+inserttime+"')");
		stmtOuter.execute("INSERT INTO reg_temp_gruu_counter(COUNTER, KA, KE,REGISTRATIONID, SIP_INSTANCE_ID) VALUES('"+tga.getCounter()+"','"+tga.getKa_String()+"','"+tga.getKe_String()+"','"+registrationId+"','"+sipinstance+"')" );
		
		ResultSet resultSetOuter=stmtOuter.executeQuery("select count(*) from reg_pubgruu where SIP_INSTANCE_ID='"+sipinstance+"' and REGISTRATIONID='"+registrationId+"'");
		while(resultSetOuter.next())
 		{
 			int count=resultSetOuter.getInt(1);
 			if(count==0)
 			{	
 				logger.debug("insert sipinstance into database !!!!");
 				tmpStmt.execute("insert into reg_pubgruu (GRUU_URI,REGISTRATIONID,SIP_INSTANCE_ID) values('"+pubgruu+"','"+registrationId+"','"+sipinstance+"')");
 			
 			}
 		}
		
		resultSetOuter=stmtOuter.executeQuery("select r.REGISTRATIONID, r.addressofrecord from reg_registrations r, reg_passociateduri p where p.aor='"+aor+"'and p.P_ASSOCIATED_URI=r.ADDRESSOFRECORD and r.is_public='false'");
			while(resultSetOuter.next())
			{
				int reg_ID=resultSetOuter.getInt("REGISTRATIONID");
				String p_aor=(resultSetOuter.getString("addressofrecord")).trim();
				tga=constructgruu.createTempGruu();
				tempgruu=tga.getTempGruu();
				stmtInner.execute("insert into reg_tempgruu (GRUU_URI,REGISTRATIONID,SIP_INSTANCE_ID,IS_VALID,INSERTIONTIME) values('"+tempgruu+"','"+reg_ID+"','"+sipinstance+"','true','"+inserttime+"')");
				stmtInner.execute("INSERT INTO reg_temp_gruu_counter(COUNTER, KA, KE,REGISTRATIONID, SIP_INSTANCE_ID) VALUES('"+tga.getCounter()+"','"+tga.getKa_String()+"','"+tga.getKe_String()+"','"+reg_ID+"','"+sipinstance+"')" );
				ResultSet resultSetInner=stmtInner.executeQuery("select count(*) from reg_pubgruu where SIP_INSTANCE_ID='"+sipinstance+"' and REGISTRATIONID='"+reg_ID+"'");
				while(resultSetInner.next())
		 		{
		 			int count=resultSetInner.getInt(1);
		 			if(count==0)
		 			{
		 				p_aor=p_aor.replaceAll("'", "''");
		 				String p_pubgruu=constructgruu.createPublicGruu(p_aor, sipinstance);		 				
		 				stmtInner.execute("insert into reg_pubgruu (GRUU_URI,REGISTRATIONID,SIP_INSTANCE_ID) values('"+p_pubgruu+"','"+reg_ID+"','"+sipinstance+"')");	
		 			}
		 		}
			}
			
			stmtOuter.close();
			stmtInner.close();
			tmpStmt.close();
		logger.debug("insertGRUU(): exit.....");		
	}


	@Override
	public boolean addPresenceData(Presence presence) throws SQLException,Exception {
		if(logger.isDebugEnabled())
			logger.debug("addPresenceData(): called.....");
		boolean isAdded=false;
		if(presence!=null){
			Connection connection=null;
			PreparedStatement presenceStatement=null;
			PreparedStatement tupleStatement=null;
			PreparedStatement personStatement=null;
			try	{
				connection=regDataSource.getConnection();
				if(connection==null)
				{
					logger.error("addPresenceData()::couldnot get connection");
					return false;
				}
				connection.setAutoCommit(false);
				String presenceQuery="INSERT INTO reg_presence(SIPIFTAG, ENTITY, EXPIRES, TIME_STAMP, NOTE_VAL, NOTE_LANG) VALUES (?,?,?,?,?,?)";



				String noteLang=presence.getNote()!=null?presence.getNote().getLang():null;
				String noteVal=presence.getNote()!=null?presence.getNote().getValue():null;

				presenceStatement=connection.prepareStatement(presenceQuery);
				presenceStatement.setString(1, presence.getSipIfTag());
				presenceStatement.setString(2, presence.getEntity());
				presenceStatement.setInt(3, presence.getExpires());
				presenceStatement.setLong(4, System.currentTimeMillis());
				presenceStatement.setString(5, noteVal);
				presenceStatement.setString(6, noteLang);
				presenceStatement.execute();

				List<Tuple> tupleList=presence.getTupleList();
				if(tupleList!=null && tupleList.size()!=0){
					String tupleQuery="INSERT INTO reg_tuple(SIPIFTAG, TUPLE_ID, BASIC, NOTE_VAL, NOTE_LANG) VALUES (?,?,?,?,?)";
					tupleStatement=connection.prepareStatement(tupleQuery);
					for(Tuple t:tupleList){
						noteLang=t.getNote()!=null?t.getNote().getLang():null;
						noteVal=t.getNote()!=null?t.getNote().getValue():null;
						tupleStatement.setString(1,presence.getSipIfTag());
						tupleStatement.setString(2, t.getTupleId());
						tupleStatement.setString(3, t.getBasic());
						tupleStatement.setString(4, noteVal);
						tupleStatement.setString(5, noteLang);
						tupleStatement.addBatch();
					}
					tupleStatement.execute();
				}

				List<Person> personList=presence.getPersonList();
				if(personList!=null && personList.size()!=0){
					String personQuery="INSERT INTO reg_person(SIPIFTAG, PERSON_ID, ACTIVITIES,ACTIVITIES_VAL, NOTE_VAL, NOTE_LANG) VALUES (?,?,?,?,?,?)";
					personStatement=connection.prepareStatement(personQuery);
					for(Person p:personList){
						noteLang=p.getNote()!=null?p.getNote().getLang():null;
						noteVal=p.getNote()!=null?p.getNote().getValue():null;
						personStatement.setString(1,presence.getSipIfTag());
						personStatement.setString(2, p.getPersonId());
						personStatement.setString(3, p.getActivities());
						personStatement.setString(4, p.getActivitiesVal());
						personStatement.setString(5, noteVal);
						personStatement.setString(6, noteLang);
						personStatement.addBatch();
					}
					personStatement.execute();
				}
				connection.commit();
				isAdded=true;
			}catch(Exception e)	{
				logger.error("Exception in addPresenceData():"+e.toString());
				throw e;
			}finally{
				if(presenceStatement!=null)
					presenceStatement.close();
				if(tupleStatement!=null)
					tupleStatement.close();
				if(personStatement!=null)
					personStatement.close();
				if(connection!=null)
					connection.close(); 
			}
		}
		if(logger.isDebugEnabled())
			logger.debug("addPresenceData(): exitting.....");
		return isAdded;
	}


	@Override
	public boolean updatePresenceData(Presence presence) throws SQLException,
			Exception {
		if(logger.isDebugEnabled())
			logger.debug("updatePresenceData(): called.....");
		boolean isUpdated=false;
		if(presence!=null){
			Connection connection=null;
			PreparedStatement presenceStatement=null;
			PreparedStatement tupleStatement=null;
			PreparedStatement tupleUpdateStatement=null;
			PreparedStatement personStatement=null;
			PreparedStatement personUpdateStatement=null;
			try	{
				connection=regDataSource.getConnection();
				if(connection==null)
				{
					logger.error("updatePresenceData()::couldnot get connection");
					return false;
				}
				connection.setAutoCommit(false);
				String presenceQuery=null;
				boolean isNotePresent=false;
				if(presence.getNote()!=null){		
					presenceQuery="UPDATE reg_presence SET EXPIRES=?, TIME_STAMP=?, NOTE_VAL=?, NOTE_LANG=?  WHERE SIPIFTAG=?";
					isNotePresent=true;
				}
				else
					presenceQuery="UPDATE reg_presence SET EXPIRES=?, TIME_STAMP=? WHERE SIPIFTAG=?";

				presenceStatement=connection.prepareStatement(presenceQuery);
			
				presenceStatement.setInt(1, presence.getExpires());
				presenceStatement.setLong(2, System.currentTimeMillis());
				String noteVal=null;
				String noteLang=null;
				if(isNotePresent){
					noteLang=presence.getNote().getLang();
					noteVal=presence.getNote().getValue();	
					presenceStatement.setString(3, noteVal);
					presenceStatement.setString(4, noteLang);
					presenceStatement.setString(5, presence.getSipIfTag());
				}else{
					presenceStatement.setString(3, presence.getSipIfTag());
				}
				
				
				int count=presenceStatement.executeUpdate();
				if(count>0){
					//Process tuple list
					List<Tuple> tupleList=presence.getTupleList();
					if(tupleList!=null && tupleList.size()!=0){
						String tupleInsertQuery="INSERT INTO reg_tuple(SIPIFTAG, TUPLE_ID, BASIC, NOTE_VAL, NOTE_LANG) VALUES (?,?,?,?,?)";
						String tupleUpdateQuery="UPDATE reg_tuple SET BASIC=?, NOTE_VAL=?,NOTE_LANG=? WHERE TUPLE_ID=? AND SIPIFTAG=?";
						tupleStatement=connection.prepareStatement(tupleInsertQuery);
						tupleUpdateStatement=connection.prepareStatement(tupleUpdateQuery);
						for(Tuple t:tupleList){
							count=0;
							noteLang=t.getNote()!=null?t.getNote().getLang():null;
							noteVal=t.getNote()!=null?t.getNote().getValue():null;
							tupleUpdateStatement.setString(5,presence.getSipIfTag());
							tupleUpdateStatement.setString(4, t.getTupleId());
							tupleUpdateStatement.setString(1, t.getBasic());
							tupleUpdateStatement.setString(2, noteVal);
							tupleUpdateStatement.setString(3, noteLang);
							count=tupleUpdateStatement.executeUpdate();
							
							if(count==0){
								//not present so insert
							tupleStatement.setString(1,presence.getSipIfTag());
							tupleStatement.setString(2, t.getTupleId());
							tupleStatement.setString(3, t.getBasic());
							tupleStatement.setString(4, noteVal);
							tupleStatement.setString(5, noteLang);
							tupleStatement.execute();
							}
						}
						
					}
					//Process person list
					List<Person> personList=presence.getPersonList();
					if(personList!=null && personList.size()!=0){
						String personInsertQuery="INSERT INTO reg_person(SIPIFTAG, PERSON_ID, ACTIVITIES, ACTIVITIES_VAL, NOTE_VAL, NOTE_LANG) VALUES (?,?,?,?,?,?)";
						String personUpdateQuery="UPDATE reg_person SET ACTIVITIES=?,ACTIVITIES_VAL=?, NOTE_VAL=?,NOTE_LANG=? WHERE PERSON_ID=? AND SIPIFTAG=?";
						personStatement=connection.prepareStatement(personInsertQuery);
						personUpdateStatement=connection.prepareStatement(personUpdateQuery);
						for(Person p:personList){
							count=0;
							noteLang=p.getNote()!=null?p.getNote().getLang():null;
							noteVal=p.getNote()!=null?p.getNote().getValue():null;
							personUpdateStatement.setString(6,presence.getSipIfTag());
							personUpdateStatement.setString(5, p.getPersonId());
							personUpdateStatement.setString(1, p.getActivities());
							personUpdateStatement.setString(2, p.getActivitiesVal());
							personUpdateStatement.setString(3, noteVal);
							personUpdateStatement.setString(4, noteLang);
							count=personUpdateStatement.executeUpdate();
							
							if(count==0){
								//not present so insert
							personStatement.setString(1,presence.getSipIfTag());
							personStatement.setString(2, p.getPersonId());
							personStatement.setString(3, p.getActivities());
							personStatement.setString(4, p.getActivitiesVal());
							personStatement.setString(5, noteVal);
							personStatement.setString(6, noteLang);
							personStatement.execute();
							}
						}
						
					}
					connection.commit();
					isUpdated=true;
				}else{
					logger.error("No presene information stored for:"+presence.getSipIfTag()+":"+presence.getEntity());
				}
			}catch(Exception e)	{
				logger.error("Exception in updatePresenceData():"+e.toString());
				throw e;
			}finally{
				if(presenceStatement!=null)
					presenceStatement.close();
				if(tupleStatement!=null)
					tupleStatement.close();
				if(tupleUpdateStatement!=null)
					tupleStatement.close();
				if(personUpdateStatement!=null)
					personStatement.close();
				if(presenceStatement!=null)
					presenceStatement.close();
				if(connection!=null)
					connection.close(); 
			}
		}
		if(logger.isDebugEnabled())
			logger.debug("updatePresenceData(): exitting.....");
		return isUpdated;
	}


	@Override
	public boolean removePresenceData(String sipIfMatch) throws SQLException,
			Exception {
		if(logger.isDebugEnabled())
			logger.debug("removePresenceData(): called....."+sipIfMatch);
		boolean isRemoved=false;
		if(sipIfMatch!=null){
			Connection connection=null;
			PreparedStatement statement=null;
			try	{
				connection=regDataSource.getConnection();
				if(connection==null)
				{
					logger.error("removePresenceData()::couldnot get connection");
					return false;
				}
				statement=connection.prepareStatement("DELETE FROM reg_presence where SIPIFTAG=?");
				statement.setString(1, sipIfMatch);
				int count=statement.executeUpdate();
				if(logger.isDebugEnabled())
					logger.debug("For sipIfMatch: "+sipIfMatch+" rows deleted:"+count);
				isRemoved=count>0?true:false;
			}catch(Exception e)	{
				logger.error("Exception in removePresenceData():"+e.toString());
				throw e;
			}finally{
				if(statement!=null)
					statement.close();
				if(connection!=null)
					connection.close(); 
			}
		}
		if(logger.isDebugEnabled())
			logger.debug("removePresenceData(): exitting.....");
		return isRemoved;
	}


	@Override
	public boolean refreshPresenceData(String sipIfMatch, int expires)
			throws SQLException, Exception {
		if(logger.isDebugEnabled())
			logger.debug("refreshPresenceData(): called....."+sipIfMatch);
		boolean isRefreshed=false;
		if(sipIfMatch!=null){
			Connection connection=null;
			PreparedStatement statement=null;
			try	{
				connection=regDataSource.getConnection();
				if(connection==null)
				{
					logger.error("refreshPresenceData()::couldnot get connection");
					return false;
				}
				statement=connection.prepareStatement("UPDATE reg_presence set EXPIRES=?,TIME_STAMP=? where SIPIFTAG=?");
				statement.setInt(1, expires);
				statement.setLong(2, System.currentTimeMillis());
				statement.setString(3, sipIfMatch);
				int count=statement.executeUpdate();
				if(logger.isDebugEnabled())
					logger.debug("For sipIfMatch: "+sipIfMatch+" rows updated:"+count);
				isRefreshed=count>0?true:false;
			}catch(Exception e)	{
				logger.error("Exception in refreshPresenceData():"+e.toString());
				throw e;
			}finally{
				if(statement!=null)
					statement.close();
				if(connection!=null)
					connection.close(); 
			}
		}
		if(logger.isDebugEnabled())
			logger.debug("refreshPresenceData(): exitting.....");
		return isRefreshed;
	}


	@Override
	public Presence getPresenceData(String addressOfRecord)
			throws SQLException, Exception {
		if(logger.isDebugEnabled())
			logger.debug("getPresenceData(): called.....");
		Presence presence=null;
		if(addressOfRecord!=null){
			Connection connection=null;
			PreparedStatement presenceStatement=null;
			PreparedStatement tupleStatement=null;
			PreparedStatement personStatement=null;
			ResultSet resultSet=null;
			try	{
				connection=regDataSource.getConnection();
				if(connection==null)
				{
					logger.error("getPresenceData()::couldnot get connection");
					return null;
				}
				
				String presenceQuery="SELECT SIPIFTAG,NOTE_VAL,NOTE_LANG FROM reg_presence WHERE ENTITY=? ORDER BY TIME_STAMP DESC";
				presenceStatement=connection.prepareStatement(presenceQuery);
				presenceStatement.setString(1, addressOfRecord);
				resultSet=presenceStatement.executeQuery();
				int i=0;
				StringBuilder sipIfTags=new StringBuilder();
				String noteVal=null;
				String noteLang=null;
				while(resultSet.next()){
					String sipIfTag=resultSet.getString("SIPIFTAG");
					sipIfTags.append("'"+sipIfTag+"',");
					if(i==0){
						noteVal=resultSet.getString("NOTE_VAL");
						noteLang=resultSet.getString("NOTE_LANG");
					}
					i++;
				}
				resultSet.close();
				if(i==0){
					return presence;
				}else{
					
					presence=new Presence();
					presence.setEntity(addressOfRecord);
					if(noteVal!=null)
						presence.setNote(new Note(noteVal, noteLang));
					//Adding tuples
					
					String tags=sipIfTags.toString();		
					tags=tags.substring(0, tags.length()-1);
					
					String tupleQuery="SELECT TUPLE_ID,BASIC,NOTE_VAL,NOTE_LANG FROM reg_tuple WHERE SIPIFTAG IN ("+tags+")";
					
					tupleStatement=connection.prepareStatement(tupleQuery);
					
					resultSet=tupleStatement.executeQuery();
					ArrayList <Tuple> tupleList=new ArrayList<Tuple>();
					while(resultSet.next()){
						String tupleId=resultSet.getString("TUPLE_ID");
						String basic=resultSet.getString("BASIC");
						String tupleNoteVal=resultSet.getString("NOTE_VAL");
						String tupleNoteLang=resultSet.getString("NOTE_LANG");
						Tuple t=new Tuple(tupleId, basic,null);
						if(tupleNoteVal!=null)
							t.setNote(new Note(tupleNoteVal,tupleNoteLang));
						tupleList.add(t);
					}
					
					resultSet.close();
					
					if(!tupleList.isEmpty())
						presence.setTupleList(tupleList);
					String personQuery="SELECT PERSON_ID,ACTIVITIES,ACTIVITIES_VAL,NOTE_VAL,NOTE_LANG FROM reg_person WHERE SIPIFTAG IN ("+tags+")";
					personStatement=connection.prepareStatement(personQuery);
					resultSet=personStatement.executeQuery();
					
					ArrayList <Person> personList=new ArrayList<Person>();
					while(resultSet.next()){
						String personId=resultSet.getString("PERSON_ID");
						String activities=resultSet.getString("ACTIVITIES");
						String activitiesVal=resultSet.getString("ACTIVITIES_VAL");
						String personNoteVal=resultSet.getString("NOTE_VAL");
						String personNoteLang=resultSet.getString("NOTE_LANG");
						Person p=new Person(personId, activities,activitiesVal, null);
						if(personNoteVal!=null)
							p.setNote(new Note(personNoteVal,personNoteLang));
						personList.add(p);
					}
					//result set close in finally
					if(!personList.isEmpty())
						presence.setPersonList(personList);
				}

			}catch(Exception e)	{
				logger.error("Exception in addPresenceData():"+e.toString());
				throw e;
			}finally{
				if(resultSet!=null)
					resultSet.close();
				if(presenceStatement!=null)
					presenceStatement.close();
				if(tupleStatement!=null)
					tupleStatement.close();
				if(personStatement!=null)
					personStatement.close();
				if(connection!=null)
					connection.close(); 
			}
		}
		if(logger.isDebugEnabled())
			logger.debug("getPresenceData(): exitting.....");
		return presence;
	}


	@Override
	public ArrayList<Presence> deleteExpiredPresenceInformation()
			throws SQLException, Exception {
		if(logger.isDebugEnabled())
			logger.debug("deleteExpiredPresenceInformation(): called.....");
		ArrayList <Presence> expiredPresenceList = null;
		Connection connection = null;
		Statement stmt = null;
		ResultSet rs = null;
		try	
		{
			connection = regDataSource.getConnection();
			if(connection==null)
			{
				logger.error("deleteExpiredPresenceInformation():: could not get connections");
				return null;
			}
			stmt = connection.createStatement();
			long currentTime=System.currentTimeMillis()/1000;
			String selectionQuery = "SELECT ENTITY FROM reg_presence WHERE (EXPIRES+TIME_STAMP)<"+currentTime;
			rs = stmt.executeQuery(selectionQuery);
			while (rs!=null && rs.next())
			{
				if(expiredPresenceList==null)
					expiredPresenceList=new ArrayList<Presence>();
				String entity=rs.getString("ENTITY");
				expiredPresenceList.add(new Presence(null, entity, null, null, null, 0));
			}
			if(expiredPresenceList!=null){
				String deletionQuery="DELETE FROM reg_presence WHERE (EXPIRES+TIME_STAMP)<"+currentTime;
				stmt.execute(deletionQuery);
			}
		}
		catch(Exception exp)
		{
			logger.error(exp.toString(),exp);
		}finally{
			if(rs != null)	
				rs.close();
			if(stmt!=null)
				stmt.close();
			if(connection!=null)
				connection.close();
		}
		if(logger.isDebugEnabled())
			logger.debug("deleteExpiredPresenceInformation(): exitting.....");
		return expiredPresenceList;
	}

}
