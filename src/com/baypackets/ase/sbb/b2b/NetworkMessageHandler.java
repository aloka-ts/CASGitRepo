/*
 * NetworkMessageHandler.java   1.0 11 July 2005
 *
 */

package com.baypackets.ase.sbb.b2b;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import java.io.UnsupportedEncodingException;
import java.util.Iterator;
import java.util.ListIterator;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.mail.BodyPart;
import javax.mail.MessagingException;
import javax.mail.Multipart;
import javax.mail.internet.MimeMultipart;
import javax.servlet.sip.Rel100Exception;
import javax.servlet.sip.ServletTimer;
import javax.servlet.sip.SipApplicationSession;
import javax.servlet.sip.SipServlet;
import javax.servlet.sip.SipServletMessage;
import javax.servlet.sip.SipServletRequest;
import javax.servlet.sip.SipServletResponse;
import javax.servlet.sip.SipSession;
import javax.servlet.sip.SipSession.State;
import javax.servlet.sip.TimerService;

import org.apache.log4j.Logger;
import org.apache.log4j.Priority;

import com.baypackets.ase.msadaptor.MsAdaptor;
import com.baypackets.ase.sbb.MsCollectSpec;
import com.baypackets.ase.sbb.MsRecordSpec;
import com.baypackets.ase.sbb.MsSessionController;
import com.baypackets.ase.sbb.ProcessMessageException;
import com.baypackets.ase.sbb.SBB;
import com.baypackets.ase.sbb.SBBEvent;
import com.baypackets.ase.sbb.SBBEventListener;
import com.baypackets.ase.sbb.impl.BasicSBBOperation;
import com.baypackets.ase.sbb.impl.SBBImpl;
import com.baypackets.ase.sbb.impl.SBBOperation;
import com.baypackets.ase.sbb.impl.SBBOperationContext;
import com.baypackets.ase.sbb.mediaserver.GroupedMsSessionControllerImpl;
import com.baypackets.ase.sbb.mediaserver.MediaServerInfoHandler;
import com.baypackets.ase.sbb.mediaserver.MsSessionControllerImpl;
import com.baypackets.ase.sbb.timer.TimerInfo;
import com.baypackets.ase.sbb.util.Constants;
import com.baypackets.ase.sbb.util.SBBResponseUtil;
import com.baypackets.ase.util.AseStrings;
import com.baypackets.ase.util.AseTimerInfo;
import com.baypackets.bayprocessor.slee.common.BaseContext;
import com.esotericsoftware.kryo.DefaultSerializer;
import com.esotericsoftware.kryo.serializers.ExternalizableSerializer;

/**
 * Implementation of the network message handler. This class is responsible for
 * handling any SIP event generated by any of two B2BUA end point.
 */

@DefaultSerializer(ExternalizableSerializer.class)
public class NetworkMessageHandler extends BasicSBBOperation {

	/** Logger element */
	private static Logger logger = Logger.getLogger(NetworkMessageHandler.class
			.getName());
	private static final long serialVersionUID = -349247024880647033L;
	private static final int DEFAULT_RESPONSE_CODE = 500;

	private String lastFiredEvent;

	private transient SipServletMessage originatingMessage;

	private int operation = -1;

	private final int PLAY = 1;
	private final int PLAY_COLLECT = 2;
	private final int PLAY_RECORD = 3;

	private boolean reInviteWithSameSDP = false;
	private boolean inviteToPartyBSent = true;
	private static boolean playMedia = false;
	private static boolean callInHold = false;
	private SipServletRequest reInvite;
	private byte[] rel_isup = { (byte) 0x0c, (byte) 0x02, (byte) 0x00,
			(byte) 0x02, (byte) 0x83, (byte) 0xbf };
	private static int releaseCause = Integer.parseInt(BaseContext
			.getConfigRepository().getValue(
					Constants.SESSION_EXPIRES_DEFAULT_ISUP_RELEASE_CAUSE));

	// private static boolean
	// notifyASessionExpiry=Boolean.parseBoolean(BaseContext.getConfigRepository().getValue(Constants.NOTIFY_SESSION_EXPIRY_A_TOAPP));

	private SipServletRequest reInviteRequest;
	// Mukesh
	private static final String ATT_CPA_CHECK = "ATT_CPA_CHECK";

	private static final String ORIG_INITIAL_REQUEST = "ORIG_INITIAL_REQUEST";
	private static final String TIMER = "timer";

	private static String requestPendingTimerVal = (String) BaseContext
			.getConfigRepository().getValue(Constants.REQUEST_PENDING_TIMER);

	// Created a place holder for request sent to Media Server at Object level
	// for cases when we receives 491 from media server and we need to send it
	// again after timer expiry.
	private transient SipServletRequest sessRefReqOut = null;

	/**
	 * Public Default Constructor used for Externalizing this Object
	 */
	public NetworkMessageHandler(SipServletMessage message) {
		super();
		originatingMessage = message;
	}

	/**
	 * Public Default Constructor used for Externalizing this Object
	 */
	public NetworkMessageHandler() {
		this(null);
	}

	/**
	 * This method will be invoked to start network message handler operation.
	 * This would be done, when the application invokes an operation on the SBB.
	 * (OR) when the SBB Servlet receives an message from network, but there are
	 * no handlers available to handle it.
	 */
	public void start() throws ProcessMessageException {
		if (logger.isDebugEnabled()) {
			logger.debug("<SBB>entered start() ");
			logger.debug("<SBB>exited start() ");
		}
	}

	public void ackTimedout(SipSession session) {
	}

	public void prackTimedout(SipSession session) {
	}

	// This can be a request or an ACK/PRACK for Network generated reINVITE
	public void handleRequest(SipServletRequest request) {

		// No need to generate SIG_IN_PROGRESS event for ACK or PRACK
		// generate a SIG_IN_PROGRESS event for application

		int responseFromApp = SBBEventListener.CONTINUE;
		SBBOperationContext operCtx = (SBBOperationContext) getOperationContext();

		// its only handle re-invite request for session refresh
		// limitation: we always expecting refresher=uac in re-invite there is
		// no handling for refersher=uas
		//
		if (request.getMethod().equalsIgnoreCase(Constants.METHOD_INVITE)) {
			if (logger.isInfoEnabled()) {
				logger.info("<SBB>Mid call signalling, handling control to application for re-invite");
			}

			SBBEvent sigInProgressEvent = new SBBEvent(
					SBBEvent.EVENT_SIG_IN_PROGRESS);
			sigInProgressEvent.setMessage(request);
			this.lastFiredEvent = SBBEvent.EVENT_SIG_IN_PROGRESS;

			responseFromApp = operCtx.fireEvent(sigInProgressEvent);
			if (responseFromApp == SBBEventListener.CONTINUE) {

				SBB sbb = (SBB) operCtx;
				SipSession partyA = sbb.getA();
				SipSession partyB = sbb.getB();

				// ---
				if (request.getMethod().equals(Constants.METHOD_INVITE)
						&& !request.isInitial()
						&& request.getSession() == partyA
						&& partyB != null
						&& ((Boolean) partyB
								.getAttribute("ReceivedFinalResponseFromB") != null)
						&& !((Boolean) partyB
								.getAttribute("ReceivedFinalResponseFromB"))
								.booleanValue()) {
					if (logger.isDebugEnabled()) {
						logger.debug("<SBB>re-INVITE received from A, while INVITE request pending with B");
					}
					try {
						SipServletResponse response = request
								.createResponse(491);
						response.send();
						return;
					} catch (Exception exp) {
						logger.error("Exception in sending 491", exp);
					}
				}
				if (logger.isDebugEnabled()) {
					logger.debug("in handle request (reinvite)");
				}
				Object content = null;
				this.reInvite = request;
				String newSDP = null;
				String oldSDP = null;
				byte[] newSDPByteValue = null;
				byte[] oldSDPByteValue = null;
				boolean isSameSdp = false;
				try {
					content = request.getContent();
					if (content != null) {
						if (content instanceof String) {
							newSDP = ((String) content).trim();
							newSDPByteValue = newSDP.getBytes();
						} else if (content instanceof MimeMultipart) {
							newSDPByteValue = this.getSDP(content);
							if (newSDPByteValue != null) {
								newSDP = new String(newSDPByteValue).trim();
							}
						} else {
							newSDPByteValue = (byte[]) request.getContent();
							newSDP = new String(newSDPByteValue).trim();
						}

					}
					oldSDPByteValue = (byte[]) request.getSession()
							.getAttribute(SBBOperationContext.ATTRIBUTE_SDP);
					if (newSDPByteValue != null && oldSDPByteValue != null) {
						// newSDP = new String(newSDPByteValue).trim();
						oldSDP = new String(oldSDPByteValue).trim();
						isSameSdp = newSDP.equals(oldSDP);
					}

				} catch (IOException e) {
					logger.error("error: " + e.getMessage());
				}
				if (logger.isDebugEnabled()) {
					logger.debug("is sdp's are same? " + isSameSdp);
				}
				if (isSameSdp || (newSDP == null)) {
					if (request.getHeader(Constants.HDR_SESSION_EXPIRES) != null) {
						try {

							this.reInviteWithSameSDP = true;
							// partA
							if (partyA != null
									&& request.getSession().getId()
											.equalsIgnoreCase(partyA.getId())) {
								// cancel then start new session expiry timer
								// for session refresh re-invite
								if (logger.isDebugEnabled()) {
									logger.debug("partyA sends re-invite");
								}
								this.cancelSessionExpiryTimer(Constants.SESSION_EXPIRY_TIMER_FOR_A_PARTY);
								request.getSession()
										.setAttribute(
												"SESSION_EXPIRES",
												this.getDeltaSeconds(request
														.getHeader(Constants.HDR_SESSION_EXPIRES)));
								// creating response 200 ok
								SipServletResponse resp = request
										.createResponse(200);
								// add require header
								resp.addHeader(Constants.HDR_REQUIRE, TIMER);
								// add supported header..
								// String supportedHeaderValue =
								// (String)request.getHeader(Constants.HDR_SUPPORTED);
								String supportedHeaderValue = null;
								boolean suppTimerFound = false;
								Iterator valueList = request
										.getHeaders(Constants.HDR_SUPPORTED);
								while (valueList.hasNext()) {
									supportedHeaderValue = (String) valueList
											.next();
									if (supportedHeaderValue.contains(TIMER)) {
										resp.setHeader(Constants.HDR_SUPPORTED,
												supportedHeaderValue);
										suppTimerFound = true;
										break;
									}
								}
								if (!suppTimerFound) {
									resp.addHeader(Constants.HDR_SUPPORTED,
											TIMER);
								}
								// add session-expires header filed in 200ok of
								// re-invite for session refresh
								if (request
										.getHeader(Constants.HDR_SESSION_EXPIRES) != null) {
									String value = this
											.getDeltaSeconds(request
													.getHeader(Constants.HDR_SESSION_EXPIRES))
											+ ";refresher=uac";
									resp.addHeader(
											Constants.HDR_SESSION_EXPIRES,
											value);

								}
								if (partyB != null
										&& partyB
												.getAttribute(Constants.HDR_CONTENT_DISPOSITION) != null) {
									resp.setHeader(
											Constants.HDR_CONTENT_DISPOSITION,
											(String) partyB
													.getAttribute(Constants.HDR_CONTENT_DISPOSITION));
								} else {
									resp.setHeader(
											Constants.HDR_CONTENT_DISPOSITION,
											Constants.DEFAULT_VALUE_SDP_CONTENT_DISPOSITION);
								}
								// The null check for party B is applied here
								// because of race condition
								// introduced in UAT-745. Where in we can get
								// session refresh re-invite
								// from party-a while connection process
								// (dialout) is currently going on.
								if (partyB != null
										&& partyB
												.getAttribute(SBBOperationContext.ATTRIBUTE_SDP) != null
										&& ((Integer) partyB
												.getAttribute(Constants.ATTRIBUTE_DIALOG_STATE))
												.intValue() == Constants.STATE_CONFIRMED) {
									resp.setContent(
											partyB.getAttribute(SBBOperationContext.ATTRIBUTE_SDP),
											(String) partyB
													.getAttribute(SBBOperationContext.ATTRIBUTE_SDP_CONTENT_TYPE));
								} else {
									logger.error("Party B is null or not in confirmed state");
									resp.setContent(
											sbb.getAttribute(SBBOperationContext.ATTRIBUTE_SDP_PARTY_B),
											(String) sbb
													.getAttribute(SBBOperationContext.ATTRIBUTE_SDP_PARTY_B_CONTENT_TYPE));
								}
								if (logger.isDebugEnabled()) {
									logger.debug("old sdp set in 200ok..");
								}
								try {
									sendResponse(resp, false);
								} catch (IOException e) {
									logger.error(e.getMessage(), e);
								} catch (Rel100Exception e) {
									logger.error(e.getMessage(), e);
								}
								if (logger.isDebugEnabled()) {
									logger.debug("200 send for re-invite of session-refresh");
								}
								this.startSessionExpiryTimer(
										request,
										Constants.TIMER_FOR_A_PARTY,
										Constants.SESSION_EXPIRY_TIMER_FOR_A_PARTY);

							} else if (partyB != null
									&& request.getSession().getId()
											.equalsIgnoreCase(partyB.getId())) {
								// cancel then start new session expiry timer
								// for session refresh re-invite
								if (logger.isDebugEnabled()) {
									logger.debug("partyB sends re-invite");
								}
								this.cancelSessionExpiryTimer(Constants.SESSION_EXPIRY_TIMER_FOR_MS);
								request.getSession()
										.setAttribute(
												"SESSION_EXPIRES",
												this.getDeltaSeconds(request
														.getHeader(Constants.HDR_SESSION_EXPIRES)));
								// creating response 200 ok
								SipServletResponse resp = request
										.createResponse(200);
								// add require header...
								resp.addHeader(Constants.HDR_REQUIRE, TIMER);
								// add supported header..
								// String supportedHeaderValue =
								// (String)request.getHeader(Constants.HDR_SUPPORTED);
								String supportedHeaderValue = null;
								boolean suppTimerFound = false;
								Iterator valueList = request
										.getHeaders(Constants.HDR_SUPPORTED);
								while (valueList.hasNext()) {
									supportedHeaderValue = (String) valueList
											.next();
									if (supportedHeaderValue.contains(TIMER)) {
										resp.setHeader(Constants.HDR_SUPPORTED,
												supportedHeaderValue);
										suppTimerFound = true;
										break;
									}
								}
								if (!suppTimerFound) {
									resp.addHeader(Constants.HDR_SUPPORTED,
											TIMER);
								}
								// add session-expires header filed in 200ok of
								// re-invite for session refresh
								if (request
										.getHeader(Constants.HDR_SESSION_EXPIRES) != null) {
									String value = this
											.getDeltaSeconds(request
													.getHeader(Constants.HDR_SESSION_EXPIRES))
											+ ";refresher=uac";
									resp.addHeader(
											Constants.HDR_SESSION_EXPIRES,
											value);

								}

								if (partyA != null) {
									resp.setContent(
											partyA.getAttribute(SBBOperationContext.ATTRIBUTE_SDP),
											(String) partyA
													.getAttribute(SBBOperationContext.ATTRIBUTE_SDP_CONTENT_TYPE));
								} else {
									if (logger.isDebugEnabled()) {
										logger.debug("Setting SDP from Conference Controller Session");
									}
									resp.setContent(
											partyB.getAttribute(Constants.CONTROLLER_SDP_CONTENT),
											(String) partyB
													.getAttribute(Constants.CONTROLLER_SDP_CONTENT_TYPE));
								}

								if (logger.isDebugEnabled()) {
									logger.debug("old sdp set in 200ok..");
								}
								try {
									sendResponse(resp, false);
								} catch (IOException e) {
									logger.error(e.getMessage(), e);
								} catch (Rel100Exception e) {
									logger.error(e.getMessage(), e);
								}
								if (logger.isDebugEnabled()) {
									logger.debug("200 send for re-invite of session-refresh");
								}
								this.startSessionExpiryTimer(request,
										Constants.TIMER_FOR_MS,
										Constants.SESSION_EXPIRY_TIMER_FOR_MS);

							}

						} catch (Exception e) {
							logger.error("exception in handle re-invite ", e);
						}
						return;

					} else {
						if (logger.isDebugEnabled()) {
							logger.debug("same sdp but without session-expeies header filed, cancel timer");
						}
						this.reInviteWithSameSDP = true;
						if (partyA != null
								&& request.getSession().getId()
										.equalsIgnoreCase(partyA.getId())) {

							try {
								this.cancelSessionExpiryTimer(Constants.SESSION_EXPIRY_TIMER_FOR_A_PARTY);
								SipServletResponse resp = request
										.createResponse(200);
								// set supported header
								String supportedHeaderValue = null;
								Iterator valueList = request
										.getHeaders(Constants.HDR_SUPPORTED);
								boolean suppTimerFound = false;
								while (valueList.hasNext()) {
									supportedHeaderValue = (String) valueList
											.next();
									if (supportedHeaderValue.contains(TIMER)) {
										resp.setHeader(Constants.HDR_SUPPORTED,
												supportedHeaderValue);
										suppTimerFound = true;
										break;
									}
								}
								if (!suppTimerFound) {
									resp.addHeader(Constants.HDR_SUPPORTED,
											TIMER);
								}
								// ---------------
								// UAT-745
								if (partyB != null
										&& partyB
												.getAttribute(SBBOperationContext.ATTRIBUTE_SDP) != null
										&& ((Integer) partyB
												.getAttribute(Constants.ATTRIBUTE_DIALOG_STATE))
												.intValue() == Constants.STATE_CONFIRMED) {
									resp.setContent(
											partyB.getAttribute(SBBOperationContext.ATTRIBUTE_SDP),
											(String) partyB
													.getAttribute(SBBOperationContext.ATTRIBUTE_SDP_CONTENT_TYPE));
								} else {
									logger.error("Party B is null or not in confirmed state");
									resp.setContent(
											sbb.getAttribute(SBBOperationContext.ATTRIBUTE_SDP_PARTY_B),
											(String) sbb
													.getAttribute(SBBOperationContext.ATTRIBUTE_SDP_PARTY_B_CONTENT_TYPE));
								}

								sendResponse(resp, false);
								if (logger.isDebugEnabled()) {
									logger.debug("200ok send..for same sdp");
								}
							} catch (IOException e) {
								logger.error(e.getMessage(), e);
							} catch (Rel100Exception e) {
								logger.error(e.getMessage(), e);
							}

						} else {// b-party
							try {
								this.cancelSessionExpiryTimer(Constants.SESSION_EXPIRY_TIMER_FOR_MS);
								SipServletResponse resp = request
										.createResponse(200);
								// set supported header
								String supportedHeaderValue = null;
								boolean suppTimerFound = false;
								Iterator valueList = request
										.getHeaders(Constants.HDR_SUPPORTED);
								while (valueList.hasNext()) {
									supportedHeaderValue = (String) valueList
											.next();
									if (supportedHeaderValue.contains(TIMER)) {
										resp.setHeader(Constants.HDR_SUPPORTED,
												supportedHeaderValue);
										suppTimerFound = true;
										break;
									}
								}
								if (!suppTimerFound) {
									resp.setHeader(Constants.HDR_SUPPORTED,
											TIMER);
								}
								// ---------------
								if (partyA != null) {
									resp.setContent(
											partyA.getAttribute(SBBOperationContext.ATTRIBUTE_SDP),
											(String) partyA
													.getAttribute(SBBOperationContext.ATTRIBUTE_SDP_CONTENT_TYPE));
								} else {
									if (logger.isDebugEnabled()) {
										logger.debug("Setting SDP from Conference Controller Session");
									}
									resp.setContent(
											partyB.getAttribute(Constants.CONTROLLER_SDP_CONTENT),
											(String) partyB
													.getAttribute(Constants.CONTROLLER_SDP_CONTENT_TYPE));
								}

								sendResponse(resp, false);
								if (logger.isDebugEnabled()) {
									logger.debug("200ok send..for same sdp");
								}
							} catch (IOException e) {
								logger.error(e.getMessage(), e);
							} catch (Rel100Exception e) {
								logger.error(e.getMessage(), e);
							}
						}
						return;
					}

				}

				/*
				 * else if(newSDP==null){ //send response 488 (not acceptable)
				 * and return try{ SipServletResponse errorResp =
				 * request.createResponse(488); //This is required here as well
				 * as ACK for the failed response come to //the application and
				 * we need to stop ACK going to the other party
				 * inviteToPartyBSent = false; sendResponse(errorResp, false);
				 * 
				 * if(logger.isDebugEnabled()){ logger.debug("488 sends...."); }
				 * return; }catch (Rel100Exception e) {
				 * logger.error(e.getMessage(),e); } catch(IOException e){
				 * logger.error(e.getMessage(),e); }
				 * 
				 * }
				 */
				else {
					// re-invite for update sdp
					// SipSession peerSession =
					// (request.getSession()==sbb.getA())?sbb.getB():sbb.getA();
					if (logger.isDebugEnabled()) {
						logger.debug("ReINVITE for update sdp");
					}
					request.getSession().setAttribute(
							SBBOperationContext.ATTRIBUTE_SDP, newSDPByteValue);
					request.getSession().setAttribute(
							SBBOperationContext.ATTRIBUTE_SDP_CONTENT_TYPE,
							request.getContentType());

					if (request.getHeader(Constants.HDR_SESSION_EXPIRES) != null) {
						if (logger.isDebugEnabled()) {
							logger.debug("with session-Expires header field");
						}
						// A-PARTY----------------------------------
						if (partyA != null
								&& request.getSession().getId()
										.equalsIgnoreCase(partyA.getId())) {
							if (logger.isDebugEnabled()) {
								logger.debug("partyA sends re-invite with newSDP");
							}
							this.cancelSessionExpiryTimer(Constants.SESSION_EXPIRY_TIMER_FOR_A_PARTY);
							request.getSession()
									.setAttribute(
											"SESSION_EXPIRES",
											this.getDeltaSeconds(request
													.getHeader(Constants.HDR_SESSION_EXPIRES)));

							// changes for hold
							// now re-invite sends through
							// MediaServerInfoHandler when play stop completed
							if (this.isHoldRequest(request)) {
								if (sbb instanceof MsSessionControllerImpl
										|| sbb instanceof GroupedMsSessionControllerImpl) {
									this.handleUpdateSDP();
									if (playMedia) {
										this.reInviteRequest = request;
										return;
									}
									if (logger.isDebugEnabled()) {
										logger.debug("Session-Expires::re-invite recevied for update sdp and no media playing right now ");
									}
								}

							}
							// ----
							// UAT-745
							// Now this has been moved as object level attribute
							// SipServletRequest requestOut = null;
							if (sbb.getB() != null
									&& ((Integer) sbb.getB().getAttribute(
											Constants.ATTRIBUTE_DIALOG_STATE))
											.intValue() == Constants.STATE_CONFIRMED) {
								sessRefReqOut = sbb.getB().createRequest(
										Constants.METHOD_INVITE);
							} else {
								// There is a race condition where dialout is
								// going on and Session refresh
								// reinvite came from Party-A, since party A SDP
								// is not associated with SBB
								// so it will be considered as reinvite for
								// update SDP, but when it tries to
								// send INVITE to Party-B, it will not find
								// party B and ends up here, so
								// setting the attribute to false which will be
								// checked when ACK is received
								// from Party-A and then we need not to relay
								// ACK there
								inviteToPartyBSent = false;
								logger.error("Party B is null or not in confirmed state");
								SipServletResponse resp = request
										.createResponse(200);
								this.addHeaders(request, resp, sbb);
								try {
									sendResponse(resp, false);
								} catch (Rel100Exception e) {
									logger.error(e.getMessage(), e);
								} catch (IOException e) {
									logger.error(e.getMessage(), e);
								}
								return;
							}
							this.setHeadersOnOutRequest(request, sessRefReqOut);
							// add supported header..
							// String supportedHeaderValue =
							// (String)requestOut.getHeader(Constants.HDR_SUPPORTED);
							String supportedHeaderValue = null;
							boolean suppTimerFound = false;
							Iterator valueList = sessRefReqOut
									.getHeaders(Constants.HDR_SUPPORTED);
							while (valueList.hasNext()) {
								supportedHeaderValue = (String) valueList
										.next();
								if (supportedHeaderValue.contains(TIMER)) {
									sessRefReqOut.setHeader(
											Constants.HDR_SUPPORTED,
											supportedHeaderValue);
									suppTimerFound = true;
									break;
								}
							}
							if (!suppTimerFound) {
								sessRefReqOut.addHeader(
										Constants.HDR_SUPPORTED, TIMER);
							}

							// add session-expires header...
							if (sbb.getB().getAttribute("SESSION_EXPIRES") != null) {
								String sessionExpiresValue = (String) sbb
										.getB().getAttribute("SESSION_EXPIRES")
										+ ";refresher=uas";
								sessRefReqOut.setHeader(
										Constants.HDR_SESSION_EXPIRES,
										sessionExpiresValue);
							}
							if (sbb.getB().getAttribute("MIN_SE") != null) {
								String deltaSec = (String) sbb.getB()
										.getAttribute("MIN_SE");
								sessRefReqOut.setHeader(Constants.HDR_MIN_SE,
										deltaSec);
							}
							if (logger.isDebugEnabled()) {
								logger.debug("session-exprires headers are set....");
							}

							try {

								if (logger.isDebugEnabled()) {
									logger.debug("relay reinvite with: PIGGY_BACK_ORIG_REQ is  ..."
											+ request);
								}

								sessRefReqOut.setAttribute(
										Constants.PIGGY_BACK_ORIG_REQ, request);
								sessRefReqOut.setContent(request.getContent(),
										request.getContentType());
								sendRequest(sessRefReqOut);
								// requestOut.getSession().setAttribute(Constants.PENDING_REQUEST,
								// true);
								if (logger.isDebugEnabled()) {
									logger.debug("relay re-invite with session-expires header changes");
								}
								this.cancelSessionExpiryTimer(Constants.SESSION_EXPIRY_TIMER_FOR_MS);
							} catch (IOException e) {
								logger.error(e.getMessage(), e);
							}

							// B-PARTY-------------------------------------------------------------------
						} else if (partyB != null
								&& request.getSession().getId()
										.equalsIgnoreCase(partyB.getId())) {
							if (logger.isDebugEnabled()) {
								logger.debug("MS sends re-invite with newSDP sdp");
							}
							this.cancelSessionExpiryTimer(Constants.SESSION_EXPIRY_TIMER_FOR_MS);
							request.getSession()
									.setAttribute(
											"SESSION_EXPIRES",
											this.getDeltaSeconds(request
													.getHeader(Constants.HDR_SESSION_EXPIRES)));
							// SipServletRequest requestOut =
							// sbb.getA().createRequest(Constants.METHOD_INVITE);
							sessRefReqOut = sbb.getA().createRequest(
									Constants.METHOD_INVITE);
							this.setHeadersOnOutRequest(request, sessRefReqOut);
							if (sbb.getA().getAttribute("SESSION_EXPIRES") != null) {
								String sessionExpiresValue = (String) sbb
										.getA().getAttribute("SESSION_EXPIRES")
										+ ";refresher=uas";
								sessRefReqOut.setHeader(
										Constants.HDR_SESSION_EXPIRES,
										sessionExpiresValue);
							}
							if (sbb.getA().getAttribute("MIN_SE") != null) {
								String deltaSec = (String) sbb.getA()
										.getAttribute("MIN_SE");
								sessRefReqOut.setHeader(Constants.HDR_MIN_SE,
										deltaSec);
							}
							if (logger.isDebugEnabled()) {
								logger.debug("session-exprires headers are set....");
							}

							try {
								if (logger.isDebugEnabled()) {
									logger.debug("relay : PIGGY_BACK_ORIG_REQ is  ..."
											+ request);
								}
								sessRefReqOut.setAttribute(
										Constants.PIGGY_BACK_ORIG_REQ, request);
								sessRefReqOut.setContent(request.getContent(),
										request.getContentType());
								if (request
										.getHeader(Constants.HDR_CONTENT_DISPOSITION) != null) {
									sessRefReqOut
											.setHeader(
													Constants.HDR_CONTENT_DISPOSITION,
													request.getHeader(Constants.HDR_CONTENT_DISPOSITION));
								} else {
									sessRefReqOut
											.setHeader(
													Constants.HDR_CONTENT_DISPOSITION,
													Constants.DEFAULT_VALUE_SDP_CONTENT_DISPOSITION);
								}
								sendRequest(sessRefReqOut);
								// requestOut.getSession().setAttribute(Constants.PENDING_REQUEST,
								// true);
								if (logger.isDebugEnabled()) {
									logger.debug("relay re-invite with session-expires header changes");
								}
								this.cancelSessionExpiryTimer(Constants.SESSION_EXPIRY_TIMER_FOR_A_PARTY);
							} catch (IOException e) {
								logger.error(e.getMessage(), e);
							}

						}

						return;
					} else {
						if (logger.isDebugEnabled()) {
							logger.debug("without session-expires header field");
						}
						// This has been moved as an attribute at object level
						// SipServletRequest relayRequest = null;
						if (partyA != null
								&& request.getSession().getId()
										.equalsIgnoreCase(partyA.getId())) {
							this.cancelSessionExpiryTimer(Constants.SESSION_EXPIRY_TIMER_FOR_A_PARTY);
							// changes for hold
							// now re-invite sends through
							// MediaServerInfoHandler when play stop completed
							if (this.isHoldRequest(request)) {
								if (sbb instanceof MsSessionControllerImpl
										|| sbb instanceof GroupedMsSessionControllerImpl) {
									this.handleUpdateSDP();
									if (playMedia) {
										this.reInviteRequest = request;
										return;
									}
									if (logger.isDebugEnabled()) {
										logger.debug("Session-Expires::re-invite recevied for update sdp and no media playing right now ");
									}
								}

							}
							// ----
							// UAT-745
							if (partyB != null
									&& ((Integer) partyB
											.getAttribute(Constants.ATTRIBUTE_DIALOG_STATE))
											.intValue() == Constants.STATE_CONFIRMED) {
								sessRefReqOut = partyB
										.createRequest(Constants.METHOD_INVITE);
							} else {
								// There is a race condition where dialout is
								// going on and Session refresh
								// reinvite came from Party-A, since party A SDP
								// is not associated with SBB
								// so it will be considered as reinvite for
								// update SDP, but when it tries to
								// send INVITE to Party-B, it will not find
								// party B and ends up here, so
								// setting the attribute to false which will be
								// checked when ACK is received
								// from Party-A and then we need not to relay
								// ACK there
								inviteToPartyBSent = false;
								logger.error("Party B is null or not in confirmed state");
								// There is a race condition where
								SipServletResponse resp = request
										.createResponse(200);
								this.addHeaders(request, resp, sbb);
								try {
									sendResponse(resp, false);
								} catch (Rel100Exception e) {
									logger.error(e.getMessage(), e);
								} catch (IOException e) {
									logger.error(e.getMessage(), e);
								}
								return;
							}
						} else {
							this.cancelSessionExpiryTimer(Constants.SESSION_EXPIRY_TIMER_FOR_MS);
							sessRefReqOut = partyA
									.createRequest(Constants.METHOD_INVITE);
						}
						// relay request...
						try {
							if (logger.isDebugEnabled()) {
								logger.debug("relay sessionrefresh with: PIGGY_BACK_ORIG_REQ is  ..."
										+ request);
							}
							this.setHeadersOnOutRequest(request, sessRefReqOut);
							sessRefReqOut.setAttribute(
									Constants.PIGGY_BACK_ORIG_REQ, request);
							sessRefReqOut.setContent(request.getContent(),
									request.getContentType());
							sendRequest(sessRefReqOut);
							// relayRequest.getSession().setAttribute(Constants.PENDING_REQUEST,
							// true);
							return;

						} catch (UnsupportedEncodingException e) {
							logger.error(e.getMessage(), e);
						} catch (IOException e) {
							logger.error(e.getMessage(), e);
						}

					}
				}

			} else {
				// app return NOOP so sends 200ok
				if (logger.isDebugEnabled()) {
					logger.debug("<SBB> Application has handled the message, so only responding with 200 OK for re-invite");
				}

				try {
					SipServletResponse response = request.createResponse(200);
					this.sendResponse(response, false);
				} catch (IOException exp) {
					logger.error("Not able to send response ", exp);
				} catch (Rel100Exception e) {
					logger.error("Not able to send response ", e);
				}
				return;
			}

		}
		// ---------------------------------------
		// ACK handling
		if (request.getMethod().equalsIgnoreCase(Constants.METHOD_ACK)) {
			if (logger.isInfoEnabled()) {
				logger.info("<SBB> "
						+ request.getMethod()
						+ " from party Network, sending notification to application");
			}

			SBB sbb = (SBB) operCtx;
			SipSession partyA = sbb.getA();
			SipSession partyB = sbb.getB();

			boolean isMsDisconnectReqd = false;

			// received ack for re-invite for session refresh
			if (this.reInviteWithSameSDP) {
				if (logger.isDebugEnabled()) {
					logger.debug("received ack for reinvte of session expiry");
				}
				this.reInviteWithSameSDP = false;

				// @abaxi : Added to check when ACK for MS Leg Session Refresh
				// received and A Party no longer in valid state
				// then disconnect media server after firing SIG Complete event.

				if (partyB != null
						&& partyA != null
						&& request.getSession().getId()
								.equalsIgnoreCase(partyB.getId())) {

					if (partyA.isValid()
							&& partyA.getState() == SipSession.State.INITIAL
							|| partyA.getState() == SipSession.State.TERMINATED) {
						isMsDisconnectReqd = true;
					} else if (!partyA.isValid()) {
						isMsDisconnectReqd = true;
					} else {
						if (logger.isDebugEnabled())
							logger.debug("Party A Session in confirmed/early state so ms dissconnect not required.");
					}
				}
			} else if (inviteToPartyBSent) {
				handleAckRequestFromNetwork(request);
			}
			// handleAckRequestFromNetwork(request);
			if ((this.lastFiredEvent != null)
					&& (this.lastFiredEvent
							.equals(SBBEvent.EVENT_SIG_IN_PROGRESS))) {
				SBBEvent sigCompletedEvent = new SBBEvent(
						SBBEvent.EVENT_SIG_COMPLETED);
				sigCompletedEvent.setMessage(request);
				this.lastFiredEvent = SBBEvent.EVENT_SIG_COMPLETED;
				operCtx.fireEvent(sigCompletedEvent);
			}
			setCompleted(true);

			if (isMsDisconnectReqd && sbb instanceof MsSessionController) {
				if (logger.isDebugEnabled()) {
					logger.debug("Party A Session not in confirmed/early state so dissconnecting of mediaserver required to stop session refresh.");
				}
				try {
					((MsSessionController) sbb).disconnectMediaServer();
				} catch (Exception ex) {
					logger.error("Not able disconnect media server", ex);
				}
			}
			return;
		}
		// Cancel handling
		// cancel will only come from network
		else if (request.getMethod().equalsIgnoreCase(Constants.METHOD_CANCEL)) {
			if (logger.isInfoEnabled()) {
				logger.info("<SBB> "
						+ request.getMethod()
						+ " from party Network, no notification to application is required");
			}
			handleCancelRequestFromNetwork(request);
			return;
		}

		// PRACK handling
		else if (request.getMethod().equalsIgnoreCase(Constants.METHOD_PRACK)) {
			responseFromApp = SBBEventListener.CONTINUE;
		}

		// other requests
		else {
			// bye received, session refresh timer must be cancel
			// @abaxi BUG 12891 fix cancel session expiry timer before handing
			// control to application, because application can remove party A or
			// MS
			if (request.getMethod().equalsIgnoreCase(Constants.METHOD_BYE)) {
				this.cancelSessionExpiryTimer(Constants.SESSION_EXPIRY_TIMER_FOR_A_PARTY);
				this.cancelSessionExpiryTimer(Constants.SESSION_EXPIRY_TIMER_FOR_MS);
			}
			if (logger.isInfoEnabled()) {
				logger.info("<SBB>Mid call signalling, handling control to application ");
			}

			SBBEvent sigInProgressEvent = new SBBEvent(
					SBBEvent.EVENT_SIG_IN_PROGRESS);
			sigInProgressEvent.setMessage(request);
			this.lastFiredEvent = SBBEvent.EVENT_SIG_IN_PROGRESS;

			responseFromApp = operCtx.fireEvent(sigInProgressEvent);
		}

		if (responseFromApp == SBBEventListener.CONTINUE) {

			SBB sbb = (SBB) operCtx;
			SipSession partyA = sbb.getA();
			SipSession partyB = sbb.getB();
			if (logger.isInfoEnabled()) {
				logger.info("<SBB> Applying default handling for this messages");
			}

			// relaying the message to other party
			SipSession peerSession = null;
			SipServletRequest relayRequest = null;

			// Mukesh
			String attCPACheck = "false";
			SipApplicationSession appsession = sbb.getApplicationSession();
			SipServletRequest origRequest = (SipServletRequest) appsession
					.getAttribute(ORIG_INITIAL_REQUEST);
			if (appsession.getAttribute(ATT_CPA_CHECK) != null) {
				attCPACheck = (String) appsession.getAttribute(ATT_CPA_CHECK);
			}

			if (logger.isDebugEnabled()) {
				logger.debug("Handling Cancel....OrigRequest is ::::"
						+ origRequest);
				logger.debug("attcpacheck is :::::" + attCPACheck);
				logger.debug("Request is received from Session :::::"
						+ request.getSession().getId());
			}

			if (partyA != null) {
				logger.debug("Party A Session id :::::" + partyA.getId());
			}

			if (partyB != null) {
				logger.debug("Party B Session id :::::" + partyB.getId());
			}

			if (partyA != null
					&& request.getSession().getId()
							.equalsIgnoreCase(partyA.getId())) {
				if (logger.isInfoEnabled()) {
					logger.info("<SBB> Received [" + request.getMethod()
							+ "] from party-A");
				}
				peerSession = partyB;
				/*
				 * if(request.getMethod().equals(Constants.METHOD_BYE)){
				 * request.
				 * getApplicationSession().setAttribute(prepaidAppSessionAttributes
				 * .ORIG_HUNG_UP, true);
				 * 
				 * }
				 */
			} else if (partyB != null
					&& request.getSession().getId()
							.equalsIgnoreCase(partyB.getId())) {
				if (logger.isInfoEnabled()) {
					logger.info("<SBB> Received [" + request.getMethod()
							+ "] from party-B");
				}
				peerSession = partyA;
			}
			// Bug 8718 ::Modified . This is specific to ATT Govt project only.
			// Added checks that if we recieve Bye from Party A in dialout when
			// it is still not connected to intial party then only we need to
			// send 480 response to initial response.
			if (logger.isDebugEnabled()) {
				logger.debug("PeerSession is :::" + peerSession);
				logger.debug("Party B is :::" + partyB);
				logger.debug("PArty A is  :::" + partyA);
			}
			// HAndle BYE request from B party when B party disconnect while
			// hearing announcemnet.
			// Changes doen are for CPA call flow for ATT Govt Project.
			if (attCPACheck.equalsIgnoreCase(AseStrings.TRUE_SMALL)
					&& request.getMethod().equals(Constants.METHOD_BYE)
					&& peerSession.equals(partyB)) {
				try {
					SipSession origSession = origRequest.getSession();
					int dialogState = ((Integer) origSession
							.getAttribute(Constants.ATTRIBUTE_DIALOG_STATE))
							.intValue();
					if (logger.isDebugEnabled()) {
						logger.debug("Received Bye during Media Player");
						logger.debug("Dialog state of another party to which we need to send response is ::"
								+ dialogState);
					}
					if (dialogState == Constants.STATE_UNDEFINED
							|| dialogState == Constants.STATE_INITIAL
							|| dialogState == Constants.STATE_EARLY) {
						if (logger.isDebugEnabled()) {
							logger.debug(request.getCallId()
									+ " got the request " + request);
						}
						SipServletResponse tempNotAvailable = origRequest
								.createResponse(480);
						if (logger.isDebugEnabled()) {
							logger.debug(request.getCallId() + " 480 response "
									+ tempNotAvailable);
						}
						sendResponse(tempNotAvailable, false);
						if (logger.isDebugEnabled()) {
							logger.debug(request.getCallId()
									+ " 480 response send to A "
									+ tempNotAvailable);
						}
					}
            	}catch(Exception e){
            		if(logger.isEnabledFor(Priority.INFO)){
            			logger.info(e.getMessage(), e);
            		}
            	}
            }
            SipServletResponse relayResponse = null;
            if(peerSession != null && request.getMethod().equals(Constants.METHOD_BYE)){
            	int dialogState =((Integer) peerSession.getAttribute(Constants.ATTRIBUTE_DIALOG_STATE)).intValue();
            	
            	if(logger.isDebugEnabled()){
            		logger.debug(request.getCallId()+" Peer Session is not null and request reecived is BYE and Peer dialog state is "+dialogState);
            	}
            	if (partyA!=null &&peerSession.equals(partyA)) {

            		if(logger.isDebugEnabled()){
                		logger.debug(request.getCallId()+" Peer Session is same as A Session");
                	}
            		String reasonHdr = (String) sbb.getAttribute(MsSessionController.PARTY_A_REASON_HDR);
            		if((dialogState == Constants.STATE_UNDEFINED) || (dialogState == Constants.STATE_EARLY)){
           				if (logger.isInfoEnabled()) {
           					logger.info("<SBB> Dialog is in EARLY state so creating a 487 Response for Party-A");
           				}
                		SipServletRequest iniRequest = (SipServletRequest)peerSession.getAttribute(Constants.ATTRIBUTE_INIT_REQUEST);
                		//Need to send the response code received from Service
    	            	Integer responseCode = (Integer) sbb.getAttribute(MsSessionController.PARTY_A_EARLY_RESP_CODE);
    	            	if (responseCode != null){
    	            		relayResponse = iniRequest != null ? iniRequest.createResponse(responseCode) : null;
    	            	}else{
    	            		relayResponse = iniRequest != null ? iniRequest.createResponse(487) : null;	
    	            	}
    	            	
    	            	if (reasonHdr != null){
    	            		relayResponse.addHeader(Constants.HDR_REASON, reasonHdr);
    	            	}
                		setREL(relayResponse);
            		}else if (dialogState == Constants.STATE_CONFIRMED) {
            			if (logger.isInfoEnabled()) {
            				logger.info("<SBB> Dialog is in CONFIRMED state so creating a BYE request");
            			}
                		relayRequest = peerSession.createRequest(Constants.METHOD_BYE);
    	            	if (reasonHdr != null){
    	            		relayRequest.addHeader(Constants.HDR_REASON, reasonHdr);
    	            	}
                		setREL(relayRequest);
            		}
 
            	}else if (partyB!=null && peerSession.equals(partyB)){
            		
            		if(logger.isDebugEnabled()){
                		logger.debug(request.getCallId()+" Peer Session is same as B Session");
                	}
            		//@saneja-UAT194 race condition
            		State sipSessionState = peerSession.getState();
            		if (sipSessionState == State.EARLY || sipSessionState == State.INITIAL) {
            		//if ((dialogState == Constants.STATE_UNDEFINED) || (dialogState == Constants.STATE_EARLY)) {
            			if (logger.isInfoEnabled()) {
            				logger.info("<SBB> Dialog is in EARLY state so creating a CANCEL request instead of BYE");
            			}
                		SipServletRequest iniRequest = (SipServletRequest)
                		peerSession.getAttribute(Constants.ATTRIBUTE_INIT_REQUEST);
                		try{
                			relayRequest = iniRequest != null ? iniRequest.createCancel() : null;
                			
                			//
                			if(relayRequest!=null){
                				SipServletResponse byeResp = request.createResponse(200);
                        		try{
                        			sendResponse(byeResp, false);
                        			if (logger.isDebugEnabled()) {
                        				logger.debug("Send 200ok for BYE as relay request is CANCEL");
                        			}
                        		}catch(Rel100Exception e){
                        			if (logger.isDebugEnabled()) {
                        				logger.debug(e.getMessage(),e);
                        			}
                        		}catch (Exception e) {
                        			if (logger.isDebugEnabled()) {
                        				logger.debug(e.getMessage(),e);
                        			}
        						}
                			}
                			
                		}catch(Exception e){
                			relayRequest=null;
                			if (logger.isDebugEnabled()) {
                				logger.debug("exception while creating cancel request");
                			}
                		}
                	} else if (sipSessionState == State.CONFIRMED) {
            		//}else if (dialogState == Constants.STATE_CONFIRMED) {
                		if (logger.isInfoEnabled()) {
                			logger.info("<SBB> Dialog is in CONFIRMED state so creating a BYE request");
                		}
                		
                		/* For the Dialogic Media Server INFO is not received for the PLAY operation after sending BYE so
        				 * only stop INFO request is sent.
        				 * For PLAY COLLECT and PLAY RECORD INFO is received both for playcollect or playrecord 
        				 * request and also for the stop request afterwards so BYE operation is handled after receiving
        				 * final INFO request.
        				 * The stop operation is not handled for the PLAY_VXML operation.
        				 */
                		if(sbb instanceof MsSessionControllerImpl || sbb instanceof GroupedMsSessionControllerImpl){
                			try {
                				Iterator itr = ((SBBImpl)sbb).getOperations().iterator();
                				while(itr.hasNext()) {
                					SBBOperation oper = (SBBOperation)itr.next();
                					if(oper instanceof MediaServerInfoHandler){
                						this.operation = ((MediaServerInfoHandler)oper).getOperation();
                						MsSessionControllerImpl msSbb=((MsSessionControllerImpl)sbb);
                						//Modified the implementation as same for both play as well as 
                						//play_collect or play_record operations. As it is observed that service 
                						//is not handling the bye operation.
                						if(this.operation == PLAY){
                							//In case of play operation after sending BYE request to media server
                							//INFO for stop INFO request doesn't come from media server.
                							//So in this case BYE is sent to media server upfront and will 
                							//send the 200 OK to originating party when response(BYE) from
                							//Media Server
                							//Temp Fix...
                							
                							SipServletResponse response = request.createResponse(200);
                							this.sendResponse(response, false);
                							msSbb.stopMediaOperations();
                							return;
                						}else if((this.operation == PLAY_COLLECT) || (this.operation == PLAY_RECORD)){
                							//In case of play_collect and play_record operations after sending 
                							//BYE request to media server INFO for stop INFO request comes from media server.
                							//So when INFO(STOP INFO) comes from Media Server then SBB sends the BYE 
                							//request. Thus not sending bye this time and also handling the bye from
                							//originating party.

                							SipServletResponse response = request.createResponse(200);
                							this.sendResponse(response, false);
                							
                							MsAdaptor msAdaptor=msSbb.getMsAdaptor();
                							
                						  if(msAdaptor != null && msAdaptor.getClass().getName().contains(Constants.MSML_TYPE)) {
                							
                							  MsCollectSpec collectSpec=((MediaServerInfoHandler)oper).getCollectSpec();
                							
                							  MsRecordSpec recordSpec=((MediaServerInfoHandler)oper).getRecordSpec();
                							
                							if (logger.isDebugEnabled()) {
												logger.debug("Collectspec is  "+collectSpec);
											}
                							
                							if (logger.isDebugEnabled()) {
												logger.debug("RecordSpec is  "+recordSpec);
											}
                							int timerDuration=-1;
                							
//                							if (collectSpec!= null
//                									&& (collectSpec.getExtraDigitTimer() > 0 || collectSpec.getInterDigitTimer() > 0)) {
//
//												timerDuration = collectSpec
//														.getInterDigitTimer();
//												if (timerDuration <= 0) {
//													timerDuration = collectSpec
//															.getExtraDigitTimer();
//												}
//												
//												timerDuration=timerDuration+1000; //adding 1 sec as margin, here duration was in ms)
//												
//												if (logger.isDebugEnabled()) {
//													logger.debug("Create timer for stopping ms play collect operation in  "
//															+timerDuration
//															+ " ms...");
//												}		
//											}else if (recordSpec != null
//													&& (recordSpec.getPostSpeechTimer() > 0)) {
//
//												timerDuration = recordSpec
//														.getPostSpeechTimer();
//												
//												timerDuration=timerDuration*1000+1000; //adding 1 sec as margin, here duration was in seconds)
//												
//												if (logger.isDebugEnabled()) {
//													logger.debug("Create timer for stopping ms play record operation in  "
//															+ timerDuration
//															+ " ms...");
//												}
//											} 
												if (timerDuration > 0) {		

													if (logger.isDebugEnabled()) {
														logger.debug("Creating timer for stopping ms operation in  "
																+ timerDuration
																+ " ms..and setting ATTRIBUTE_OPERATION_STOPPED in mssbb that operation was stopped ");
													}
													TimerService timerService = (TimerService) msSbb
															.getServletContext()
															.getAttribute(
																	SipServlet.TIMER_SERVICE);

													ServletTimer timer = timerService
															.createTimer(
																	response.getApplicationSession(),
																	timerDuration,
																	false,
																	new TimerInfo(
																			Constants.STOP_MS_OPER_AFTER_TIMER,
																			msSbb));

													msSbb.setAttribute(
															Constants.ATTRIBUTE_OPERATION_STOPPED,
															timer.getId());
												} else {

													if (logger.isDebugEnabled()) {
														logger.debug("No timer value available for stopping ms operation on timer, stop it now");
													}
													msSbb.stopMediaOperations();
												}
											} else {
												if (logger.isDebugEnabled()) {
													logger.debug("Stop media operations now and return from here , donot need to wait as its not MSML based ms");
												}
												msSbb.stopMediaOperations();
											}

											return;
										}// play record or play collect
											// operations
									}
								}
								relayRequest = peerSession
										.createRequest(Constants.METHOD_BYE);
							} catch (Exception e) {
								logger.error(e.getMessage(), e);
							}
						}
						relayRequest = peerSession
								.createRequest(Constants.METHOD_BYE);

						try {
							SipServletResponse response = request
									.createResponse(200);
							this.sendResponse(response, false);
						} catch (Exception e) {
							logger.error(
									"Excpton while sending response "
											+ e.getMessage(), e);
						}

					}
				}
			}
			if (peerSession != null
					&& !request.getMethod().equals(Constants.METHOD_BYE)) {
				if (request.getMethod().equals(Constants.METHOD_INVITE)
						&& !request.isInitial()
						&& request.getSession() == partyA
						&& ((Boolean) partyB
								.getAttribute("ReceivedFinalResponseFromB") != null)
						&& !((Boolean) partyB
								.getAttribute("ReceivedFinalResponseFromB"))
								.booleanValue()) {
					if (logger.isDebugEnabled()) {
						logger.debug("re-INVITE received from A, while INVITE request pending with B");
					}
					try {
						SipServletResponse response = request
								.createResponse(491);
						response.send();
						return;
					} catch (Exception exp) {
						logger.error("Exception in sending 491", exp);
					}
				} else {
					relayRequest = peerSession.createRequest(request
							.getMethod());
				}
			}

			// Handle the case, when we are not able to piggy-back this request.
			// Send an error response to this request so as to terminate this
			// transaction.
			if (relayRequest == null && relayResponse == null) {
				if (logger.isDebugEnabled()) {
					logger.debug("Unable to get the peer request From the SBB. So just sending the default response.");
				}

				try {
					SipServletResponse resp = null;
					this.setCompleted(true);
					if (request.getMethod().equals(Constants.METHOD_BYE)) {
						if (logger.isDebugEnabled()) {
							logger.debug("handleRequest(): Dispatching DISCONNECTED event to event listener...");
						}
						// Create 200 response by default.
						resp = request.createResponse(200);
						byte[] rlc_isup = (byte[]) this.getOperationContext()
								.getSBB()
								.getAttribute(MsSessionController.RLC_ISUP);
						if (rlc_isup != null) {
							Multipart mp = new MimeMultipart();
							try {
								SBBResponseUtil.formMultiPartMessage(mp,
										rlc_isup, Constants.ISUP_CONTENT_TYPE,
										null);
							} catch (MessagingException e) {
								logger.error(e.getMessage(), e);
							}
							this.getOperationContext()
									.getSBB()
									.setAttribute(MsSessionController.RLC_ISUP,
											null);
							resp.setContent(mp, mp.getContentType());
						} else {
							if (logger.isDebugEnabled()) {
								logger.debug("RLC is not set by Service");
							}
						}
					}

					resp = resp != null ? resp : request
							.createResponse(DEFAULT_RESPONSE_CODE);
					this.sendResponse(resp, false);

					// Send a DISCONNECTED event to the SBB. if the request is
					// from IVR only
					// Providing a null check for the party B as in case when we
					// need to clear both INAP as
					// well as Media Server Leg. Party B will be disconnected
					// first and then DFC will be sent
					// to INAP leg. On receipt of DFC, INAP leg sends BYE for
					// which we need to send 200 OK. But
					// at this time media server is already disconnected, hence
					// the null check.
					if (partyB != null
							&& request.getSession().getId()
									.equalsIgnoreCase(partyB.getId())) {
						SBBEvent event = new SBBEvent(
								SBBEvent.EVENT_DISCONNECTED);
						SBBOperationContext context = (SBBOperationContext) sbb;
						this.lastFiredEvent = SBBEvent.EVENT_DISCONNECTED;
						context.fireEvent(event);
					}

				} catch (IOException e) {
					logger.error(e.getMessage(), e);
				} catch (Rel100Exception e) {
					logger.error(e.getMessage(), e);
				}
				return;
			} else if (relayResponse != null) {
				if (logger.isDebugEnabled()) {
					logger.debug("handleRequest(): Sending the 487 Response to Party-A and 200 OK (BYE) to Party-B");
					logger.debug("handleRequest(): Generating a disconnected event to the application");
				}
				try {
					sendResponse(relayResponse, false);
					SipServletResponse response = request.createResponse(200);
					this.sendResponse(response, false);
					SBBEvent event = new SBBEvent(SBBEvent.EVENT_DISCONNECTED);
					SBBOperationContext context = (SBBOperationContext) sbb;
					this.lastFiredEvent = SBBEvent.EVENT_DISCONNECTED;
					context.fireEvent(event);
				} catch (Rel100Exception e) {
					logger.error(e.getMessage(), e);
				} catch (IOException e) {
					logger.error(e.getMessage(), e);
				}
				return;
			}

			// piggy back the original request
			relayRequest.setAttribute(Constants.PIGGY_BACK_ORIG_REQ, request);

			if (logger.isDebugEnabled()) {
				logger.debug("handleRequest(): PIGGY_BACK_ORIG_REQ is  ..."
						+ request);
			}
			// attach the originating SDP if any
			Object content = null;
			String contentType = null;
			int contentLenght = request.getContentLength();
			try {
				if (!request.getMethod().equals(Constants.METHOD_BYE)) {
					content = request.getContent();
					contentType = request.getContentType();
					if (contentLenght != 0) {
						relayRequest.setContent(content, contentType);
					}

					if (request.getMethod().equals(Constants.METHOD_UPDATE)) {

						if (!handleSessionRefreshForUpdate(request, sbb)) {

							if (logger.isDebugEnabled()) {
								logger.debug("handleRequest(): Donot relay update as incoming update has no content ...");
							}
							return;
						}

						else {
							Iterator valueList = request
									.getHeaders(Constants.HDR_SUPPORTED);
							while (valueList.hasNext()) {
								String supportedHeaderValue = (String) valueList
										.next();
								
									relayRequest.setHeader(
											Constants.HDR_SUPPORTED,
											supportedHeaderValue);

							}
							Iterator valueListReq = request
									.getHeaders(Constants.HDR_REQUIRE);
							while (valueListReq.hasNext()) {
								String reqHeaderValue = (String) valueListReq
										.next();
								
									relayRequest.setHeader(
											Constants.HDR_REQUIRE,
											reqHeaderValue);

							}

						}
					}
				}

				sendRequest(relayRequest);
				// UAT-745
				/*
				 * if (relayRequest.getMethod().equals("INVITE")){ if
				 * (logger.isInfoEnabled()) {
				 * logger.info("<SBB> Setting request pending attribute for 491"
				 * ); }
				 * relayRequest.getSession().setAttribute(Constants.PENDING_REQUEST
				 * , true); }
				 */
			} catch (IOException exp) {
				logger.error("Not able to send request ", exp);
			} catch (Exception exp) {
				logger.error("Not able to extract content", exp);
			}
		} else {
			// logger.info("<SBB> Application has handled the message, so not doing any processing");
			if (logger.isInfoEnabled()) {
				logger.info("<SBB> Application has handled the message, so only responding with 200 OK");
			}

			try {
				SipServletResponse response = request.createResponse(200);

				if (request.getMethod().equalsIgnoreCase(Constants.METHOD_BYE)) {
					byte[] rlc_isup = (byte[]) this.getOperationContext()
							.getSBB()
							.getAttribute(MsSessionController.RLC_ISUP);
					if (rlc_isup != null) {
						Multipart mp = new MimeMultipart();
						try {
							SBBResponseUtil.formMultiPartMessage(mp, rlc_isup,
									Constants.ISUP_CONTENT_TYPE, null);
						} catch (MessagingException e) {
							logger.error(e.getMessage(), e);
						}
						this.getOperationContext()
								.getSBB()
								.setAttribute(MsSessionController.RLC_ISUP,
										null);
						response.setContent(mp, mp.getContentType());
						if (logger.isDebugEnabled()) {
							logger.debug("RLC is set by Service for BYE");
						}
					} else {
						if (logger.isDebugEnabled()) {
							logger.debug("RLC is not set by Service for BYE");
						}
					}
				}

				this.sendResponse(response, false);
			} catch (IOException exp) {
				logger.error("Not able to send response ", exp);
			} catch (Rel100Exception e) {
				logger.error("Not able to send response ", e);
			}
		}

	}

	private void handleAckRequestFromNetwork(SipServletRequest request) {

		SBB sbb = (SBB) getOperationContext();
		SipSession thisSession = request.getSession();
		SipSession peerSession = null;

		if (request.getSession().getId().equalsIgnoreCase(sbb.getA().getId())) {
			peerSession = sbb.getB();
		} else {
			peerSession = sbb.getA();
		}

		SipServletResponse response = null;
		if (peerSession != null) {
			// Extract the 200 stored in peer session for creating ACK
			response = (SipServletResponse) peerSession
					.getAttribute(SBBOperationContext.ATTRIBUTE_INV_RESP);
			// remove the ATTRIBUTE as its not required any more
			peerSession.removeAttribute(SBBOperationContext.ATTRIBUTE_INV_RESP);
		} else {
			logger.error("<SBB> Illegal state as peer session is not available");
		}
		if (response != null) {
			SipServletRequest ack = response.createAck();
			// Attached the SDP if present
			try {
				Object content = request.getContent();
				String contentType = request.getContentType();
				if (content != null) {
					ack.setContent(content, contentType);
				}
				sendRequest(ack);
			} catch (Exception exp) {
				logger.error("Invalid request Content");
			}
		} else {
			logger.error("<SBB> 200 response not stored in session, as ACK would already be sent to the other party");
		}
	}

	private void handleCancelRequestFromNetwork(SipServletRequest request) {
		if (logger.isDebugEnabled()) {
			logger.debug("Inside handleCancelRequestFromNetwork ");
		}

		SBB sbb = (SBB) getOperationContext();
		SipSession thisSession = request.getSession();
		SipSession peerSession = null;

		// mark orig side state as terminated
		thisSession.setAttribute(Constants.ATTRIBUTE_DIALOG_STATE,
				Constants.STATE_TERMINATED);

		// in case of cancel wlae ia never expected to be executed..
		// added only for debugging purpose
		if (request.getSession().getId().equalsIgnoreCase(sbb.getA().getId())) {
			if (logger.isDebugEnabled()) {
				logger.debug("handleCancelRequestFromNetwork got Party B as peer session");
			}
			peerSession = sbb.getB();
		} else {
			if (logger.isDebugEnabled()) {
				logger.debug("handleCancelRequestFromNetwork got Party A as peer session");
			}
			peerSession = sbb.getA();

		}

		int dialogState = ((Integer) peerSession
				.getAttribute(Constants.ATTRIBUTE_DIALOG_STATE)).intValue();

		State sipSessionState = peerSession.getState();

		SipServletRequest relayRequest = null;
		if (sipSessionState == State.EARLY || sipSessionState == State.INITIAL) {
			if (logger.isInfoEnabled()) {
				logger.info("<SBB> handleCancelRequestFromNetwork Dialog is in EARLY state so creating a CANCEL request instead of BYE");
			}
			SipServletRequest iniRequest = (SipServletRequest) peerSession
					.getAttribute(Constants.ATTRIBUTE_INIT_REQUEST);
			relayRequest = iniRequest != null ? iniRequest.createCancel()
					: null;
			peerSession.removeAttribute(Constants.ATTRIBUTE_INIT_REQUEST);
		} else if (sipSessionState == State.CONFIRMED) {
			if (logger.isInfoEnabled()) {
				logger.info("<SBB> handleCancelRequestFromNetwork Dialog is in CONFIRMED state so creating a BYE request");
			}
			this.fireEvent(SBBEvent.EVENT_SIG_IN_PROGRESS,
					SBBEvent.REASON_CODE_CANCELLED_BY_ENDPOINT, request);
			/*
			 * For the Dialogic Media Server INFO is not received for the PLAY
			 * operation after sending BYE so only stop INFO request is sent.
			 * For PLAY COLLECT and PLAY RECORD INFO is received both for
			 * playcollect or playrecord request and also for the stop request
			 * afterwards so BYE operation is handled after receiving final INFO
			 * request. The stop operation is not handled for the PLAY_VXML
			 * operation.
			 */
			if (sbb instanceof MsSessionControllerImpl
					|| sbb instanceof GroupedMsSessionControllerImpl) {
				try {
					Iterator itr = ((SBBImpl) sbb).getOperations().iterator();
					while (itr.hasNext()) {
						SBBOperation oper = (SBBOperation) itr.next();
						if (oper instanceof MediaServerInfoHandler) {
							this.operation = ((MediaServerInfoHandler) oper)
									.getOperation();
							// Modified the implementation as same for both play
							// as well as
							// play_collect or play_record operations. As it is
							// observed that service
							// is not handling the bye operation.
							if (this.operation == PLAY) {
								// In case of play operation after sending BYE
								// request to media server
								// INFO for stop INFO request doesn't come from
								// media server.
								// So in this case BYE is sent to media server
								// upfront and will
								// send the 200 OK to originating party when
								// response(BYE) from
								// Media Server
								// Temp Fix...

								((MsSessionControllerImpl) sbb)
										.stopMediaOperations();
								return;
							} else if ((this.operation == PLAY_COLLECT)
									|| (this.operation == PLAY_RECORD)) {
								// In case of play_collect and play_record
								// operations after sending
								// BYE request to media server INFO for stop
								// INFO request comes from media server.
								// So when INFO(STOP INFO) comes from Media
								// Server then SBB sends the BYE
								// request. Thus not sending bye this time and
								// also handling the bye from
								// originating party.

								((MsSessionControllerImpl) sbb)
										.stopMediaOperations();
								return;
							}
						}
					}
				} catch (Exception e) {
					logger.error(e.getMessage(), e);
				}
			}
			// BYE will not be sent here as CANCEL will always arrive at
			// Connect/EalryMediaConnect
			// handler once 200 OK is received from Media Server. If 200 OK is
			// not arrived then BYE
			// is being sent from Connect or early media connect handler on
			// receiving 200 OK from
			// Media Server
			// relayRequest = peerSession.createRequest(Constants.METHOD_BYE);

			// cancel session expiry timer
			this.cancelSessionExpiryTimer(Constants.SESSION_EXPIRY_TIMER_FOR_A_PARTY);
			this.cancelSessionExpiryTimer(Constants.SESSION_EXPIRY_TIMER_FOR_MS);
		}
		int contentLength = request.getContentLength();

		if (contentLength > 0 && relayRequest != null) {
			this.setSDP(request, relayRequest);
		}

		try {
			if (relayRequest != null) {
				sendRequest(relayRequest);
				this.fireEvent(SBBEvent.EVENT_CONNECT_FAILED,
						SBBEvent.REASON_CODE_CANCELLED_BY_ENDPOINT,
						relayRequest);
			}
		} catch (IOException e) {
			logger.error("IOException Error sending peer request on cancel", e);
		}

	}

	private void setSDP(SipServletRequest request,
			SipServletRequest relayRequest) {
		try {
			Object content = request.getContent();
			String contentType = request.getContentType();
			if (contentType.startsWith(Constants.SDP_MULTIPART)) {
				int sdpBpIndx = -1;
				MimeMultipart multipart = null;
				multipart = (MimeMultipart) content;
				int count = multipart.getCount();
				for (int i = 0; i < count; i++) {
					if (multipart.getBodyPart(i).getContentType()
							.startsWith(Constants.SDP_CONTENT_TYPE)) {
						sdpBpIndx = i;
						break;
					}
				}
				if (sdpBpIndx != -1) {
					byte[] bp;
					ByteArrayInputStream bis = (ByteArrayInputStream) multipart
							.getBodyPart(sdpBpIndx).getContent();
					int bytes = bis.available();
					bp = new byte[bytes];
					bis.read(bp, 0, bytes);
					relayRequest.setContent(bp, Constants.SDP_CONTENT_TYPE);
				} else {
					if (logger.isInfoEnabled()) {
						logger.info("<SBB> No SDP content associated with  multipart "
								+ request.getMethod() + " request");
					}
				}

			} else {
				relayRequest.setContent(content, contentType);
			}
		} catch (MessagingException e) {
			logger.error("Exception in saving SDP " + e);
		} catch (UnsupportedEncodingException e1) {
			logger.error(
					"UnsupportedEncodingException Error setting cotent in peer request on cancel",
					e1);
		} catch (IOException e1) {
			logger.error(
					"UnsupportedEncodingException Error setting cotent in peer request on cancel",
					e1);
		} catch (Exception e) {
			logger.error("Exception in saving SDP " + e);
		}
	}

	/**
	 * This method handles all response from party issued a BYE request
	 *
	 * @response - Response .
	 */
	public void handleResponse(SipServletResponse response) {
		boolean loggerEnabled = logger.isDebugEnabled();

		SBB sbb = (SBB) getOperationContext();

		if (response.getRequest().getMethod().equals(Constants.METHOD_INVITE)
				&& response.getStatus() == SipServletResponse.SC_REQUEST_PENDING) {
			Double timerDuration = Double.valueOf(requestPendingTimerVal);
			timerDuration = timerDuration * 1000;
			TimerService ts = (TimerService) sbb.getServletContext()
					.getAttribute(SipServlet.TIMER_SERVICE);
			// --changes for ft---------
			AseTimerInfo aseTimerInfo = new AseTimerInfo();
			aseTimerInfo.setSbbName(sbb.getName());
			ServletTimer timer = ts.createTimer(sbb.getApplicationSession(),
					timerDuration.longValue(), false, aseTimerInfo);
			TimerInfo timerInfo = new TimerInfo(Constants.TIMER_FOR_REQ_PEND,
					this);
			((SBBImpl) sbb).setServletTimer(timer.getId(), timerInfo);
			logger.error("Timer Created for pending request to be answered");
			return;
		}
		if (loggerEnabled) {
			logger.debug("<SBB> entered handleResponse with following response :: "
					+ response);
		}

		// Handle the stray 200 Ok received from the network
		if (!playMedia
				&& response != null
				&& originatingMessage == response
				&& SBBResponseUtil.is200Ok(response)
				&& response.getRequest().getMethod()
						.equals(Constants.METHOD_INVITE)) { // reeta modied as
															// can send ACK for
															// only success
															// response

			if (loggerEnabled) {
				logger.debug("<SBB>Stray 200 OK received sending ACK and then BYE");
			}

			try {

				SipServletMessage ack = response.createAck();
				ack.send();

				SipServletMessage bye = response.getSession().createRequest(
						Constants.METHOD_BYE);
				bye.send();
			} catch (IOException e) {
				logger.error(e.getMessage(), e);
			}

			return;
		}

		playMedia = false;
		// relaying the response to other party
		SipServletRequest origRequest = (SipServletRequest) response
				.getRequest().getAttribute(Constants.PIGGY_BACK_ORIG_REQ);

		if (logger.isDebugEnabled()) {
			logger.debug("handleResponse(): PIGGY_BACK_ORIG_REQ is  ..."
					+ origRequest);
		}

		// fire event in case of hold call or unhold call
		if (response.getStatus() > 199 && response.getStatus() <= 299) {
			if (response.getMethod().equalsIgnoreCase(Constants.METHOD_INVITE)) {
				this.holdUnholdFireEvent(origRequest);
			}
		}
		/*
		 * if(response.getMethod().equalsIgnoreCase(Constants.METHOD_INVITE) &&
		 * !(response.getRequest().isInitial())){
		 * response.setAttribute(Constants.PENDING_REQUEST, false); }
		 */
		// -----
		if (response.getSession().getId().equalsIgnoreCase(sbb.getA().getId())) {
			if (logger.isInfoEnabled()) {
				logger.info("<SBB> Received" + "[" + response.getStatus()
						+ "] for [" + response.getMethod() + "]"
						+ " from party-A, relaying it to party-B");
			}
			if (response.getMethod().equalsIgnoreCase(Constants.METHOD_INVITE)
					&& response.getHeader(Constants.HDR_SESSION_EXPIRES) != null) {
				response.getSession().setAttribute(
						"SESSION_EXPIRES",
						this.getDeltaSeconds(response
								.getHeader(Constants.HDR_SESSION_EXPIRES)));
				this.startSessionExpiryTimer(null, Constants.TIMER_FOR_A_PARTY,
						Constants.SESSION_EXPIRY_TIMER_FOR_A_PARTY);
			}
			// Removing this piece of code as we need to send the 200 OK
			// response to Party-B
			// This is the case where BYE is initiated by the Party-B
			// if(response.getMethod().equals(Constants.METHOD_BYE)){
			// logger.info("Invalidating AppSession as originating was disconnected by service ");
			// response.getApplicationSession().invalidate();
			// return;
			// }
		} else {
			if (logger.isInfoEnabled()) {
				logger.info("<SBB> Received" + "[" + response.getStatus()
						+ "] for [" + response.getMethod() + "]"
						+ " from party-B, relaying it to party-A");
			}
			if (response.getMethod().equalsIgnoreCase(Constants.METHOD_INVITE)
					&& response.getHeader(Constants.HDR_SESSION_EXPIRES) != null) {
				// set delta secound value in current session..
				response.getSession().setAttribute(
						"SESSION_EXPIRES",
						this.getDeltaSeconds(response
								.getHeader(Constants.HDR_SESSION_EXPIRES)));
				this.startSessionExpiryTimer(null, Constants.TIMER_FOR_MS,
						Constants.SESSION_EXPIRY_TIMER_FOR_MS);
			}
		}
		try {

			// Need to call setComplete if its a final response
			if (SBBResponseUtil.isFinalResponse(response)) {
				if (response.getMethod().equalsIgnoreCase(
						Constants.METHOD_INVITE)) {
					if (logger.isInfoEnabled()) {
						logger.info("<SBB> Delaying setCompleted to ACK,"
								+ " and storing final response into session ");
					}
					response.getSession().setAttribute(
							SBBOperationContext.ATTRIBUTE_INV_RESP, response);

				} else {
					if (logger.isInfoEnabled()) {
						logger.info("<SBB> Network operation completed");
					}
					setCompleted(true);
				}
			}

			// attached the SDP from terminating party to outgoing message to
			// originating
			// party if present
			if (origRequest != null) {
				// changed for GroupedMSSBB, sending RLC in response out.
				SipServletResponse outgoingResponseToOrig = origRequest
						.createResponse(response.getStatus());
				int contentLength = response.getContentLength();
				Multipart mp = null;
				byte[] rlc_isup = (byte[]) this.getOperationContext().getSBB()
						.getAttribute(MsSessionController.RLC_ISUP);
				if (contentLength != 0 && rlc_isup == null) {
					outgoingResponseToOrig.setContent(response.getContent(),
							response.getContentType());
					if (response.getHeader(Constants.HDR_CONTENT_DISPOSITION) != null) {
						outgoingResponseToOrig
								.setHeader(
										Constants.HDR_CONTENT_DISPOSITION,
										response.getHeader(Constants.HDR_CONTENT_DISPOSITION));
					} else {
						outgoingResponseToOrig
								.setHeader(
										Constants.HDR_CONTENT_DISPOSITION,
										Constants.DEFAULT_VALUE_SDP_CONTENT_DISPOSITION);
					}
				} else if (contentLength != 0 && rlc_isup != null) {
					mp = new MimeMultipart();
					SBBResponseUtil
							.formMultiPartMessage(
									mp,
									(byte[]) response.getContent(),
									(String) response.getContentType(),
									response.getHeader(Constants.HDR_CONTENT_DISPOSITION));
					SBBResponseUtil.formMultiPartMessage(mp, rlc_isup,
							Constants.ISUP_CONTENT_TYPE, null);
				} else if (rlc_isup != null) {
					mp = new MimeMultipart();
					SBBResponseUtil.formMultiPartMessage(mp, rlc_isup,
							Constants.ISUP_CONTENT_TYPE, null);
				}
				// if (contentLength != 0) {
				// mp = new MimeMultipart();
				// SBBResponseUtil.formMultiPartMessage(mp,
				// (byte[])response.getContent(),
				// (String)response.getContentType());
				// }
				//
				// if(rlc_isup != null) {
				// mp = new MimeMultipart();
				// SBBResponseUtil.formMultiPartMessage(mp, rlc_isup,
				// Constants.ISUP_CONTENT_TYPE);
				// }
				// Multipart will only bet set when neither content is empty nor
				// rlc set by service
				// -change for session-expires

				if (response.getMethod().equalsIgnoreCase(
						Constants.METHOD_UPDATE)) {
					try {
						if (logger.isDebugEnabled()) {
							logger.debug("response for UPDATE received..");
						}

						Iterator requireValueList = response
								.getHeaders(Constants.HDR_REQUIRE);
						while (requireValueList.hasNext()) {
							String requireHeaderValue = (String) requireValueList
									.next();

							if (logger.isDebugEnabled()) {
								logger.debug("setting require header in out response to orig..");
							}
							outgoingResponseToOrig.addHeader(
									Constants.HDR_REQUIRE, requireHeaderValue);
						}
					} catch (Exception e) {
						logger.error("exception in setting require header in response to orig..");
					}

				}

				if (response.getMethod().equalsIgnoreCase(
						Constants.METHOD_INVITE)) {

					// String supportedHeaderValue =
					// (String)origRequest.getHeader(Constants.HDR_SUPPORTED);
					String supportedHeaderValue = null;
					Iterator valueList = origRequest
							.getHeaders(Constants.HDR_SUPPORTED);
					boolean suppTimerFound = false;
					while (valueList.hasNext()) {
						supportedHeaderValue = (String) valueList.next();
						if (supportedHeaderValue.contains(TIMER)) {
							outgoingResponseToOrig.setHeader(
									Constants.HDR_SUPPORTED,
									supportedHeaderValue);
							suppTimerFound = true;
							break;
						}
					}
					if (!suppTimerFound) {
						outgoingResponseToOrig.addHeader(
								Constants.HDR_SUPPORTED, TIMER);
					}
					// add session-expires header with refresher=uac
					if (origRequest.getHeader(Constants.HDR_SESSION_EXPIRES) != null) {
						String valueOfSessionExpires = this
								.getDeltaSeconds(origRequest
										.getHeader(Constants.HDR_SESSION_EXPIRES))
								+ ";refresher=uac";
						outgoingResponseToOrig.setHeader(
								Constants.HDR_SESSION_EXPIRES,
								valueOfSessionExpires);
						// add Require header
						String requireHeaderValue = null;
						boolean requireHeaderFound = false;
						Iterator requireValueList = response
								.getHeaders(Constants.HDR_REQUIRE);
						while (requireValueList.hasNext()) {
							requireHeaderValue = (String) requireValueList
									.next();
							if (requireHeaderValue.contains(TIMER)) {
								outgoingResponseToOrig.setHeader(
										Constants.HDR_REQUIRE,
										requireHeaderValue);
								requireHeaderFound = true;
								break;
							}
						}
						if (!requireHeaderFound) {
							outgoingResponseToOrig.addHeader(
									Constants.HDR_REQUIRE, TIMER);
						}
						// --
					}
					if (logger.isDebugEnabled()) {
						logger.debug("session-expires header value set in responce of re-invite");
					}
					try {
						response.getSession().setAttribute(
								SBBOperationContext.ATTRIBUTE_SDP,
								response.getContent());
						response.getSession().setAttribute(
								SBBOperationContext.ATTRIBUTE_SDP_CONTENT_TYPE,
								response.getContentType());
					} catch (IOException e) {
						if (logger.isDebugEnabled()) {
							logger.debug("set SDP: " + e.getMessage());
						}
					}

				}
				// -------
				if (mp != null)
					outgoingResponseToOrig.setContent(mp, mp.getContentType());

				sendResponse(outgoingResponseToOrig, false);

				if (outgoingResponseToOrig.getSession().getId()
						.equalsIgnoreCase(sbb.getA().getId())) {
					if (outgoingResponseToOrig.getMethod().equalsIgnoreCase(
							Constants.METHOD_INVITE)
							&& outgoingResponseToOrig
									.getHeader(Constants.HDR_SESSION_EXPIRES) != null) {
						this.startSessionExpiryTimer(null,
								Constants.TIMER_FOR_A_PARTY,
								Constants.SESSION_EXPIRY_TIMER_FOR_A_PARTY);
					}

				} else {
					if (outgoingResponseToOrig.getMethod().equalsIgnoreCase(
							Constants.METHOD_INVITE)
							&& outgoingResponseToOrig
									.getHeader(Constants.HDR_SESSION_EXPIRES) != null) {
						this.startSessionExpiryTimer(null,
								Constants.TIMER_FOR_MS,
								Constants.SESSION_EXPIRY_TIMER_FOR_MS);
					}
				}

			} else {
				if (loggerEnabled) {
					logger.debug("<SBB> handleResponse(): Orig Request is NULL so cant relay to party A");
				}
			}

			// If this is a response to a BYE request, notify the app that the
			// connection is now terminated.
			if (response.getMethod().equals(Constants.METHOD_BYE)) {
				if (loggerEnabled) {
					logger.debug("handleResponse(): Dispatching DISCONNECTED event to event listener...");
				}
				// bye received dialog state must be terminated
				response.getSession().setAttribute(
						Constants.ATTRIBUTE_DIALOG_STATE,
						Constants.STATE_TERMINATED);
				if (logger.isDebugEnabled()) {
					logger.debug("200ok for bye recevied now dialog state is terminated.");
				}
				// dispatch event only if it is from IVR i.e party B
				// Removing the condition as in it should be generic to raise
				// the disconnected event
				// when BYE transaction between Party-A and Party-B is completed
				// that is final 200 OK response
				// for both BYE's have been exchanged.
				// if(response.getSession().getId().equalsIgnoreCase(sbb.getB().getId())){
				// handle 200ok of bye for session expired if timer timeout of A
				// party then its waiting for 2nd 200ok
				// and fire disconnect event and in case of ms timer timeout its
				// only fire event of session expired
				// String sessionExpired = (String)
				// response.getApplicationSession().getAttribute(Constants.SESSION_EXPIRED_OF);
				String sessionExpiredOfA = (String) sbb.getA().getAttribute(
						Constants.SESSION_EXPIRED_OF);
				String sessionExpiredOfMS = (String) sbb.getB().getAttribute(
						Constants.SESSION_EXPIRED_OF);

				if (sessionExpiredOfA != null) {
					sbb.getA().removeAttribute(Constants.SESSION_EXPIRED_OF);
					if (logger.isDebugEnabled()) {
						logger.debug("1st 200ok received of bye of session expired");
					}
					return;
				}

				if (sessionExpiredOfMS != null) {
					if (logger.isDebugEnabled()) {
						logger.debug("200ok received from media server");
					}
					sbb.getB().removeAttribute(Constants.SESSION_EXPIRED_OF);
					// In case, if ms already down then sbb not going to receive
					// 200ok for bye.
					// now ms session expired event fired when sbb send bye to
					// ms.
					/*
					 * SBBEvent event = new
					 * SBBEvent(SBBEvent.EVENT_MS_SESSION_EXPIRED);
					 * SBBOperationContext context = (SBBOperationContext)sbb;
					 * this.lastFiredEvent = SBBEvent.EVENT_MS_SESSION_EXPIRED;
					 * int responseCode = context.fireEvent(event);
					 * if(logger.isDebugEnabled()){
					 * logger.debug("event fired for ms_session_expired.."); }
					 */
					setCompleted(true);
					return;
				}

				// ----
				SBBEvent event = new SBBEvent(SBBEvent.EVENT_DISCONNECTED);
				SBBOperationContext context = (SBBOperationContext) sbb;
				this.lastFiredEvent = SBBEvent.EVENT_DISCONNECTED;
				int responseCode = context.fireEvent(event);
				setCompleted(true);
				// }
			} else {
				if (logger.isDebugEnabled()) {
					logger.debug("handleResponse(): Not Dispatching DISCONNECTED event to event listener as orig hung up...");
				}
			}

		} catch (Rel100Exception exp) {
			// should not happen as request is sent unreliably.
		} catch (IOException exp) {
			logger.error("<SBB> Unable to send reponse", exp);
		} catch (MessagingException e) {
			logger.error("<SBB> Unable to send reponse", e);
		}
		if (logger.isDebugEnabled()) {
			logger.debug("<SBB> exited handleResponse");
		}
	}

	private void setREL(SipServletMessage message) {
		byte[] rel_isup = (byte[]) this.getOperationContext().getSBB()
				.getAttribute(MsSessionController.REL_ISUP);
		try {

			if (rel_isup != null) {
				Multipart mp = new MimeMultipart();
				try {
					SBBResponseUtil.formMultiPartMessage(mp, rel_isup,
							Constants.ISUP_CONTENT_TYPE, null);
				} catch (MessagingException e) {
					logger.error(e.getMessage(), e);
				}
				this.getOperationContext().getSBB()
						.setAttribute(MsSessionController.REL_ISUP, null);
				message.setContent(mp, mp.getContentType());
			} else {
				if (logger.isDebugEnabled()) {
					logger.debug("REL is not set by Service");
				}
			}
		} catch (UnsupportedEncodingException e) {
			logger.error(e.getMessage(), e);
		}

	}

	public void readExternal(ObjectInput in) throws IOException,
			ClassNotFoundException {
		super.readExternal(in);
	}

	public void writeExternal(ObjectOutput out) throws IOException {
		super.writeExternal(out);
	}

	public String getDeltaSeconds(String sessionExpHeadVal) {
		int deltaSecIndex = sessionExpHeadVal.indexOf(AseStrings.SEMI_COLON, 0);
		String deltaSeconds = null;
		if (deltaSecIndex != -1)
			deltaSeconds = sessionExpHeadVal.substring(0, deltaSecIndex);
		else
			deltaSeconds = sessionExpHeadVal;
		if (logger.isDebugEnabled()) {
			logger.debug("delta Second:" + deltaSeconds);
		}
		return deltaSeconds.trim();
	}

	protected void startSessionExpiryTimer(SipServletRequest request,
			String servletTimer, String timerInSession) {
		SBB sbb = (SBB) getOperationContext();
		if (request != null) {
			if (request.getHeader("Session-Expires") != null) {
				if (logger.isDebugEnabled()) {
					logger.debug("re-Invite received and start session expiry timer for Session-Expires:"
							+ request.getHeader("Session-Expires"));
				}
				String deltaSecondsUAS = getDeltaSeconds(request
						.getHeader("Session-Expires"));
				long timerDuration = Long.valueOf(deltaSecondsUAS);
				timerDuration = timerDuration * 1000;
				TimerService ts = (TimerService) sbb.getServletContext()
						.getAttribute(SipServlet.TIMER_SERVICE);
				// ServletTimer
				// timer=ts.createTimer(request.getApplicationSession(),
				// timerDuration, false, new TimerInfo(servletTimer,this));
				// ----changes--------
				AseTimerInfo aseTimerInfo = new AseTimerInfo();
				aseTimerInfo.setSbbName(sbb.getName());
				ServletTimer timer = ts.createTimer(
						request.getApplicationSession(), timerDuration, true,
						aseTimerInfo);
				TimerInfo timerInfo = new TimerInfo(servletTimer,
						Constants.SESSION_REFRESH_TIMER);
				((SBBImpl) sbb).setServletTimer(timer.getId(), timerInfo);

				// -------------------
				request.getSession()
						.setAttribute(timerInSession, timer.getId());
				if (logger.isDebugEnabled()) {
					logger.debug("timer created " + timerInSession
							+ "and delta sec is " + deltaSecondsUAS);
				}

			} else {
				if (logger.isDebugEnabled()) {
					logger.debug("session-expires value is null, start session expiry timer and set initial value of session expires");
				}
				String deltaSecondsUAS = (String) reInvite.getSession()
						.getAttribute("SESSION_EXPIRES");
				long timerDuration = Long.valueOf(deltaSecondsUAS);
				timerDuration = timerDuration * 1000;
				TimerService ts = (TimerService) sbb.getServletContext()
						.getAttribute(SipServlet.TIMER_SERVICE);
				// ServletTimer
				// timer=ts.createTimer(request.getApplicationSession(),
				// timerDuration, false, new TimerInfo(servletTimer,this));
				// --changes for ft---------
				AseTimerInfo aseTimerInfo = new AseTimerInfo();
				aseTimerInfo.setSbbName(sbb.getName());
				ServletTimer timer = ts.createTimer(
						request.getApplicationSession(), timerDuration, true,
						aseTimerInfo);
				TimerInfo timerInfo = new TimerInfo(servletTimer,
						Constants.SESSION_REFRESH_TIMER);
				((SBBImpl) sbb).setServletTimer(timer.getId(), timerInfo);
				// ----------------------
				request.getSession()
						.setAttribute(timerInSession, timer.getId());
				if (logger.isDebugEnabled()) {
					logger.debug("timer created " + timerInSession
							+ "and delta sec is " + deltaSecondsUAS);
				}
			}

		} else {
			if (logger.isDebugEnabled()) {
				logger.debug("start session expiry timer and set initial value of session expires");
			}
			String deltaSecondsUAS = null;
			if (servletTimer.equals(Constants.TIMER_FOR_A_PARTY)) {
				deltaSecondsUAS = (String) sbb.getA().getAttribute(
						"SESSION_EXPIRES");
			} else {
				deltaSecondsUAS = (String) sbb.getB().getAttribute(
						"SESSION_EXPIRES");
			}
			long timerDuration = Long.valueOf(deltaSecondsUAS);
			timerDuration = timerDuration * 1000;
			TimerService ts = (TimerService) sbb.getServletContext()
					.getAttribute(SipServlet.TIMER_SERVICE);
			// ServletTimer timer=ts.createTimer(sbb.getApplicationSession(),
			// timerDuration, false, new TimerInfo(servletTimer,this));
			// --changes for ft---------
			AseTimerInfo aseTimerInfo = new AseTimerInfo();
			aseTimerInfo.setSbbName(sbb.getName());
			ServletTimer timer = ts.createTimer(sbb.getApplicationSession(),
					timerDuration, true, aseTimerInfo);
			TimerInfo timerInfo = new TimerInfo(servletTimer,
					Constants.SESSION_REFRESH_TIMER);
			((SBBImpl) sbb).setServletTimer(timer.getId(), timerInfo);
			// ----------------------
			// sbb.getApplicationSession().setAttribute(timerInSession, timer);
			if (servletTimer.equals(Constants.TIMER_FOR_A_PARTY)) {
				sbb.getA().setAttribute(timerInSession, timer.getId());
			} else {
				sbb.getB().setAttribute(timerInSession, timer.getId());
			}
			if (logger.isDebugEnabled()) {
				logger.debug("timer created " + timerInSession
						+ "and delta sec is " + deltaSecondsUAS);
			}
		}

	}

	private boolean cancelSessionExpiryTimer(String str) {
		SBB sbb = (SBB) this.getOperationContext();
		// ServletTimer timer = (ServletTimer)
		// sbb.getApplicationSession().getAttribute(str);
		ServletTimer timer = null;
		if (str.equals(Constants.SESSION_EXPIRY_TIMER_FOR_A_PARTY)
				&& sbb.getA() != null) {
			String timerId = (String) sbb.getA().getAttribute(str);
			if (timerId != null) {
				timer = sbb.getA().getApplicationSession().getTimer(timerId);
			}
		} else if (sbb.getB() != null) {
			String timerId = (String) sbb.getB().getAttribute(str);
			if (timerId != null) {
				timer = sbb.getB().getApplicationSession().getTimer(timerId);
			}
		}
		if (timer != null) {
			timer.cancel();
			if (logger.isDebugEnabled()) {
				logger.debug("session Expires timer cancel " + str);
			}
			if (str.equals(Constants.SESSION_EXPIRY_TIMER_FOR_A_PARTY)) {
				sbb.getA().removeAttribute(str);
				if (logger.isDebugEnabled()) {
					logger.debug("session expires timer attribute remove for A-party");
				}
			} else {
				sbb.getB().removeAttribute(str);
				if (logger.isDebugEnabled()) {
					logger.debug("session expires timer attribute remove for B-party");
				}
			}
			return true;
		}
		return false;
	}

	public void postSessionExpiry(String timerType) {

		SBB sbb = (SBB) this.getOperationContext();
		// sbb.getApplicationSession().setAttribute(Constants.SESSION_EXPIRED_OF,
		// timerType);
		/*
		 * this.cancelSessionExpiryTimer(Constants.SESSION_EXPIRY_TIMER_FOR_A_PARTY
		 * );
		 * this.cancelSessionExpiryTimer(Constants.SESSION_EXPIRY_TIMER_FOR_MS);
		 */

		if (timerType.equals(Constants.TIMER_FOR_A_PARTY)) {
			if (logger.isDebugEnabled()) {
				logger.debug("session-expires timer timeout for A party");
			}
			sbb.getA().removeAttribute(
					Constants.SESSION_EXPIRY_TIMER_FOR_A_PARTY);
			if (logger.isDebugEnabled()) {
				logger.debug("attribute removed from sip session");
			}
			// cancel timer of ms , and timer for A already timeout
			this.cancelSessionExpiryTimer(Constants.SESSION_EXPIRY_TIMER_FOR_MS);
			sbb.getA().setAttribute(Constants.SESSION_EXPIRED_OF,
					Constants.TIMER_FOR_A_PARTY);

			SipServletRequest aByeOut = sbb.getA().createRequest(
					Constants.METHOD_BYE);

			String NotifyExpiry = BaseContext.getConfigRepository().getValue(
					Constants.NOTIFY_SESSION_EXPIRY_A_TOAPP);

			if (logger.isDebugEnabled()) {
				logger.debug("notify.session.expiry.orig.toapp property is "
						+ NotifyExpiry);
			}

			if (NotifyExpiry != null) {

				try {
					// sends normal SIP bye request to A-party
					this.sendRequest(aByeOut);
					// ---------------
				} catch (Exception e) {
					logger.error(e.getMessage(), e);
				}

				boolean notifyASessionExpiry = Boolean
						.parseBoolean(NotifyExpiry);

				if (logger.isDebugEnabled()) {
					logger.debug("do we need to notifyASessionExpiry "
							+ notifyASessionExpiry);
				}

				if (notifyASessionExpiry) {

					if (logger.isDebugEnabled()) {
						logger.debug("Going to notifyASession expiry as EVENT_SIG_IN_PROGRESS as BYE to A is sent ");
					}
					SBBEvent event = new SBBEvent(
							SBBEvent.EVENT_SIG_IN_PROGRESS);
					event.setMessage(aByeOut);
					SBBOperationContext context = (SBBOperationContext) sbb;
					this.lastFiredEvent = SBBEvent.EVENT_SIG_IN_PROGRESS;
					int responseCode = context.fireEvent(event);
					if (logger.isDebugEnabled()) {
						logger.debug("event EVENT_SIG_IN_PROGRESS fired for a_session_expired.. as notifyASessionExpiry flag is ON in ase.properties");
					}
					return;
				}
			} else {

				try {
					// creating rel bye-------------
					byte relCauseByte = (byte) ((1 << 7) | releaseCause);
					rel_isup[((rel_isup.length) - 1)] = relCauseByte;
					Multipart mp = new MimeMultipart();
					if (logger.isInfoEnabled()) {
						logger.info("setting REL in bye to Party A");
					}
					String contentType = getIsupContentTypeForA();
					if (contentType == null) {
						SBBResponseUtil.formMultiPartMessage(mp, rel_isup,
								Constants.ISUP_CONTENT_TYPE, null);
					} else {
						SBBResponseUtil.formMultiPartMessage(mp, rel_isup,
								contentType, null);
					}
					aByeOut.addHeader(Constants.HDR_REASON, "Q.850;cause="
							+ releaseCause);
					aByeOut.setContent(mp, mp.getContentType());
					// sends bye request to A-party
					this.sendRequest(aByeOut);
					// ---------------

				} catch (MessagingException me) {
					logger.error(me.getMessage(), me);
				} catch (IOException e) {
					logger.error(e.getMessage(), e);
				} catch (Exception e) {
					logger.error(e.getMessage(), e);
				}

			}

			/*
			 * check for any media playing if stopPlay() retuen true ms
			 * disconnected from MediaServerInfoHAndler when received final INFO
			 * request.
			 */
			if (this.stopPlay()) {
				return;
			}

			SipServletRequest bByeOut = sbb.getB().createRequest(
					Constants.METHOD_BYE);
			try {
				// this.sendRequest(aByeOut);
				this.sendRequest(bByeOut);
			} catch (IOException e) {
				logger.error(e.getMessage(), e);
			}

		} else if (timerType.equals(Constants.TIMER_FOR_MS)) {
			if (logger.isDebugEnabled()) {
				logger.debug("session-expires timer timeout for ms");
			}
			sbb.getB().removeAttribute(Constants.SESSION_EXPIRY_TIMER_FOR_MS);
			if (logger.isDebugEnabled()) {
				logger.debug("attribute removed from sip session");
			}
			this.cancelSessionExpiryTimer(Constants.SESSION_EXPIRY_TIMER_FOR_A_PARTY);
			sbb.getB().setAttribute(Constants.SESSION_EXPIRED_OF,
					Constants.TIMER_FOR_MS);
			SipServletRequest bByeOut = sbb.getB().createRequest(
					Constants.METHOD_BYE);
			try {
				this.sendRequest(bByeOut);
				if (logger.isDebugEnabled()) {
					logger.debug("bye sends to ms.....");
				}
				SBBEvent event = new SBBEvent(SBBEvent.EVENT_MS_SESSION_EXPIRED);
				SBBOperationContext context = (SBBOperationContext) sbb;
				this.lastFiredEvent = SBBEvent.EVENT_MS_SESSION_EXPIRED;
				int responseCode = context.fireEvent(event);
				if (logger.isDebugEnabled()) {
					logger.debug("event fired for ms_session_expired..");
				}
			} catch (IOException e) {
				logger.error(e.getMessage(), e);
			}
		} else if (timerType.equals(Constants.TIMER_FOR_REQ_PEND)) {
			logger.error("Timer fires for Request pending scenario");
			SipServletRequest tempReInvite = null;
			try {
				if (sessRefReqOut != null) {
					tempReInvite = sessRefReqOut.getSession().createRequest(
							Constants.METHOD_INVITE);
					if (sessRefReqOut.getContentLength() > 0) {
						tempReInvite.setContent(sessRefReqOut.getContent(),
								sessRefReqOut.getContentType());
						tempReInvite
								.setHeader(
										Constants.HDR_CONTENT_DISPOSITION,
										Constants.DEFAULT_VALUE_SDP_CONTENT_DISPOSITION);
					}
					this.setHeadersOnOutRequest(sessRefReqOut, tempReInvite);

					if (logger.isDebugEnabled()) {
						logger.debug("postSessionExpiry(): PIGGY_BACK_ORIG_REQ is  ..."
								+ sessRefReqOut
										.getAttribute(Constants.PIGGY_BACK_ORIG_REQ));
					}
					tempReInvite
							.setAttribute(
									Constants.PIGGY_BACK_ORIG_REQ,
									sessRefReqOut
											.getAttribute(Constants.PIGGY_BACK_ORIG_REQ));
					sessRefReqOut = tempReInvite;
					sendRequest(sessRefReqOut);
					logger.error("Re-Invite again sent for 491 received");
				} else {
					// If the code is there then the race condition occured in
					// cases other than
					// those happening when Party-A and Media Server are over
					// wire.
					logger.error("Not able to send Re-Invite again for 491 received");
				}
			} catch (IOException e) {
				logger.error(e.getMessage(), e);
			}
		}
	}

	protected String getIsupContentTypeForA() {
		String contentType = null;
		SBB sbb = (SBB) this.getOperationContext();
		SipServletRequest requestIn = (SipServletRequest) sbb
				.getApplicationSession().getAttribute(Constants.REQUEST_FROM_A);
		try {
			if (requestIn.getContentType().startsWith(
					Constants.SDP_MULTIPART_MIXED)) {
				MimeMultipart mimeMultipart = (MimeMultipart) requestIn
						.getContent();
				for (int indx = 0; indx < mimeMultipart.getCount(); indx++) {
					BodyPart bodyPart = mimeMultipart.getBodyPart(indx);
					if (bodyPart.getContentType().startsWith(
							Constants.ISUP_CONTENT_TYPE)) {
						contentType = bodyPart.getContentType();
					}
				}
			}
		} catch (UnsupportedEncodingException e) {
			logger.error(e.getMessage(), e);
		} catch (IOException e) {
			logger.error(e.getMessage(), e);
		} catch (MessagingException e) {
			logger.error(e.getMessage(), e);
		}
		return contentType;
	}

	// this method called when re-invite received for update sdp and
	// something playing that time from ms . so first stop playing media
	// then send re-invite through MediaServerInfoHandler when stop operation
	// successful received in handleRequest method.
	private void handleUpdateSDP() {
		SBB sbb = (SBB) this.getOperationContext();
		try {
			Iterator itr = ((SBBImpl) sbb).getOperations().iterator();
			while (itr.hasNext()) {
				SBBOperation oper = (SBBOperation) itr.next();
				if (oper instanceof MediaServerInfoHandler) {
					this.operation = ((MediaServerInfoHandler) oper)
							.getOperation();
					// Modified the implementation as same for both play as well
					// as
					// play_collect or play_record operations.
					if ((this.operation == PLAY)
							|| (this.operation == PLAY_COLLECT)
							|| (this.operation == PLAY_RECORD)) {

						((GroupedMsSessionControllerImpl) sbb)
								.stopMediaOperations(this);
						playMedia = true;
						// StopMediaOperation called..now re-invite send by
						// MediaServerInfoHandler when 200ok received for
						// Stop completed
						/*
						 * sbb.setAttribute(MsSessionController.
						 * RE_INVITE_WITH_NEW_SDP, request);
						 * if(logger.isDebugEnabled()){ logger.debug(
						 * "StopMediaOperation called..now re-invite send by MediaServerInfoHandler."
						 * ); }
						 */
						return;
					}
				}
			}

		} catch (Exception e) {
			logger.error(e.getMessage(), e);
		}

	}

	// this method called when 200ok received for re-invite
	private void holdUnholdFireEvent(SipServletRequest request) {
		Pattern p = null;
		Matcher m = null;
		boolean ipFound = false;
		boolean sendOnly = false;

		try {
			SBBOperationContext operCtx = (SBBOperationContext) getOperationContext();
			byte[] sdpByteValue = this.getSDP(request.getContent());
			String sdp = null;
			if (sdpByteValue != null) {
				sdp = new String(sdpByteValue).trim();
				// ip 0.0.0.0 check
				p = Pattern.compile("c(\\s*)=(.*)0.0.0.0");
				m = p.matcher(sdp);
				ipFound = m.find();
				// a=sandonly check
				p = Pattern.compile("a(\\s*)=(\\s*)sendonly");
				m = p.matcher(sdp);
				sendOnly = m.find();
				if (!callInHold) {
					// fire event for hold
					if (ipFound || sendOnly) {
						if (logger.isDebugEnabled()) {
							logger.debug("<SBB> now call in hold..");
						}
						SBBEvent holdCompleted = new SBBEvent(
								SBBEvent.EVENT_HOLD_COMPLETE);
						holdCompleted.setMessage(request);
						// this.lastFiredEvent = SBBEvent.EVENT_HOLD_COMPLETE;
						int responseFromApp = operCtx.fireEvent(holdCompleted);
						if (logger.isDebugEnabled()) {
							logger.debug("hold completed event fired and app return::"
									+ responseFromApp);
						}
						callInHold = true;
					}
				} else if (!ipFound && !sendOnly) {
					// fire event for unhold
					if (logger.isDebugEnabled()) {
						logger.debug("<SBB> call unhold......");
					}
					SBBEvent unHoldCompleted = new SBBEvent(
							SBBEvent.EVENT_UNHOLD_COMPLETED);
					unHoldCompleted.setMessage(request);
					// this.lastFiredEvent = SBBEvent.EVENT_UNHOLD_COMPLETED;
					int responseFromApp = operCtx.fireEvent(unHoldCompleted);
					if (logger.isDebugEnabled()) {
						logger.debug("call unhold completed event fired and app return::"
								+ responseFromApp);
					}
					callInHold = false;
				}
			}

		} catch (IOException e) {
			logger.error(e.getMessage(), e);
		} catch (Exception e) {
			logger.error(e.getMessage(), e);
		}

	}

	// check for hold request
	private boolean isHoldRequest(SipServletRequest request) {
		Pattern p = null;
		Matcher m = null;
		boolean ipFound = false;
		boolean sendOnly = false;
		try {
			SBBOperationContext operCtx = (SBBOperationContext) getOperationContext();
			byte[] sdpByteValue = this.getSDP(request.getContent());
			String sdp = null;
			if (sdpByteValue != null) {
				sdp = new String(sdpByteValue).trim();
				// ip 0.0.0.0 check
				p = Pattern.compile("c(\\s*)=(.*)0.0.0.0");
				m = p.matcher(sdp);
				ipFound = m.find();
				// a=sandonly check
				p = Pattern.compile("a(\\s*)=(\\s*)sendonly");
				m = p.matcher(sdp);
				sendOnly = m.find();
				return ipFound || sendOnly;
			}

		} catch (IOException e) {
			logger.error(e.getMessage(), e);
		} catch (Exception e) {
			logger.error(e.getMessage(), e);
		}
		return false;
	}

	// --------------------------

	private void setHeadersOnOutRequest(SipServletRequest request,
			SipServletRequest outReq) {

		String where = "setHeadersOnOutRequest()";
		if (logger.isDebugEnabled()) {
			logger.debug("Entering....." + where);
		}
		Iterator itr = request.getHeaderNames();

		while (itr.hasNext()) {
			String name = (String) itr.next();

			// Content type check applied as it will be updated afterwards
			// depending upon whether
			// content is present in the incoming request or sdp set by the
			// service
			if (!name.equals("From") && !name.equals("To")
					&& !name.equals("Via") && !name.equalsIgnoreCase("CSeq")
					&& !name.equals("Route")
					&& !name.equalsIgnoreCase("Call-ID")
					&& !name.equals("Record-Route") && !name.equals("Contact")
					&& !name.equals("Allow")
					&& !name.equalsIgnoreCase("Content-Length")
					&& !name.equalsIgnoreCase("Content-Type")) {

				/*
				 * Do not set system headers, Allow is also set by the IMX so
				 * not setting it
				 */
				ListIterator pai = request.getHeaders(name);
				if (logger.isDebugEnabled()) {
					logger.debug("<SBB> getting Headers for name " + name);
				}

				while (pai != null && pai.hasNext()) {
					String value = (String) pai.next();
					if (logger.isDebugEnabled()) {
						logger.debug("Setting Sip Header Value for Header Name "
								+ name + " is..." + value);
					}
					outReq.addHeader(name, value);
				}
			}
		}
		if (logger.isDebugEnabled()) {
			logger.debug("Leaving....." + where);
		}
	}

	// in case of multipart content type
	private byte[] getSDP(Object content) {
		byte[] bp = null;
		if (content != null) {
			if (content instanceof byte[]) {
				return (byte[]) content;
			}
			if (content instanceof String) {
				bp = ((String) content).getBytes();
				return bp;
			}
			// in case of multipart
			try {
				int sdpBpIndx = -1;
				MimeMultipart multipart = null;
				multipart = (MimeMultipart) content;
				int count = multipart.getCount();
				for (int i = 0; i < count; i++) {
					if (multipart.getBodyPart(i).getContentType()
							.startsWith(Constants.SDP_CONTENT_TYPE)) {
						sdpBpIndx = i;
						break;
					}
				}
				if (sdpBpIndx != -1) {

					ByteArrayInputStream bis = (ByteArrayInputStream) multipart
							.getBodyPart(sdpBpIndx).getContent();
					int bytes = bis.available();
					bp = new byte[bytes];
					bis.read(bp, 0, bytes);

					return bp;
				}

			} catch (MessagingException e) {
				logger.error("Exception in returning SDP " + e);
			} catch (Exception e) {
				logger.error("Exception in returning SDP " + e);
			}
			if (logger.isDebugEnabled()) {
				logger.debug("sdp not found in multipart message");
			}
		}

		return null;
	}

	// in case of re-invite for update sdp or for hold/unhold case
	// first stop record operation then send re-invite to other party
	public void sendReInviteRequest() {
		SBB sbb = (SBB) this.getOperationContext();
		SipServletRequest requestOut = null;
		try {
			SipServletRequest reInviteRequest = this.reInviteRequest;

			requestOut = sbb.getB().createRequest(Constants.METHOD_INVITE);
			this.setHeadersOnOutRequest(reInviteRequest, requestOut);
			// add supported header..
			String supportedHeaderValue = null;
			boolean suppHeaderFound = false;
			Iterator valueList = requestOut.getHeaders(Constants.HDR_SUPPORTED);
			while (valueList.hasNext()) {
				supportedHeaderValue = (String) valueList.next();
				if (supportedHeaderValue.contains(TIMER)) {
					requestOut.setHeader(Constants.HDR_SUPPORTED,
							supportedHeaderValue);
					suppHeaderFound = true;
					break;
				}
			}
			if (!suppHeaderFound) {
				requestOut.addHeader(Constants.HDR_SUPPORTED, TIMER);
			}
			// add session-expires header...
			if (sbb.getB().getAttribute("SESSION_EXPIRES") != null) {
				String sessionExpiresValue = (String) sbb.getB().getAttribute(
						"SESSION_EXPIRES")
						+ ";refresher=uas";
				requestOut.setHeader(Constants.HDR_SESSION_EXPIRES,
						sessionExpiresValue);
			}
			// add MIN_SE header...
			if (sbb.getB().getAttribute("MIN_SE") != null) {
				String deltaSec = (String) sbb.getB().getAttribute("MIN_SE");
				requestOut.setHeader(Constants.HDR_MIN_SE, deltaSec);
			}
			if (logger.isDebugEnabled()) {
				logger.debug("session-exprires headers are set....");
			}
			if (logger.isDebugEnabled()) {
				logger.debug("postSessionExpiry(): PIGGY_BACK_ORIG_REQ is  ..."
						+ reInviteRequest);
			}
			requestOut.setAttribute(Constants.PIGGY_BACK_ORIG_REQ,
					reInviteRequest);
			requestOut.setContent(reInviteRequest.getContent(),
					reInviteRequest.getContentType());
			if (logger.isDebugEnabled()) {
				logger.debug("relay re-invite with session-expires header changes");
			}
			sendRequest(requestOut);
			// UAT-745
			// requestOut.getSession().setAttribute(Constants.PENDING_REQUEST,
			// true);
			this.cancelSessionExpiryTimer(Constants.SESSION_EXPIRY_TIMER_FOR_MS);

		} catch (IOException e) {
			logger.error(e.getMessage(), e);
		} catch (Exception e) {
			logger.error(e.getMessage(), e);
		}

	}

	private void addHeaders(SipServletRequest request, SipServletResponse resp,
			SBB sbb) {
		// set supported header
		String supportedHeaderValue = null;
		Iterator valueList = request.getHeaders(Constants.HDR_SUPPORTED);
		boolean suppTimerFound = false;
		while (valueList.hasNext()) {
			supportedHeaderValue = (String) valueList.next();
			if (supportedHeaderValue.contains(TIMER)) {
				resp.setHeader(Constants.HDR_SUPPORTED, supportedHeaderValue);
				suppTimerFound = true;
				break;
			}
		}
		if (!suppTimerFound) {
			resp.addHeader(Constants.HDR_SUPPORTED, TIMER);
		}
		try {
			resp.setContent(
					sbb.getAttribute(SBBOperationContext.ATTRIBUTE_SDP_PARTY_B),
					(String) sbb
							.getAttribute(SBBOperationContext.ATTRIBUTE_SDP_PARTY_B_CONTENT_TYPE));
		} catch (UnsupportedEncodingException e) {
			logger.error(e.getMessage(), e);
		}
	}

	/**
	 * this method is used to handle session refresh for update from orig
	 * 
	 * @param request
	 * @param sbb
	 * @param partyB
	 */
	boolean handleSessionRefreshForUpdate(SipServletRequest request, SBB sbb) {

		boolean relayRequest = true;
		/*
		 * cancel then start new session expiry timer for session refresh
		 * re-invite
		 */
		if (logger.isDebugEnabled()) {
			logger.debug("handleSessionRefreshForUpdate partyA sends session refresh "
					+ request.getMethod());
		}
		if (request.getHeader(Constants.HDR_SESSION_EXPIRES) != null) {

			if (logger.isDebugEnabled()) {
				logger.debug("handleSessionRefreshForUpdate Session-Expires header found need to check for expiry timer ");
			}

			if (sbb.getA().equals(request.getSession())) {
				this.cancelSessionExpiryTimer(Constants.SESSION_EXPIRY_TIMER_FOR_A_PARTY);
			} else if (sbb.getB().equals(request.getSession())) {
				this.cancelSessionExpiryTimer(Constants.SESSION_EXPIRY_TIMER_FOR_MS);
			}
			request.getSession().setAttribute(
					"SESSION_EXPIRES",
					this.getDeltaSeconds(request
							.getHeader(Constants.HDR_SESSION_EXPIRES)));

			// send 200 ok response
			if (request.getContentLength() == 0) {
				relayRequest = false;

				// creating response 200 ok
				SipServletResponse resp = request.createResponse(200);
				// add require header
				resp.addHeader(Constants.HDR_REQUIRE, TIMER);

				String supportedHeaderValue = null;
				boolean suppTimerFound = false;
				Iterator valueList = request
						.getHeaders(Constants.HDR_SUPPORTED);
				while (valueList.hasNext()) {
					supportedHeaderValue = (String) valueList.next();
					if (supportedHeaderValue.contains(TIMER)) {
						resp.setHeader(Constants.HDR_SUPPORTED,
								supportedHeaderValue);
						suppTimerFound = true;
						break;
					}
				}
				if (!suppTimerFound) {
					resp.addHeader(Constants.HDR_SUPPORTED, TIMER);
				}
				// add session-expires header filed in 200ok of re-invite for
				// session refresh
				if (request.getHeader(Constants.HDR_SESSION_EXPIRES) != null) {
					String value = this.getDeltaSeconds(request
							.getHeader(Constants.HDR_SESSION_EXPIRES))
							+ ";refresher=uac";
					resp.addHeader(Constants.HDR_SESSION_EXPIRES, value);

				}
				try {

					if (logger.isDebugEnabled()) {
						logger.debug("send 200 for  session-refresh UPDATE request as content length is zero-> will not relay this UPDATE request ");
					}
					sendResponse(resp, false);
				} catch (IOException e) {
					logger.error(e.getMessage(), e);
				} catch (Rel100Exception e) {
					logger.error(e.getMessage(), e);
				}
			}

			if (sbb.getA().equals(request.getSession())) {
				this.startSessionExpiryTimer(request,
						Constants.TIMER_FOR_A_PARTY,
						Constants.SESSION_EXPIRY_TIMER_FOR_A_PARTY);
			} else if (sbb.getB().equals(request.getSession())) {
				this.startSessionExpiryTimer(request, Constants.TIMER_FOR_MS,
						Constants.SESSION_EXPIRY_TIMER_FOR_MS);
			}
		}
		return relayRequest;
	}

}